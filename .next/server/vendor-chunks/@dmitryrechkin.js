"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@dmitryrechkin";
exports.ids = ["vendor-chunks/@dmitryrechkin"];
exports.modules = {

/***/ "(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONSchemaToZod: () => (/* binding */ JSONSchemaToZod)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/ZodError.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/v3/types.js\");\n/* harmony import */ var _Type_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Type.js */ \"(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js\");\n\n\nclass JSONSchemaToZod {\n    /**\n     * Converts a JSON schema to a Zod schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodSchema} - The Zod schema.\n     */\n    static convert(schema) {\n        return this.parseSchema(schema);\n    }\n    /**\n     * Checks if data matches a condition schema.\n     *\n     * @param {JSONValue} data - The data to check.\n     * @param {JSONSchema} condition - The condition schema.\n     * @returns {boolean} - Whether the data matches the condition.\n     */\n    static matchesCondition(data, condition) {\n        // If no properties to check, condition is met\n        if (!condition.properties) {\n            return true;\n        }\n        // If data is not an object or is null, it can't match a schema with properties\n        if (typeof data !== 'object' || data === null || Array.isArray(data)) {\n            return false;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        // Check all property conditions\n        for (const [key, propCondition] of Object.entries(condition.properties)) {\n            // If property doesn't exist in data\n            if (!(key in objectData)) {\n                // If there's a const condition and property is missing, it doesn't match\n                if ('const' in propCondition) {\n                    return false;\n                }\n                // For other conditions, skip this property\n                continue;\n            }\n            const value = objectData[key];\n            // Check for const condition\n            if ('const' in propCondition && value !== propCondition['const']) {\n                return false;\n            }\n            // Check for minimum condition\n            if ('minimum' in propCondition && typeof value === 'number' && value < propCondition['minimum']) {\n                return false;\n            }\n            // Check for maximum condition\n            if ('maximum' in propCondition && typeof value === 'number' && value > propCondition['maximum']) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Validates data against a conditional schema and adds issues to context if validation fails.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The conditional schema.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateConditionalSchema(data, schema, ctx) {\n        this.validateRequiredProperties(data, schema, ctx);\n        this.validatePropertyPatterns(data, schema, ctx);\n        this.validateNestedConditions(data, schema, ctx);\n    }\n    /**\n     * Validates that all required properties are present in the data.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing required properties.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateRequiredProperties(data, schema, ctx) {\n        if (!schema.required) {\n            return;\n        }\n        // If data is not an object or is null, all required properties are missing\n        if (typeof data !== 'object' || data === null) {\n            for (const requiredProp of schema.required) {\n                ctx.addIssue({\n                    code: zod__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.custom,\n                    message: `Required property '${requiredProp}' is missing`,\n                    path: [requiredProp]\n                });\n            }\n            return;\n        }\n        // Now we know data is an object (either a plain object or an array)\n        for (const requiredProp of schema.required) {\n            if (!(requiredProp in data)) {\n                ctx.addIssue({\n                    code: zod__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.custom,\n                    message: `Required property '${requiredProp}' is missing`,\n                    path: [requiredProp]\n                });\n            }\n        }\n    }\n    /**\n     * Validates property patterns for string properties.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing property patterns.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validatePropertyPatterns(data, schema, ctx) {\n        if (!schema.properties) {\n            return;\n        }\n        // If data is not an object or is null, we can't validate property patterns\n        if (typeof data !== 'object' || data === null) {\n            return;\n        }\n        // If data is an array, we can't validate property patterns\n        if (Array.isArray(data)) {\n            return;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        // Process each property in the schema\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            // Skip if property doesn't exist in data\n            if (!(key in objectData)) {\n                continue;\n            }\n            const value = objectData[key];\n            // Check pattern validation for strings\n            if (propSchema['pattern'] && typeof value === 'string') {\n                const regex = new RegExp(propSchema['pattern']);\n                if (!regex.test(value)) {\n                    ctx.addIssue({\n                        code: zod__WEBPACK_IMPORTED_MODULE_1__.ZodIssueCode.custom,\n                        message: `String '${value}' does not match pattern '${propSchema['pattern']}'`,\n                        path: [key]\n                    });\n                }\n            }\n        }\n    }\n    /**\n     * Validates nested if-then-else conditions.\n     *\n     * @param {JSONValue} data - The data to validate.\n     * @param {JSONSchema} schema - The schema containing if-then-else conditions.\n     * @param {z.RefinementCtx} ctx - The Zod refinement context.\n     */\n    static validateNestedConditions(data, schema, ctx) {\n        if (!schema['if'] || !schema['then']) {\n            return;\n        }\n        const matchesIf = this.matchesCondition(data, schema['if']);\n        if (matchesIf) {\n            this.validateConditionalSchema(data, schema['then'], ctx);\n        }\n        else if (schema['else']) {\n            this.validateConditionalSchema(data, schema['else'], ctx);\n        }\n    }\n    /**\n     * Parses a JSON schema and returns the corresponding Zod schema.\n     * This is the main entry point for schema conversion.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseSchema(schema) {\n        // Handle array of types (e.g., ['string', 'null'] for nullable types)\n        if (Array.isArray(schema.type)) {\n            return this.handleTypeArray(schema);\n        }\n        // Handle combinators (oneOf, anyOf, allOf)\n        if (schema.oneOf || schema.anyOf || schema.allOf) {\n            return this.parseCombinator(schema);\n        }\n        // Handle if-then-else conditional validation\n        if (schema['if'] && schema['then']) {\n            return this.parseObject(schema);\n        }\n        // Handle object schema without explicit type but with properties\n        if (schema.properties && (!schema.type || schema.type === 'object')) {\n            return this.parseObject(schema);\n        }\n        // Handle all other types\n        return this.handleSingleType(schema);\n    }\n    /**\n     * Handles schemas with an array of types.\n     *\n     * @param {JSONSchema} schema - The JSON schema with type array.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static handleTypeArray(schema) {\n        if (!Array.isArray(schema.type)) {\n            throw new Error('Expected schema.type to be an array');\n        }\n        // Check if the type array includes 'null' to create a nullable type\n        if (schema.type.includes('null')) {\n            return this.handleNullableType(schema);\n        }\n        // If no 'null' in the type array, handle as a union of types\n        return this.createUnionFromTypes(schema.type, schema);\n    }\n    /**\n     * Handles nullable types by creating a nullable schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema with nullable type.\n     * @returns {ZodTypeAny} - The nullable Zod schema.\n     */\n    static handleNullableType(schema) {\n        if (!Array.isArray(schema.type)) {\n            throw new Error('Expected schema.type to be an array');\n        }\n        // Create a copy of the schema without the 'null' type\n        const nonNullSchema = { ...schema };\n        nonNullSchema.type = schema.type.filter(t => t !== 'null');\n        // If there's only one type left, handle it as a single type and make it nullable\n        if (nonNullSchema.type.length === 1) {\n            const singleTypeSchema = this.handleSingleType({ ...schema, type: nonNullSchema.type[0] });\n            return singleTypeSchema.nullable();\n        }\n        // If multiple non-null types, create a union and make it nullable\n        const unionSchema = this.parseSchema(nonNullSchema);\n        return unionSchema.nullable();\n    }\n    /**\n     * Creates a union type from an array of types.\n     *\n     * @param {string[]} types - Array of type strings.\n     * @param {JSONSchema} baseSchema - The base schema to apply to each type.\n     * @returns {ZodTypeAny} - The union Zod schema.\n     */\n    static createUnionFromTypes(types, baseSchema) {\n        const schemas = types.map(type => {\n            const singleTypeSchema = { ...baseSchema, type };\n            return this.parseSchema(singleTypeSchema);\n        });\n        return zod__WEBPACK_IMPORTED_MODULE_2__.union(schemas);\n    }\n    /**\n     * Handles schemas with a single type.\n     *\n     * @param {JSONSchema} schema - The JSON schema with single type.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static handleSingleType(schema) {\n        // Handle schemas without a type property\n        if (schema.type === undefined) {\n            // Check for combinators first\n            if (schema.oneOf || schema.anyOf || schema.allOf) {\n                return this.parseCombinator(schema);\n            }\n            // Check for object properties\n            if (schema.properties) {\n                return this.parseObject(schema);\n            }\n            // Default to any() for schemas with no type and no other indicators\n            return zod__WEBPACK_IMPORTED_MODULE_2__.any();\n        }\n        // Handle specific types\n        switch (schema.type) {\n            case 'string': return this.parseString(schema);\n            case 'number':\n            case 'integer': return this.parseNumberSchema(schema);\n            case 'boolean': return zod__WEBPACK_IMPORTED_MODULE_2__.boolean();\n            case 'array': return this.parseArray(schema);\n            case 'object': return this.parseObject(schema);\n            default: throw new Error('Unsupported schema type');\n        }\n    }\n    /**\n     * Parses a number schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for a number.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseNumberSchema(schema) {\n        let numberSchema = zod__WEBPACK_IMPORTED_MODULE_2__.number();\n        // Apply all number validations\n        let result = numberSchema;\n        result = this.applyNumberBounds(numberSchema, schema);\n        result = this.applyNumberMultipleOf(numberSchema, schema);\n        result = this.applyNumberEnum(numberSchema, schema);\n        result = this.applyIntegerConstraint(numberSchema, schema);\n        return result;\n    }\n    /**\n     * Applies bounds validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with bounds.\n     * @returns {z.ZodNumber} - The updated schema with bounds validation.\n     */\n    static applyNumberBounds(numberSchema, schema) {\n        let result = numberSchema;\n        if (schema['minimum'] !== undefined) {\n            result = schema['exclusiveMinimum'] ?\n                result.gt(schema['minimum']) :\n                result.gte(schema['minimum']);\n        }\n        if (schema['maximum'] !== undefined) {\n            result = schema['exclusiveMaximum'] ?\n                result.lt(schema['maximum']) :\n                result.lte(schema['maximum']);\n        }\n        return result;\n    }\n    /**\n     * Applies multipleOf validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with multipleOf.\n     * @returns {z.ZodNumber} - The updated schema with multipleOf validation.\n     */\n    static applyNumberMultipleOf(numberSchema, schema) {\n        if (schema['multipleOf'] === undefined) {\n            return numberSchema;\n        }\n        return numberSchema.refine(val => val % schema['multipleOf'] === 0, { message: `Number must be a multiple of ${schema['multipleOf']}` });\n    }\n    /**\n     * Applies enum validation to a number schema.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema with enum.\n     * @returns {z.ZodNumber} - The updated schema with enum validation.\n     */\n    static applyNumberEnum(numberSchema, schema) {\n        if (!schema.enum) {\n            return numberSchema;\n        }\n        // Filter out non-number values from enum\n        const numberEnums = schema.enum.filter(val => typeof val === 'number');\n        if (numberEnums.length === 0) {\n            return numberSchema;\n        }\n        // Use refinement to validate against enum values\n        return numberSchema.refine(val => numberEnums.includes(val), { message: `Number must be one of: ${numberEnums.join(', ')}` });\n    }\n    /**\n     * Applies integer constraint to a number schema if needed.\n     *\n     * @param {z.ZodNumber} numberSchema - The base number schema.\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {z.ZodNumber} - The updated schema with integer validation if needed.\n     */\n    static applyIntegerConstraint(numberSchema, schema) {\n        if (schema.type !== 'integer') {\n            return numberSchema;\n        }\n        return numberSchema.refine(val => Number.isInteger(val), { message: 'Number must be an integer' });\n    }\n    /**\n     * Parses a string schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for a string.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseString(schema) {\n        let stringSchema = zod__WEBPACK_IMPORTED_MODULE_2__.string();\n        let result = stringSchema;\n        // Apply all string validations\n        if (schema.format) {\n            // Handle format-specific string validation\n            return this.applyStringFormat(stringSchema, schema);\n        }\n        else {\n            // Only apply other validations if format is not specified\n            // or apply them to the formatted string\n            result = this.applyStringPattern(stringSchema, schema);\n            result = this.applyStringLength(stringSchema, schema);\n            result = this.applyStringEnum(stringSchema, schema);\n        }\n        return result;\n    }\n    /**\n     * Applies format validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with format.\n     * @returns {ZodTypeAny} - The updated schema with format validation.\n     */\n    static applyStringFormat(stringSchema, schema) {\n        if (!schema.format) {\n            return stringSchema;\n        }\n        switch (schema.format) {\n            case 'email':\n                return stringSchema.email();\n            case 'date-time':\n                return stringSchema.datetime();\n            case 'uri':\n                return stringSchema.url();\n            case 'uuid':\n                return stringSchema.uuid();\n            case 'date':\n                return stringSchema.date();\n            default:\n                return stringSchema;\n        }\n    }\n    /**\n     * Applies pattern validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with pattern.\n     * @returns {z.ZodString} - The updated schema with pattern validation.\n     */\n    static applyStringPattern(stringSchema, schema) {\n        if (!schema['pattern']) {\n            return stringSchema;\n        }\n        const regex = new RegExp(schema['pattern']);\n        return stringSchema.regex(regex, { message: `String must match pattern: ${schema['pattern']}` });\n    }\n    /**\n     * Applies length constraints to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with length constraints.\n     * @returns {z.ZodString} - The updated schema with length validation.\n     */\n    static applyStringLength(stringSchema, schema) {\n        let result = stringSchema;\n        if (schema['minLength'] !== undefined) {\n            stringSchema = stringSchema.min(schema['minLength']);\n        }\n        if (schema['maxLength'] !== undefined) {\n            stringSchema = stringSchema.max(schema['maxLength']);\n        }\n        return result;\n    }\n    /**\n     * Applies enum validation to a string schema.\n     *\n     * @param {z.ZodString} stringSchema - The base string schema.\n     * @param {JSONSchema} schema - The JSON schema with enum.\n     * @returns {ZodTypeAny} - The updated schema with enum validation.\n     */\n    static applyStringEnum(stringSchema, schema) {\n        if (!schema.enum) {\n            return stringSchema;\n        }\n        // Use refinement to validate against enum values\n        return stringSchema.refine((val) => schema.enum?.includes(val), {\n            message: `Value must be one of: ${schema.enum?.join(', ')}`\n        });\n    }\n    /**\n     * Parses a JSON schema of type array and returns the corresponding Zod schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseArray(schema) {\n        // Handle tuple validation (items is an array)\n        if (Array.isArray(schema.items)) {\n            const tupleSchemas = schema.items.map(item => this.parseSchema(item));\n            return zod__WEBPACK_IMPORTED_MODULE_2__.union(tupleSchemas);\n        }\n        // Create regular array schema\n        const itemSchema = schema.items ? this.parseSchema(schema.items) : zod__WEBPACK_IMPORTED_MODULE_2__.any();\n        let arraySchema = zod__WEBPACK_IMPORTED_MODULE_2__.array(itemSchema);\n        // Apply array constraints\n        let result = arraySchema;\n        result = this.applyArrayConstraints(arraySchema, schema);\n        return result;\n    }\n    /**\n     * Applies constraints to an array schema.\n     *\n     * @param {z.ZodArray<any>} arraySchema - The base array schema.\n     * @param {JSONSchema} schema - The JSON schema with array constraints.\n     * @returns {z.ZodTypeAny} - The updated array schema with constraints.\n     */\n    static applyArrayConstraints(arraySchema, schema) {\n        // Handle minItems\n        if (schema['minItems'] !== undefined) {\n            arraySchema = arraySchema.min(schema['minItems']);\n        }\n        // Handle maxItems\n        if (schema['maxItems'] !== undefined) {\n            arraySchema = arraySchema.max(schema['maxItems']);\n        }\n        // Handle uniqueItems\n        if (schema['uniqueItems']) {\n            return arraySchema.refine((items) => new Set(items).size === items.length, { message: 'Array items must be unique' });\n        }\n        return arraySchema;\n    }\n    /**\n     * Parses an object schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseObject(schema) {\n        // Handle conditional validation (if-then-else) first\n        if (schema['if'] && schema['then']) {\n            return this.parseConditional(schema);\n        }\n        // Create shape object for Zod\n        const shape = {};\n        // Process properties\n        this.processObjectProperties(schema, shape);\n        // Create the object schema and handle additionalProperties\n        return this.processAdditionalProperties(schema, zod__WEBPACK_IMPORTED_MODULE_2__.object(shape));\n    }\n    /**\n     * Processes object properties and builds the shape object.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @param {Record<string, ZodTypeAny>} shape - The shape object to populate.\n     */\n    static processObjectProperties(schema, shape) {\n        const required = new Set(schema.required || []);\n        if (!schema.properties) {\n            return;\n        }\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            const zodSchema = this.parseSchema(propSchema);\n            shape[key] = required.has(key) ? zodSchema : zodSchema.optional();\n        }\n    }\n    /**\n     * Processes additionalProperties configuration.\n     *\n     * @param {JSONSchema} schema - The JSON schema for an object.\n     * @param {z.ZodObject<any, any>} objectSchema - The Zod object schema.\n     * @returns {z.ZodObject<any, any>} - The updated Zod object schema.\n     */\n    static processAdditionalProperties(schema, objectSchema) {\n        if (schema.additionalProperties === true) {\n            return objectSchema.passthrough();\n        }\n        else if (schema.additionalProperties && typeof schema.additionalProperties === 'object') {\n            // Handle schema for additional properties\n            const additionalPropSchema = this.parseSchema(schema.additionalProperties);\n            return objectSchema.catchall(additionalPropSchema);\n        }\n        else {\n            return objectSchema.strict();\n        }\n    }\n    /**\n     * Parses a conditional schema with if-then-else.\n     *\n     * @param {JSONSchema} schema - The JSON schema with conditional validation.\n     * @returns {ZodTypeAny} - The conditional Zod schema.\n     */\n    static parseConditional(schema) {\n        // Create base object schema\n        const zodObject = this.createBaseObjectSchema(schema);\n        // Extract conditional parts\n        const ifCondition = schema['if'];\n        const thenSchema = schema['then'];\n        const elseSchema = schema['else'];\n        // Apply conditional validation using superRefine\n        return zodObject.superRefine((data, ctx) => {\n            // Apply default values to data for condition checking\n            const dataWithDefaults = this.applyDefaultValues(data, schema);\n            // Apply appropriate validation based on condition\n            if (this.matchesCondition(dataWithDefaults, ifCondition)) {\n                this.validateConditionalSchema(dataWithDefaults, thenSchema, ctx);\n            }\n            else if (elseSchema) {\n                this.validateConditionalSchema(dataWithDefaults, elseSchema, ctx);\n            }\n        });\n    }\n    /**\n     * Creates a base object schema from the given JSON schema.\n     *\n     * @param {JSONSchema} schema - The JSON schema.\n     * @returns {z.ZodObject<any, any>} - The base Zod object schema.\n     */\n    static createBaseObjectSchema(schema) {\n        const shape = {};\n        const required = new Set(schema.required || []);\n        for (const [key, value] of Object.entries(schema.properties || {})) {\n            const zodSchema = this.parseSchema(value);\n            shape[key] = required.has(key) ? zodSchema : zodSchema.optional();\n        }\n        const zodObject = zod__WEBPACK_IMPORTED_MODULE_2__.object(shape);\n        return this.processAdditionalProperties(schema, zodObject);\n    }\n    /**\n     * Applies default values from schema properties to data object.\n     *\n     * @param {JSONValue} data - The original data object.\n     * @param {JSONSchema} schema - The schema with default values.\n     * @returns {JSONValue} - The data object with defaults applied.\n     */\n    static applyDefaultValues(data, schema) {\n        // If data is not an object or is null, we can't apply defaults\n        if (typeof data !== 'object' || data === null) {\n            return data;\n        }\n        // If data is an array, we can't apply defaults from schema properties\n        if (Array.isArray(data)) {\n            return data;\n        }\n        // Now we know data is a JSONObject\n        const objectData = data;\n        const dataWithDefaults = { ...objectData };\n        if (!schema.properties) {\n            return dataWithDefaults;\n        }\n        for (const [key, propSchema] of Object.entries(schema.properties)) {\n            if (!(key in dataWithDefaults) && 'default' in propSchema) {\n                dataWithDefaults[key] = propSchema['default'];\n            }\n        }\n        return dataWithDefaults;\n    }\n    /**\n     * Parses a schema with combinators (oneOf, anyOf, allOf).\n     * Delegates to the appropriate combinator parser based on which combinator is present.\n     *\n     * @param {JSONSchema} schema - The JSON schema with combinators.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseCombinator(schema) {\n        if (schema.oneOf) {\n            return this.parseOneOf(schema.oneOf);\n        }\n        if (schema.anyOf) {\n            return this.parseAnyOf(schema.anyOf);\n        }\n        if (schema.allOf) {\n            return this.parseAllOf(schema.allOf);\n        }\n        // Should not reach here if schema has combinators\n        throw new Error('Unsupported schema type');\n    }\n    /**\n     * Parses a oneOf combinator schema.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the oneOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseOneOf(schemas) {\n        return this.createUnionFromSchemas(schemas);\n    }\n    /**\n     * Parses an anyOf combinator schema.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the anyOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseAnyOf(schemas) {\n        return this.createUnionFromSchemas(schemas);\n    }\n    /**\n     * Creates a union from an array of schemas, handling special cases.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas to create a union from.\n     * @returns {ZodTypeAny} - The union Zod schema.\n     */\n    static createUnionFromSchemas(schemas) {\n        // Handle empty array case\n        if (schemas.length === 0) {\n            return zod__WEBPACK_IMPORTED_MODULE_2__.any();\n        }\n        // Handle single schema case\n        if (schemas.length === 1) {\n            return this.parseSchema(schemas[0]);\n        }\n        // Process each subschema individually\n        const zodSchemas = [];\n        for (const subSchema of schemas) {\n            // Handle null type specially\n            if (subSchema.type === 'null') {\n                zodSchemas.push(zod__WEBPACK_IMPORTED_MODULE_2__[\"null\"]());\n            }\n            else {\n                zodSchemas.push(this.parseSchema(subSchema));\n            }\n        }\n        // Return appropriate schema based on number of valid schemas\n        if (zodSchemas.length >= 2) {\n            return zod__WEBPACK_IMPORTED_MODULE_2__.union(zodSchemas);\n        }\n        else if (zodSchemas.length === 1) {\n            return zodSchemas[0];\n        }\n        // Fallback if no valid schemas were created\n        return zod__WEBPACK_IMPORTED_MODULE_2__.any();\n    }\n    /**\n     * Parses an allOf combinator schema by merging all schemas.\n     *\n     * @param {JSONSchema[]} schemas - Array of JSON schemas in the allOf.\n     * @returns {ZodTypeAny} - The ZodTypeAny schema.\n     */\n    static parseAllOf(schemas) {\n        // Handle empty array case\n        if (schemas.length === 0) {\n            return zod__WEBPACK_IMPORTED_MODULE_2__.any();\n        }\n        // Handle single schema case\n        if (schemas.length === 1) {\n            return this.parseSchema(schemas[0]);\n        }\n        // Merge all schemas together\n        const mergedSchema = schemas.reduce((acc, currentSchema) => this.mergeSchemas(acc, currentSchema));\n        return this.parseSchema(mergedSchema);\n    }\n    /**\n     * Merges two JSON schemas together.\n     *\n     * @param {JSONSchema} baseSchema - The base JSON schema.\n     * @param {JSONSchema} addSchema - The JSON schema to add.\n     * @returns {JSONSchema} - The merged JSON schema\n     */\n    static mergeSchemas(baseSchema, addSchema) {\n        const merged = { ...baseSchema, ...addSchema };\n        if (baseSchema.properties && addSchema.properties) {\n            const mergedProperties = { ...baseSchema.properties, ...addSchema.properties };\n            merged.properties = mergedProperties;\n        }\n        if (baseSchema.required && addSchema.required) {\n            const mergedRequired = [...new Set([...baseSchema.required, ...addSchema.required])];\n            merged.required = mergedRequired;\n        }\n        return merged;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvSlNPTlNjaGVtYVRvWm9kLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBbUM7QUFDUjtBQUNwQjtBQUNQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsWUFBWTtBQUMzQixpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQixlQUFlLFlBQVk7QUFDM0IsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLGVBQWUsWUFBWTtBQUMzQixlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBYztBQUN4QyxtREFBbUQsYUFBYTtBQUNoRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw2Q0FBYztBQUN4QyxtREFBbUQsYUFBYTtBQUNoRTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUIsZUFBZSxZQUFZO0FBQzNCLGVBQWUsaUJBQWlCO0FBQ2hD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bmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvSlNPTlNjaGVtYVRvWm9kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHosIFpvZFNjaGVtYSB9IGZyb20gJ3pvZCc7XG5pbXBvcnQge30gZnJvbSAnLi9UeXBlLmpzJztcbmV4cG9ydCBjbGFzcyBKU09OU2NoZW1hVG9ab2Qge1xuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgSlNPTiBzY2hlbWEgdG8gYSBab2Qgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEuXG4gICAgICogQHJldHVybnMge1pvZFNjaGVtYX0gLSBUaGUgWm9kIHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY29udmVydChzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2hlbWEoc2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGRhdGEgbWF0Y2hlcyBhIGNvbmRpdGlvbiBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05WYWx1ZX0gZGF0YSAtIFRoZSBkYXRhIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gY29uZGl0aW9uIC0gVGhlIGNvbmRpdGlvbiBzY2hlbWEuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciB0aGUgZGF0YSBtYXRjaGVzIHRoZSBjb25kaXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIG1hdGNoZXNDb25kaXRpb24oZGF0YSwgY29uZGl0aW9uKSB7XG4gICAgICAgIC8vIElmIG5vIHByb3BlcnRpZXMgdG8gY2hlY2ssIGNvbmRpdGlvbiBpcyBtZXRcbiAgICAgICAgaWYgKCFjb25kaXRpb24ucHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZGF0YSBpcyBub3QgYW4gb2JqZWN0IG9yIGlzIG51bGwsIGl0IGNhbid0IG1hdGNoIGEgc2NoZW1hIHdpdGggcHJvcGVydGllc1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IGRhdGEgPT09IG51bGwgfHwgQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdyB3ZSBrbm93IGRhdGEgaXMgYSBKU09OT2JqZWN0XG4gICAgICAgIGNvbnN0IG9iamVjdERhdGEgPSBkYXRhO1xuICAgICAgICAvLyBDaGVjayBhbGwgcHJvcGVydHkgY29uZGl0aW9uc1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHByb3BDb25kaXRpb25dIG9mIE9iamVjdC5lbnRyaWVzKGNvbmRpdGlvbi5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgLy8gSWYgcHJvcGVydHkgZG9lc24ndCBleGlzdCBpbiBkYXRhXG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqZWN0RGF0YSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY29uc3QgY29uZGl0aW9uIGFuZCBwcm9wZXJ0eSBpcyBtaXNzaW5nLCBpdCBkb2Vzbid0IG1hdGNoXG4gICAgICAgICAgICAgICAgaWYgKCdjb25zdCcgaW4gcHJvcENvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEZvciBvdGhlciBjb25kaXRpb25zLCBza2lwIHRoaXMgcHJvcGVydHlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb2JqZWN0RGF0YVtrZXldO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbnN0IGNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKCdjb25zdCcgaW4gcHJvcENvbmRpdGlvbiAmJiB2YWx1ZSAhPT0gcHJvcENvbmRpdGlvblsnY29uc3QnXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBtaW5pbXVtIGNvbmRpdGlvblxuICAgICAgICAgICAgaWYgKCdtaW5pbXVtJyBpbiBwcm9wQ29uZGl0aW9uICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgPCBwcm9wQ29uZGl0aW9uWydtaW5pbXVtJ10pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbWF4aW11bSBjb25kaXRpb25cbiAgICAgICAgICAgIGlmICgnbWF4aW11bScgaW4gcHJvcENvbmRpdGlvbiAmJiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIHZhbHVlID4gcHJvcENvbmRpdGlvblsnbWF4aW11bSddKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgZGF0YSBhZ2FpbnN0IGEgY29uZGl0aW9uYWwgc2NoZW1hIGFuZCBhZGRzIGlzc3VlcyB0byBjb250ZXh0IGlmIHZhbGlkYXRpb24gZmFpbHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05WYWx1ZX0gZGF0YSAtIFRoZSBkYXRhIHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIGNvbmRpdGlvbmFsIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge3ouUmVmaW5lbWVudEN0eH0gY3R4IC0gVGhlIFpvZCByZWZpbmVtZW50IGNvbnRleHQuXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlQ29uZGl0aW9uYWxTY2hlbWEoZGF0YSwgc2NoZW1hLCBjdHgpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZVJlcXVpcmVkUHJvcGVydGllcyhkYXRhLCBzY2hlbWEsIGN0eCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGVQcm9wZXJ0eVBhdHRlcm5zKGRhdGEsIHNjaGVtYSwgY3R4KTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZU5lc3RlZENvbmRpdGlvbnMoZGF0YSwgc2NoZW1hLCBjdHgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgdGhhdCBhbGwgcmVxdWlyZWQgcHJvcGVydGllcyBhcmUgcHJlc2VudCBpbiB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlZhbHVlfSBkYXRhIC0gVGhlIGRhdGEgdG8gdmFsaWRhdGUuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgc2NoZW1hIGNvbnRhaW5pbmcgcmVxdWlyZWQgcHJvcGVydGllcy5cbiAgICAgKiBAcGFyYW0ge3ouUmVmaW5lbWVudEN0eH0gY3R4IC0gVGhlIFpvZCByZWZpbmVtZW50IGNvbnRleHQuXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlUmVxdWlyZWRQcm9wZXJ0aWVzKGRhdGEsIHNjaGVtYSwgY3R4KSB7XG4gICAgICAgIGlmICghc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZGF0YSBpcyBub3QgYW4gb2JqZWN0IG9yIGlzIG51bGwsIGFsbCByZXF1aXJlZCBwcm9wZXJ0aWVzIGFyZSBtaXNzaW5nXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZFByb3Agb2Ygc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogei5ab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgUmVxdWlyZWQgcHJvcGVydHkgJyR7cmVxdWlyZWRQcm9wfScgaXMgbWlzc2luZ2AsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IFtyZXF1aXJlZFByb3BdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IHdlIGtub3cgZGF0YSBpcyBhbiBvYmplY3QgKGVpdGhlciBhIHBsYWluIG9iamVjdCBvciBhbiBhcnJheSlcbiAgICAgICAgZm9yIChjb25zdCByZXF1aXJlZFByb3Agb2Ygc2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICBpZiAoIShyZXF1aXJlZFByb3AgaW4gZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB6LlpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBSZXF1aXJlZCBwcm9wZXJ0eSAnJHtyZXF1aXJlZFByb3B9JyBpcyBtaXNzaW5nYCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogW3JlcXVpcmVkUHJvcF1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZXMgcHJvcGVydHkgcGF0dGVybnMgZm9yIHN0cmluZyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OVmFsdWV9IGRhdGEgLSBUaGUgZGF0YSB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBzY2hlbWEgY29udGFpbmluZyBwcm9wZXJ0eSBwYXR0ZXJucy5cbiAgICAgKiBAcGFyYW0ge3ouUmVmaW5lbWVudEN0eH0gY3R4IC0gVGhlIFpvZCByZWZpbmVtZW50IGNvbnRleHQuXG4gICAgICovXG4gICAgc3RhdGljIHZhbGlkYXRlUHJvcGVydHlQYXR0ZXJucyhkYXRhLCBzY2hlbWEsIGN0eCkge1xuICAgICAgICBpZiAoIXNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgZGF0YSBpcyBub3QgYW4gb2JqZWN0IG9yIGlzIG51bGwsIHdlIGNhbid0IHZhbGlkYXRlIHByb3BlcnR5IHBhdHRlcm5zXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ29iamVjdCcgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGRhdGEgaXMgYW4gYXJyYXksIHdlIGNhbid0IHZhbGlkYXRlIHByb3BlcnR5IHBhdHRlcm5zXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm93IHdlIGtub3cgZGF0YSBpcyBhIEpTT05PYmplY3RcbiAgICAgICAgY29uc3Qgb2JqZWN0RGF0YSA9IGRhdGE7XG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBwcm9wZXJ0eSBpbiB0aGUgc2NoZW1hXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgcHJvcFNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMoc2NoZW1hLnByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAvLyBTa2lwIGlmIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3QgaW4gZGF0YVxuICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9iamVjdERhdGEpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdERhdGFba2V5XTtcbiAgICAgICAgICAgIC8vIENoZWNrIHBhdHRlcm4gdmFsaWRhdGlvbiBmb3Igc3RyaW5nc1xuICAgICAgICAgICAgaWYgKHByb3BTY2hlbWFbJ3BhdHRlcm4nXSAmJiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHByb3BTY2hlbWFbJ3BhdHRlcm4nXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogei5ab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYFN0cmluZyAnJHt2YWx1ZX0nIGRvZXMgbm90IG1hdGNoIHBhdHRlcm4gJyR7cHJvcFNjaGVtYVsncGF0dGVybiddfSdgLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogW2tleV1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFZhbGlkYXRlcyBuZXN0ZWQgaWYtdGhlbi1lbHNlIGNvbmRpdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05WYWx1ZX0gZGF0YSAtIFRoZSBkYXRhIHRvIHZhbGlkYXRlLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIHNjaGVtYSBjb250YWluaW5nIGlmLXRoZW4tZWxzZSBjb25kaXRpb25zLlxuICAgICAqIEBwYXJhbSB7ei5SZWZpbmVtZW50Q3R4fSBjdHggLSBUaGUgWm9kIHJlZmluZW1lbnQgY29udGV4dC5cbiAgICAgKi9cbiAgICBzdGF0aWMgdmFsaWRhdGVOZXN0ZWRDb25kaXRpb25zKGRhdGEsIHNjaGVtYSwgY3R4KSB7XG4gICAgICAgIGlmICghc2NoZW1hWydpZiddIHx8ICFzY2hlbWFbJ3RoZW4nXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hdGNoZXNJZiA9IHRoaXMubWF0Y2hlc0NvbmRpdGlvbihkYXRhLCBzY2hlbWFbJ2lmJ10pO1xuICAgICAgICBpZiAobWF0Y2hlc0lmKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ29uZGl0aW9uYWxTY2hlbWEoZGF0YSwgc2NoZW1hWyd0aGVuJ10sIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hWydlbHNlJ10pIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDb25kaXRpb25hbFNjaGVtYShkYXRhLCBzY2hlbWFbJ2Vsc2UnXSwgY3R4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBKU09OIHNjaGVtYSBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBab2Qgc2NoZW1hLlxuICAgICAqIFRoaXMgaXMgdGhlIG1haW4gZW50cnkgcG9pbnQgZm9yIHNjaGVtYSBjb252ZXJzaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZVNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgLy8gSGFuZGxlIGFycmF5IG9mIHR5cGVzIChlLmcuLCBbJ3N0cmluZycsICdudWxsJ10gZm9yIG51bGxhYmxlIHR5cGVzKVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZVR5cGVBcnJheShzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBjb21iaW5hdG9ycyAob25lT2YsIGFueU9mLCBhbGxPZilcbiAgICAgICAgaWYgKHNjaGVtYS5vbmVPZiB8fCBzY2hlbWEuYW55T2YgfHwgc2NoZW1hLmFsbE9mKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNvbWJpbmF0b3Ioc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgaWYtdGhlbi1lbHNlIGNvbmRpdGlvbmFsIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKHNjaGVtYVsnaWYnXSAmJiBzY2hlbWFbJ3RoZW4nXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPYmplY3Qoc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgb2JqZWN0IHNjaGVtYSB3aXRob3V0IGV4cGxpY2l0IHR5cGUgYnV0IHdpdGggcHJvcGVydGllc1xuICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMgJiYgKCFzY2hlbWEudHlwZSB8fCBzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdChzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBhbGwgb3RoZXIgdHlwZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlU2luZ2xlVHlwZShzY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHNjaGVtYXMgd2l0aCBhbiBhcnJheSBvZiB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggdHlwZSBhcnJheS5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIGhhbmRsZVR5cGVBcnJheShzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYS50eXBlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBzY2hlbWEudHlwZSB0byBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSB0eXBlIGFycmF5IGluY2x1ZGVzICdudWxsJyB0byBjcmVhdGUgYSBudWxsYWJsZSB0eXBlXG4gICAgICAgIGlmIChzY2hlbWEudHlwZS5pbmNsdWRlcygnbnVsbCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVOdWxsYWJsZVR5cGUoc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyAnbnVsbCcgaW4gdGhlIHR5cGUgYXJyYXksIGhhbmRsZSBhcyBhIHVuaW9uIG9mIHR5cGVzXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVVuaW9uRnJvbVR5cGVzKHNjaGVtYS50eXBlLCBzY2hlbWEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIG51bGxhYmxlIHR5cGVzIGJ5IGNyZWF0aW5nIGEgbnVsbGFibGUgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBudWxsYWJsZSB0eXBlLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBudWxsYWJsZSBab2Qgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBoYW5kbGVOdWxsYWJsZVR5cGUoc2NoZW1hKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEudHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc2NoZW1hLnR5cGUgdG8gYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBjb3B5IG9mIHRoZSBzY2hlbWEgd2l0aG91dCB0aGUgJ251bGwnIHR5cGVcbiAgICAgICAgY29uc3Qgbm9uTnVsbFNjaGVtYSA9IHsgLi4uc2NoZW1hIH07XG4gICAgICAgIG5vbk51bGxTY2hlbWEudHlwZSA9IHNjaGVtYS50eXBlLmZpbHRlcih0ID0+IHQgIT09ICdudWxsJyk7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgb25seSBvbmUgdHlwZSBsZWZ0LCBoYW5kbGUgaXQgYXMgYSBzaW5nbGUgdHlwZSBhbmQgbWFrZSBpdCBudWxsYWJsZVxuICAgICAgICBpZiAobm9uTnVsbFNjaGVtYS50eXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29uc3Qgc2luZ2xlVHlwZVNjaGVtYSA9IHRoaXMuaGFuZGxlU2luZ2xlVHlwZSh7IC4uLnNjaGVtYSwgdHlwZTogbm9uTnVsbFNjaGVtYS50eXBlWzBdIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHNpbmdsZVR5cGVTY2hlbWEubnVsbGFibGUoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBtdWx0aXBsZSBub24tbnVsbCB0eXBlcywgY3JlYXRlIGEgdW5pb24gYW5kIG1ha2UgaXQgbnVsbGFibGVcbiAgICAgICAgY29uc3QgdW5pb25TY2hlbWEgPSB0aGlzLnBhcnNlU2NoZW1hKG5vbk51bGxTY2hlbWEpO1xuICAgICAgICByZXR1cm4gdW5pb25TY2hlbWEubnVsbGFibGUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHVuaW9uIHR5cGUgZnJvbSBhbiBhcnJheSBvZiB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHR5cGVzIC0gQXJyYXkgb2YgdHlwZSBzdHJpbmdzLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gYmFzZVNjaGVtYSAtIFRoZSBiYXNlIHNjaGVtYSB0byBhcHBseSB0byBlYWNoIHR5cGUuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIHVuaW9uIFpvZCBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVVuaW9uRnJvbVR5cGVzKHR5cGVzLCBiYXNlU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYXMgPSB0eXBlcy5tYXAodHlwZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzaW5nbGVUeXBlU2NoZW1hID0geyAuLi5iYXNlU2NoZW1hLCB0eXBlIH07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNjaGVtYShzaW5nbGVUeXBlU2NoZW1hKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB6LnVuaW9uKHNjaGVtYXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHNjaGVtYXMgd2l0aCBhIHNpbmdsZSB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBzaW5nbGUgdHlwZS5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIGhhbmRsZVNpbmdsZVR5cGUoc2NoZW1hKSB7XG4gICAgICAgIC8vIEhhbmRsZSBzY2hlbWFzIHdpdGhvdXQgYSB0eXBlIHByb3BlcnR5XG4gICAgICAgIGlmIChzY2hlbWEudHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY29tYmluYXRvcnMgZmlyc3RcbiAgICAgICAgICAgIGlmIChzY2hlbWEub25lT2YgfHwgc2NoZW1hLmFueU9mIHx8IHNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQ29tYmluYXRvcihzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIG9iamVjdCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9iamVjdChzY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBhbnkoKSBmb3Igc2NoZW1hcyB3aXRoIG5vIHR5cGUgYW5kIG5vIG90aGVyIGluZGljYXRvcnNcbiAgICAgICAgICAgIHJldHVybiB6LmFueSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBzcGVjaWZpYyB0eXBlc1xuICAgICAgICBzd2l0Y2ggKHNjaGVtYS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdzdHJpbmcnOiByZXR1cm4gdGhpcy5wYXJzZVN0cmluZyhzY2hlbWEpO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIGNhc2UgJ2ludGVnZXInOiByZXR1cm4gdGhpcy5wYXJzZU51bWJlclNjaGVtYShzY2hlbWEpO1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiB6LmJvb2xlYW4oKTtcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5JzogcmV0dXJuIHRoaXMucGFyc2VBcnJheShzY2hlbWEpO1xuICAgICAgICAgICAgY2FzZSAnb2JqZWN0JzogcmV0dXJuIHRoaXMucGFyc2VPYmplY3Qoc2NoZW1hKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgc2NoZW1hIHR5cGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBudW1iZXIgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgZm9yIGEgbnVtYmVyLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VOdW1iZXJTY2hlbWEoc2NoZW1hKSB7XG4gICAgICAgIGxldCBudW1iZXJTY2hlbWEgPSB6Lm51bWJlcigpO1xuICAgICAgICAvLyBBcHBseSBhbGwgbnVtYmVyIHZhbGlkYXRpb25zXG4gICAgICAgIGxldCByZXN1bHQgPSBudW1iZXJTY2hlbWE7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuYXBwbHlOdW1iZXJCb3VuZHMobnVtYmVyU2NoZW1hLCBzY2hlbWEpO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmFwcGx5TnVtYmVyTXVsdGlwbGVPZihudW1iZXJTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuYXBwbHlOdW1iZXJFbnVtKG51bWJlclNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgcmVzdWx0ID0gdGhpcy5hcHBseUludGVnZXJDb25zdHJhaW50KG51bWJlclNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBib3VuZHMgdmFsaWRhdGlvbiB0byBhIG51bWJlciBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3ouWm9kTnVtYmVyfSBudW1iZXJTY2hlbWEgLSBUaGUgYmFzZSBudW1iZXIgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggYm91bmRzLlxuICAgICAqIEByZXR1cm5zIHt6LlpvZE51bWJlcn0gLSBUaGUgdXBkYXRlZCBzY2hlbWEgd2l0aCBib3VuZHMgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlOdW1iZXJCb3VuZHMobnVtYmVyU2NoZW1hLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bWJlclNjaGVtYTtcbiAgICAgICAgaWYgKHNjaGVtYVsnbWluaW11bSddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHNjaGVtYVsnZXhjbHVzaXZlTWluaW11bSddID9cbiAgICAgICAgICAgICAgICByZXN1bHQuZ3Qoc2NoZW1hWydtaW5pbXVtJ10pIDpcbiAgICAgICAgICAgICAgICByZXN1bHQuZ3RlKHNjaGVtYVsnbWluaW11bSddKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hWydtYXhpbXVtJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gc2NoZW1hWydleGNsdXNpdmVNYXhpbXVtJ10gP1xuICAgICAgICAgICAgICAgIHJlc3VsdC5sdChzY2hlbWFbJ21heGltdW0nXSkgOlxuICAgICAgICAgICAgICAgIHJlc3VsdC5sdGUoc2NoZW1hWydtYXhpbXVtJ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgbXVsdGlwbGVPZiB2YWxpZGF0aW9uIHRvIGEgbnVtYmVyIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ei5ab2ROdW1iZXJ9IG51bWJlclNjaGVtYSAtIFRoZSBiYXNlIG51bWJlciBzY2hlbWEuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBtdWx0aXBsZU9mLlxuICAgICAqIEByZXR1cm5zIHt6LlpvZE51bWJlcn0gLSBUaGUgdXBkYXRlZCBzY2hlbWEgd2l0aCBtdWx0aXBsZU9mIHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5TnVtYmVyTXVsdGlwbGVPZihudW1iZXJTY2hlbWEsIHNjaGVtYSkge1xuICAgICAgICBpZiAoc2NoZW1hWydtdWx0aXBsZU9mJ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVtYmVyU2NoZW1hLnJlZmluZSh2YWwgPT4gdmFsICUgc2NoZW1hWydtdWx0aXBsZU9mJ10gPT09IDAsIHsgbWVzc2FnZTogYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtzY2hlbWFbJ211bHRpcGxlT2YnXX1gIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGVudW0gdmFsaWRhdGlvbiB0byBhIG51bWJlciBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3ouWm9kTnVtYmVyfSBudW1iZXJTY2hlbWEgLSBUaGUgYmFzZSBudW1iZXIgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggZW51bS5cbiAgICAgKiBAcmV0dXJucyB7ei5ab2ROdW1iZXJ9IC0gVGhlIHVwZGF0ZWQgc2NoZW1hIHdpdGggZW51bSB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseU51bWJlckVudW0obnVtYmVyU2NoZW1hLCBzY2hlbWEpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEuZW51bSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlclNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWx0ZXIgb3V0IG5vbi1udW1iZXIgdmFsdWVzIGZyb20gZW51bVxuICAgICAgICBjb25zdCBudW1iZXJFbnVtcyA9IHNjaGVtYS5lbnVtLmZpbHRlcih2YWwgPT4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpO1xuICAgICAgICBpZiAobnVtYmVyRW51bXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSByZWZpbmVtZW50IHRvIHZhbGlkYXRlIGFnYWluc3QgZW51bSB2YWx1ZXNcbiAgICAgICAgcmV0dXJuIG51bWJlclNjaGVtYS5yZWZpbmUodmFsID0+IG51bWJlckVudW1zLmluY2x1ZGVzKHZhbCksIHsgbWVzc2FnZTogYE51bWJlciBtdXN0IGJlIG9uZSBvZjogJHtudW1iZXJFbnVtcy5qb2luKCcsICcpfWAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgaW50ZWdlciBjb25zdHJhaW50IHRvIGEgbnVtYmVyIHNjaGVtYSBpZiBuZWVkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3ouWm9kTnVtYmVyfSBudW1iZXJTY2hlbWEgLSBUaGUgYmFzZSBudW1iZXIgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hLlxuICAgICAqIEByZXR1cm5zIHt6LlpvZE51bWJlcn0gLSBUaGUgdXBkYXRlZCBzY2hlbWEgd2l0aCBpbnRlZ2VyIHZhbGlkYXRpb24gaWYgbmVlZGVkLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseUludGVnZXJDb25zdHJhaW50KG51bWJlclNjaGVtYSwgc2NoZW1hKSB7XG4gICAgICAgIGlmIChzY2hlbWEudHlwZSAhPT0gJ2ludGVnZXInKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudW1iZXJTY2hlbWEucmVmaW5lKHZhbCA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCksIHsgbWVzc2FnZTogJ051bWJlciBtdXN0IGJlIGFuIGludGVnZXInIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzdHJpbmcgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgZm9yIGEgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VTdHJpbmcoc2NoZW1hKSB7XG4gICAgICAgIGxldCBzdHJpbmdTY2hlbWEgPSB6LnN0cmluZygpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gc3RyaW5nU2NoZW1hO1xuICAgICAgICAvLyBBcHBseSBhbGwgc3RyaW5nIHZhbGlkYXRpb25zXG4gICAgICAgIGlmIChzY2hlbWEuZm9ybWF0KSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgZm9ybWF0LXNwZWNpZmljIHN0cmluZyB2YWxpZGF0aW9uXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hcHBseVN0cmluZ0Zvcm1hdChzdHJpbmdTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPbmx5IGFwcGx5IG90aGVyIHZhbGlkYXRpb25zIGlmIGZvcm1hdCBpcyBub3Qgc3BlY2lmaWVkXG4gICAgICAgICAgICAvLyBvciBhcHBseSB0aGVtIHRvIHRoZSBmb3JtYXR0ZWQgc3RyaW5nXG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmFwcGx5U3RyaW5nUGF0dGVybihzdHJpbmdTY2hlbWEsIHNjaGVtYSk7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLmFwcGx5U3RyaW5nTGVuZ3RoKHN0cmluZ1NjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuYXBwbHlTdHJpbmdFbnVtKHN0cmluZ1NjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGZvcm1hdCB2YWxpZGF0aW9uIHRvIGEgc3RyaW5nIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ei5ab2RTdHJpbmd9IHN0cmluZ1NjaGVtYSAtIFRoZSBiYXNlIHN0cmluZyBzY2hlbWEuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBmb3JtYXQuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIHVwZGF0ZWQgc2NoZW1hIHdpdGggZm9ybWF0IHZhbGlkYXRpb24uXG4gICAgICovXG4gICAgc3RhdGljIGFwcGx5U3RyaW5nRm9ybWF0KHN0cmluZ1NjaGVtYSwgc2NoZW1hKSB7XG4gICAgICAgIGlmICghc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2VtYWlsJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hLmVtYWlsKCk7XG4gICAgICAgICAgICBjYXNlICdkYXRlLXRpbWUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWEuZGF0ZXRpbWUoKTtcbiAgICAgICAgICAgIGNhc2UgJ3VyaSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYS51cmwoKTtcbiAgICAgICAgICAgIGNhc2UgJ3V1aWQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWEudXVpZCgpO1xuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYS5kYXRlKCk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBwYXR0ZXJuIHZhbGlkYXRpb24gdG8gYSBzdHJpbmcgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt6LlpvZFN0cmluZ30gc3RyaW5nU2NoZW1hIC0gVGhlIGJhc2Ugc3RyaW5nIHNjaGVtYS5cbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIHBhdHRlcm4uXG4gICAgICogQHJldHVybnMge3ouWm9kU3RyaW5nfSAtIFRoZSB1cGRhdGVkIHNjaGVtYSB3aXRoIHBhdHRlcm4gdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlTdHJpbmdQYXR0ZXJuKHN0cmluZ1NjaGVtYSwgc2NoZW1hKSB7XG4gICAgICAgIGlmICghc2NoZW1hWydwYXR0ZXJuJ10pIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHNjaGVtYVsncGF0dGVybiddKTtcbiAgICAgICAgcmV0dXJuIHN0cmluZ1NjaGVtYS5yZWdleChyZWdleCwgeyBtZXNzYWdlOiBgU3RyaW5nIG11c3QgbWF0Y2ggcGF0dGVybjogJHtzY2hlbWFbJ3BhdHRlcm4nXX1gIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBsaWVzIGxlbmd0aCBjb25zdHJhaW50cyB0byBhIHN0cmluZyBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3ouWm9kU3RyaW5nfSBzdHJpbmdTY2hlbWEgLSBUaGUgYmFzZSBzdHJpbmcgc2NoZW1hLlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggbGVuZ3RoIGNvbnN0cmFpbnRzLlxuICAgICAqIEByZXR1cm5zIHt6LlpvZFN0cmluZ30gLSBUaGUgdXBkYXRlZCBzY2hlbWEgd2l0aCBsZW5ndGggdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlTdHJpbmdMZW5ndGgoc3RyaW5nU2NoZW1hLCBzY2hlbWEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHN0cmluZ1NjaGVtYTtcbiAgICAgICAgaWYgKHNjaGVtYVsnbWluTGVuZ3RoJ10gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLm1pbihzY2hlbWFbJ21pbkxlbmd0aCddKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hWydtYXhMZW5ndGgnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEubWF4KHNjaGVtYVsnbWF4TGVuZ3RoJ10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZW51bSB2YWxpZGF0aW9uIHRvIGEgc3RyaW5nIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ei5ab2RTdHJpbmd9IHN0cmluZ1NjaGVtYSAtIFRoZSBiYXNlIHN0cmluZyBzY2hlbWEuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBlbnVtLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSB1cGRhdGVkIHNjaGVtYSB3aXRoIGVudW0gdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlTdHJpbmdFbnVtKHN0cmluZ1NjaGVtYSwgc2NoZW1hKSB7XG4gICAgICAgIGlmICghc2NoZW1hLmVudW0pIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmdTY2hlbWE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIHJlZmluZW1lbnQgdG8gdmFsaWRhdGUgYWdhaW5zdCBlbnVtIHZhbHVlc1xuICAgICAgICByZXR1cm4gc3RyaW5nU2NoZW1hLnJlZmluZSgodmFsKSA9PiBzY2hlbWEuZW51bT8uaW5jbHVkZXModmFsKSwge1xuICAgICAgICAgICAgbWVzc2FnZTogYFZhbHVlIG11c3QgYmUgb25lIG9mOiAke3NjaGVtYS5lbnVtPy5qb2luKCcsICcpfWBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIEpTT04gc2NoZW1hIG9mIHR5cGUgYXJyYXkgYW5kIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgWm9kIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VBcnJheShzY2hlbWEpIHtcbiAgICAgICAgLy8gSGFuZGxlIHR1cGxlIHZhbGlkYXRpb24gKGl0ZW1zIGlzIGFuIGFycmF5KVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEuaXRlbXMpKSB7XG4gICAgICAgICAgICBjb25zdCB0dXBsZVNjaGVtYXMgPSBzY2hlbWEuaXRlbXMubWFwKGl0ZW0gPT4gdGhpcy5wYXJzZVNjaGVtYShpdGVtKSk7XG4gICAgICAgICAgICByZXR1cm4gei51bmlvbih0dXBsZVNjaGVtYXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSByZWd1bGFyIGFycmF5IHNjaGVtYVxuICAgICAgICBjb25zdCBpdGVtU2NoZW1hID0gc2NoZW1hLml0ZW1zID8gdGhpcy5wYXJzZVNjaGVtYShzY2hlbWEuaXRlbXMpIDogei5hbnkoKTtcbiAgICAgICAgbGV0IGFycmF5U2NoZW1hID0gei5hcnJheShpdGVtU2NoZW1hKTtcbiAgICAgICAgLy8gQXBwbHkgYXJyYXkgY29uc3RyYWludHNcbiAgICAgICAgbGV0IHJlc3VsdCA9IGFycmF5U2NoZW1hO1xuICAgICAgICByZXN1bHQgPSB0aGlzLmFwcGx5QXJyYXlDb25zdHJhaW50cyhhcnJheVNjaGVtYSwgc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbGllcyBjb25zdHJhaW50cyB0byBhbiBhcnJheSBzY2hlbWEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3ouWm9kQXJyYXk8YW55Pn0gYXJyYXlTY2hlbWEgLSBUaGUgYmFzZSBhcnJheSBzY2hlbWEuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgd2l0aCBhcnJheSBjb25zdHJhaW50cy5cbiAgICAgKiBAcmV0dXJucyB7ei5ab2RUeXBlQW55fSAtIFRoZSB1cGRhdGVkIGFycmF5IHNjaGVtYSB3aXRoIGNvbnN0cmFpbnRzLlxuICAgICAqL1xuICAgIHN0YXRpYyBhcHBseUFycmF5Q29uc3RyYWludHMoYXJyYXlTY2hlbWEsIHNjaGVtYSkge1xuICAgICAgICAvLyBIYW5kbGUgbWluSXRlbXNcbiAgICAgICAgaWYgKHNjaGVtYVsnbWluSXRlbXMnXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcnJheVNjaGVtYSA9IGFycmF5U2NoZW1hLm1pbihzY2hlbWFbJ21pbkl0ZW1zJ10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEhhbmRsZSBtYXhJdGVtc1xuICAgICAgICBpZiAoc2NoZW1hWydtYXhJdGVtcyddICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFycmF5U2NoZW1hID0gYXJyYXlTY2hlbWEubWF4KHNjaGVtYVsnbWF4SXRlbXMnXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHVuaXF1ZUl0ZW1zXG4gICAgICAgIGlmIChzY2hlbWFbJ3VuaXF1ZUl0ZW1zJ10pIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheVNjaGVtYS5yZWZpbmUoKGl0ZW1zKSA9PiBuZXcgU2V0KGl0ZW1zKS5zaXplID09PSBpdGVtcy5sZW5ndGgsIHsgbWVzc2FnZTogJ0FycmF5IGl0ZW1zIG11c3QgYmUgdW5pcXVlJyB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlTY2hlbWE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBvYmplY3Qgc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgZm9yIGFuIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlT2JqZWN0KHNjaGVtYSkge1xuICAgICAgICAvLyBIYW5kbGUgY29uZGl0aW9uYWwgdmFsaWRhdGlvbiAoaWYtdGhlbi1lbHNlKSBmaXJzdFxuICAgICAgICBpZiAoc2NoZW1hWydpZiddICYmIHNjaGVtYVsndGhlbiddKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUNvbmRpdGlvbmFsKHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIHNoYXBlIG9iamVjdCBmb3IgWm9kXG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIC8vIFByb2Nlc3MgcHJvcGVydGllc1xuICAgICAgICB0aGlzLnByb2Nlc3NPYmplY3RQcm9wZXJ0aWVzKHNjaGVtYSwgc2hhcGUpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIG9iamVjdCBzY2hlbWEgYW5kIGhhbmRsZSBhZGRpdGlvbmFsUHJvcGVydGllc1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9jZXNzQWRkaXRpb25hbFByb3BlcnRpZXMoc2NoZW1hLCB6Lm9iamVjdChzaGFwZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgb2JqZWN0IHByb3BlcnRpZXMgYW5kIGJ1aWxkcyB0aGUgc2hhcGUgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgZm9yIGFuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlY29yZDxzdHJpbmcsIFpvZFR5cGVBbnk+fSBzaGFwZSAtIFRoZSBzaGFwZSBvYmplY3QgdG8gcG9wdWxhdGUuXG4gICAgICovXG4gICAgc3RhdGljIHByb2Nlc3NPYmplY3RQcm9wZXJ0aWVzKHNjaGVtYSwgc2hhcGUpIHtcbiAgICAgICAgY29uc3QgcmVxdWlyZWQgPSBuZXcgU2V0KHNjaGVtYS5yZXF1aXJlZCB8fCBbXSk7XG4gICAgICAgIGlmICghc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHByb3BTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgY29uc3Qgem9kU2NoZW1hID0gdGhpcy5wYXJzZVNjaGVtYShwcm9wU2NoZW1hKTtcbiAgICAgICAgICAgIHNoYXBlW2tleV0gPSByZXF1aXJlZC5oYXMoa2V5KSA/IHpvZFNjaGVtYSA6IHpvZFNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhZGRpdGlvbmFsUHJvcGVydGllcyBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgZm9yIGFuIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3ouWm9kT2JqZWN0PGFueSwgYW55Pn0gb2JqZWN0U2NoZW1hIC0gVGhlIFpvZCBvYmplY3Qgc2NoZW1hLlxuICAgICAqIEByZXR1cm5zIHt6LlpvZE9iamVjdDxhbnksIGFueT59IC0gVGhlIHVwZGF0ZWQgWm9kIG9iamVjdCBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHByb2Nlc3NBZGRpdGlvbmFsUHJvcGVydGllcyhzY2hlbWEsIG9iamVjdFNjaGVtYSkge1xuICAgICAgICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0U2NoZW1hLnBhc3N0aHJvdWdoKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzICYmIHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgc2NoZW1hIGZvciBhZGRpdGlvbmFsIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxQcm9wU2NoZW1hID0gdGhpcy5wYXJzZVNjaGVtYShzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG9iamVjdFNjaGVtYS5jYXRjaGFsbChhZGRpdGlvbmFsUHJvcFNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0U2NoZW1hLnN0cmljdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIGNvbmRpdGlvbmFsIHNjaGVtYSB3aXRoIGlmLXRoZW4tZWxzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIEpTT04gc2NoZW1hIHdpdGggY29uZGl0aW9uYWwgdmFsaWRhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgY29uZGl0aW9uYWwgWm9kIHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VDb25kaXRpb25hbChzY2hlbWEpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGJhc2Ugb2JqZWN0IHNjaGVtYVxuICAgICAgICBjb25zdCB6b2RPYmplY3QgPSB0aGlzLmNyZWF0ZUJhc2VPYmplY3RTY2hlbWEoc2NoZW1hKTtcbiAgICAgICAgLy8gRXh0cmFjdCBjb25kaXRpb25hbCBwYXJ0c1xuICAgICAgICBjb25zdCBpZkNvbmRpdGlvbiA9IHNjaGVtYVsnaWYnXTtcbiAgICAgICAgY29uc3QgdGhlblNjaGVtYSA9IHNjaGVtYVsndGhlbiddO1xuICAgICAgICBjb25zdCBlbHNlU2NoZW1hID0gc2NoZW1hWydlbHNlJ107XG4gICAgICAgIC8vIEFwcGx5IGNvbmRpdGlvbmFsIHZhbGlkYXRpb24gdXNpbmcgc3VwZXJSZWZpbmVcbiAgICAgICAgcmV0dXJuIHpvZE9iamVjdC5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICAgICAgICAvLyBBcHBseSBkZWZhdWx0IHZhbHVlcyB0byBkYXRhIGZvciBjb25kaXRpb24gY2hlY2tpbmdcbiAgICAgICAgICAgIGNvbnN0IGRhdGFXaXRoRGVmYXVsdHMgPSB0aGlzLmFwcGx5RGVmYXVsdFZhbHVlcyhkYXRhLCBzY2hlbWEpO1xuICAgICAgICAgICAgLy8gQXBwbHkgYXBwcm9wcmlhdGUgdmFsaWRhdGlvbiBiYXNlZCBvbiBjb25kaXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLm1hdGNoZXNDb25kaXRpb24oZGF0YVdpdGhEZWZhdWx0cywgaWZDb25kaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNvbmRpdGlvbmFsU2NoZW1hKGRhdGFXaXRoRGVmYXVsdHMsIHRoZW5TY2hlbWEsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbHNlU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNvbmRpdGlvbmFsU2NoZW1hKGRhdGFXaXRoRGVmYXVsdHMsIGVsc2VTY2hlbWEsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBvYmplY3Qgc2NoZW1hIGZyb20gdGhlIGdpdmVuIEpTT04gc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBzY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEuXG4gICAgICogQHJldHVybnMge3ouWm9kT2JqZWN0PGFueSwgYW55Pn0gLSBUaGUgYmFzZSBab2Qgb2JqZWN0IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQmFzZU9iamVjdFNjaGVtYShzY2hlbWEpIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgY29uc3QgcmVxdWlyZWQgPSBuZXcgU2V0KHNjaGVtYS5yZXF1aXJlZCB8fCBbXSk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9KSkge1xuICAgICAgICAgICAgY29uc3Qgem9kU2NoZW1hID0gdGhpcy5wYXJzZVNjaGVtYSh2YWx1ZSk7XG4gICAgICAgICAgICBzaGFwZVtrZXldID0gcmVxdWlyZWQuaGFzKGtleSkgPyB6b2RTY2hlbWEgOiB6b2RTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB6b2RPYmplY3QgPSB6Lm9iamVjdChzaGFwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2Nlc3NBZGRpdGlvbmFsUHJvcGVydGllcyhzY2hlbWEsIHpvZE9iamVjdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgZGVmYXVsdCB2YWx1ZXMgZnJvbSBzY2hlbWEgcHJvcGVydGllcyB0byBkYXRhIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlZhbHVlfSBkYXRhIC0gVGhlIG9yaWdpbmFsIGRhdGEgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYX0gc2NoZW1hIC0gVGhlIHNjaGVtYSB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtKU09OVmFsdWV9IC0gVGhlIGRhdGEgb2JqZWN0IHdpdGggZGVmYXVsdHMgYXBwbGllZC5cbiAgICAgKi9cbiAgICBzdGF0aWMgYXBwbHlEZWZhdWx0VmFsdWVzKGRhdGEsIHNjaGVtYSkge1xuICAgICAgICAvLyBJZiBkYXRhIGlzIG5vdCBhbiBvYmplY3Qgb3IgaXMgbnVsbCwgd2UgY2FuJ3QgYXBwbHkgZGVmYXVsdHNcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnb2JqZWN0JyB8fCBkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBkYXRhIGlzIGFuIGFycmF5LCB3ZSBjYW4ndCBhcHBseSBkZWZhdWx0cyBmcm9tIHNjaGVtYSBwcm9wZXJ0aWVzXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgd2Uga25vdyBkYXRhIGlzIGEgSlNPTk9iamVjdFxuICAgICAgICBjb25zdCBvYmplY3REYXRhID0gZGF0YTtcbiAgICAgICAgY29uc3QgZGF0YVdpdGhEZWZhdWx0cyA9IHsgLi4ub2JqZWN0RGF0YSB9O1xuICAgICAgICBpZiAoIXNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YVdpdGhEZWZhdWx0cztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHByb3BTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5wcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgaWYgKCEoa2V5IGluIGRhdGFXaXRoRGVmYXVsdHMpICYmICdkZWZhdWx0JyBpbiBwcm9wU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgZGF0YVdpdGhEZWZhdWx0c1trZXldID0gcHJvcFNjaGVtYVsnZGVmYXVsdCddO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhV2l0aERlZmF1bHRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzY2hlbWEgd2l0aCBjb21iaW5hdG9ycyAob25lT2YsIGFueU9mLCBhbGxPZikuXG4gICAgICogRGVsZWdhdGVzIHRvIHRoZSBhcHByb3ByaWF0ZSBjb21iaW5hdG9yIHBhcnNlciBiYXNlZCBvbiB3aGljaCBjb21iaW5hdG9yIGlzIHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWF9IHNjaGVtYSAtIFRoZSBKU09OIHNjaGVtYSB3aXRoIGNvbWJpbmF0b3JzLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VDb21iaW5hdG9yKHNjaGVtYSkge1xuICAgICAgICBpZiAoc2NoZW1hLm9uZU9mKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9uZU9mKHNjaGVtYS5vbmVPZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5hbnlPZikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBbnlPZihzY2hlbWEuYW55T2YpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuYWxsT2YpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQWxsT2Yoc2NoZW1hLmFsbE9mKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaG91bGQgbm90IHJlYWNoIGhlcmUgaWYgc2NoZW1hIGhhcyBjb21iaW5hdG9yc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIHNjaGVtYSB0eXBlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhIG9uZU9mIGNvbWJpbmF0b3Igc2NoZW1hLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hW119IHNjaGVtYXMgLSBBcnJheSBvZiBKU09OIHNjaGVtYXMgaW4gdGhlIG9uZU9mLlxuICAgICAqIEByZXR1cm5zIHtab2RUeXBlQW55fSAtIFRoZSBab2RUeXBlQW55IHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgcGFyc2VPbmVPZihzY2hlbWFzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVVuaW9uRnJvbVNjaGVtYXMoc2NoZW1hcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlcyBhbiBhbnlPZiBjb21iaW5hdG9yIHNjaGVtYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SlNPTlNjaGVtYVtdfSBzY2hlbWFzIC0gQXJyYXkgb2YgSlNPTiBzY2hlbWFzIGluIHRoZSBhbnlPZi5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgWm9kVHlwZUFueSBzY2hlbWEuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlQW55T2Yoc2NoZW1hcykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVVbmlvbkZyb21TY2hlbWFzKHNjaGVtYXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdW5pb24gZnJvbSBhbiBhcnJheSBvZiBzY2hlbWFzLCBoYW5kbGluZyBzcGVjaWFsIGNhc2VzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hW119IHNjaGVtYXMgLSBBcnJheSBvZiBKU09OIHNjaGVtYXMgdG8gY3JlYXRlIGEgdW5pb24gZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7Wm9kVHlwZUFueX0gLSBUaGUgdW5pb24gWm9kIHNjaGVtYS5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlVW5pb25Gcm9tU2NoZW1hcyhzY2hlbWFzKSB7XG4gICAgICAgIC8vIEhhbmRsZSBlbXB0eSBhcnJheSBjYXNlXG4gICAgICAgIGlmIChzY2hlbWFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHouYW55KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFuZGxlIHNpbmdsZSBzY2hlbWEgY2FzZVxuICAgICAgICBpZiAoc2NoZW1hcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NoZW1hKHNjaGVtYXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2Nlc3MgZWFjaCBzdWJzY2hlbWEgaW5kaXZpZHVhbGx5XG4gICAgICAgIGNvbnN0IHpvZFNjaGVtYXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdWJTY2hlbWEgb2Ygc2NoZW1hcykge1xuICAgICAgICAgICAgLy8gSGFuZGxlIG51bGwgdHlwZSBzcGVjaWFsbHlcbiAgICAgICAgICAgIGlmIChzdWJTY2hlbWEudHlwZSA9PT0gJ251bGwnKSB7XG4gICAgICAgICAgICAgICAgem9kU2NoZW1hcy5wdXNoKHoubnVsbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHpvZFNjaGVtYXMucHVzaCh0aGlzLnBhcnNlU2NoZW1hKHN1YlNjaGVtYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJldHVybiBhcHByb3ByaWF0ZSBzY2hlbWEgYmFzZWQgb24gbnVtYmVyIG9mIHZhbGlkIHNjaGVtYXNcbiAgICAgICAgaWYgKHpvZFNjaGVtYXMubGVuZ3RoID49IDIpIHtcbiAgICAgICAgICAgIHJldHVybiB6LnVuaW9uKHpvZFNjaGVtYXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHpvZFNjaGVtYXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gem9kU2NoZW1hc1swXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjayBpZiBubyB2YWxpZCBzY2hlbWFzIHdlcmUgY3JlYXRlZFxuICAgICAgICByZXR1cm4gei5hbnkoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGFuIGFsbE9mIGNvbWJpbmF0b3Igc2NoZW1hIGJ5IG1lcmdpbmcgYWxsIHNjaGVtYXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT05TY2hlbWFbXX0gc2NoZW1hcyAtIEFycmF5IG9mIEpTT04gc2NoZW1hcyBpbiB0aGUgYWxsT2YuXG4gICAgICogQHJldHVybnMge1pvZFR5cGVBbnl9IC0gVGhlIFpvZFR5cGVBbnkgc2NoZW1hLlxuICAgICAqL1xuICAgIHN0YXRpYyBwYXJzZUFsbE9mKHNjaGVtYXMpIHtcbiAgICAgICAgLy8gSGFuZGxlIGVtcHR5IGFycmF5IGNhc2VcbiAgICAgICAgaWYgKHNjaGVtYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gei5hbnkoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgc2luZ2xlIHNjaGVtYSBjYXNlXG4gICAgICAgIGlmIChzY2hlbWFzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VTY2hlbWEoc2NoZW1hc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWVyZ2UgYWxsIHNjaGVtYXMgdG9nZXRoZXJcbiAgICAgICAgY29uc3QgbWVyZ2VkU2NoZW1hID0gc2NoZW1hcy5yZWR1Y2UoKGFjYywgY3VycmVudFNjaGVtYSkgPT4gdGhpcy5tZXJnZVNjaGVtYXMoYWNjLCBjdXJyZW50U2NoZW1hKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2NoZW1hKG1lcmdlZFNjaGVtYSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lcmdlcyB0d28gSlNPTiBzY2hlbWFzIHRvZ2V0aGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBiYXNlU2NoZW1hIC0gVGhlIGJhc2UgSlNPTiBzY2hlbWEuXG4gICAgICogQHBhcmFtIHtKU09OU2NoZW1hfSBhZGRTY2hlbWEgLSBUaGUgSlNPTiBzY2hlbWEgdG8gYWRkLlxuICAgICAqIEByZXR1cm5zIHtKU09OU2NoZW1hfSAtIFRoZSBtZXJnZWQgSlNPTiBzY2hlbWFcbiAgICAgKi9cbiAgICBzdGF0aWMgbWVyZ2VTY2hlbWFzKGJhc2VTY2hlbWEsIGFkZFNjaGVtYSkge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSB7IC4uLmJhc2VTY2hlbWEsIC4uLmFkZFNjaGVtYSB9O1xuICAgICAgICBpZiAoYmFzZVNjaGVtYS5wcm9wZXJ0aWVzICYmIGFkZFNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRQcm9wZXJ0aWVzID0geyAuLi5iYXNlU2NoZW1hLnByb3BlcnRpZXMsIC4uLmFkZFNjaGVtYS5wcm9wZXJ0aWVzIH07XG4gICAgICAgICAgICBtZXJnZWQucHJvcGVydGllcyA9IG1lcmdlZFByb3BlcnRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJhc2VTY2hlbWEucmVxdWlyZWQgJiYgYWRkU2NoZW1hLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRSZXF1aXJlZCA9IFsuLi5uZXcgU2V0KFsuLi5iYXNlU2NoZW1hLnJlcXVpcmVkLCAuLi5hZGRTY2hlbWEucmVxdWlyZWRdKV07XG4gICAgICAgICAgICBtZXJnZWQucmVxdWlyZWQgPSBtZXJnZWRSZXF1aXJlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvVHlwZS5qcyIsIm1hcHBpbmdzIjoiO0FBQVUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvVHlwZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQge307XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@dmitryrechkin/json-schema-to-zod/dist/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   JSONSchemaToZod: () => (/* reexport safe */ _JSONSchemaToZod_js__WEBPACK_IMPORTED_MODULE_0__.JSONSchemaToZod)\n/* harmony export */ });\n/* harmony import */ var _JSONSchemaToZod_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./JSONSchemaToZod.js */ \"(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/JSONSchemaToZod.js\");\n/* harmony import */ var _Type_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Type.js */ \"(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/Type.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQXFDO0FBQ1giLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvQGRtaXRyeXJlY2hraW4vanNvbi1zY2hlbWEtdG8tem9kL2Rpc3QvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi9KU09OU2NoZW1hVG9ab2QuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9UeXBlLmpzJztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@dmitryrechkin/json-schema-to-zod/dist/index.js\n");

/***/ })

};
;