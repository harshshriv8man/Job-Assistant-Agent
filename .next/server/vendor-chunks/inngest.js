"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/inngest";
exports.ids = ["vendor-chunks/inngest"];
exports.modules = {

/***/ "(rsc)/./node_modules/inngest/api/api.js":
/*!*****************************************!*\
  !*** ./node_modules/inngest/api/api.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestApi = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst net_js_1 = __webpack_require__(/*! ../helpers/net.js */ \"(rsc)/./node_modules/inngest/helpers/net.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst schema_js_1 = __webpack_require__(/*! ./schema.js */ \"(rsc)/./node_modules/inngest/api/schema.js\");\nconst realtimeSubscriptionTokenSchema = zod_1.z.object({\n    jwt: zod_1.z.string(),\n});\nconst sendSignalSuccessResponseSchema = zod_1.z.object({\n    data: zod_1.z.object({\n        run_id: zod_1.z.string().min(1),\n    }),\n});\nclass InngestApi {\n    constructor({ baseUrl, signingKey, signingKeyFallback, fetch, mode, }) {\n        this.apiBaseUrl = baseUrl;\n        this.signingKey = signingKey;\n        this.signingKeyFallback = signingKeyFallback;\n        this.fetch = fetch;\n        this.mode = mode;\n    }\n    get hashedKey() {\n        return (0, strings_js_1.hashSigningKey)(this.signingKey);\n    }\n    get hashedFallbackKey() {\n        if (!this.signingKeyFallback) {\n            return;\n        }\n        return (0, strings_js_1.hashSigningKey)(this.signingKeyFallback);\n    }\n    // set the signing key in case it was not instantiated previously\n    setSigningKey(key) {\n        if (typeof key === \"string\" && this.signingKey === \"\") {\n            this.signingKey = key;\n        }\n    }\n    setSigningKeyFallback(key) {\n        if (typeof key === \"string\" && !this.signingKeyFallback) {\n            this.signingKeyFallback = key;\n        }\n    }\n    async getTargetUrl(path) {\n        if (this.apiBaseUrl) {\n            return new URL(path, this.apiBaseUrl);\n        }\n        let url = new URL(path, consts_js_1.defaultInngestApiBaseUrl);\n        if (this.mode.isDev && this.mode.isInferred && !this.apiBaseUrl) {\n            const devAvailable = await (0, devserver_js_1.devServerAvailable)(consts_js_1.defaultDevServerHost, this.fetch);\n            if (devAvailable) {\n                url = new URL(path, consts_js_1.defaultDevServerHost);\n            }\n        }\n        return url;\n    }\n    async getRunSteps(runId, version) {\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url: await this.getTargetUrl(`/v0/runs/${runId}/actions`),\n        })\n            .then(async (resp) => {\n            const data = await resp.json();\n            if (resp.ok) {\n                return (0, types_js_1.ok)(schema_js_1.stepsSchemas[version].parse(data));\n            }\n            else {\n                return (0, types_js_1.err)(schema_js_1.errorSchema.parse(data));\n            }\n        })\n            .catch((error) => {\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error retrieving step data\"),\n                status: 500,\n            });\n        });\n    }\n    async getRunBatch(runId) {\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url: await this.getTargetUrl(`/v0/runs/${runId}/batch`),\n        })\n            .then(async (resp) => {\n            const data = await resp.json();\n            if (resp.ok) {\n                return (0, types_js_1.ok)(schema_js_1.batchSchema.parse(data));\n            }\n            else {\n                return (0, types_js_1.err)(schema_js_1.errorSchema.parse(data));\n            }\n        })\n            .catch((error) => {\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error retrieving event batch\"),\n                status: 500,\n            });\n        });\n    }\n    async publish(publishOptions, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data) {\n        // todo it may not be a \"text/stream\"\n        const isStream = data instanceof ReadableStream;\n        const url = await this.getTargetUrl(\"/v1/realtime/publish\");\n        url.searchParams.set(\"channel\", publishOptions.channel || \"\");\n        if (publishOptions.runId) {\n            url.searchParams.set(\"run_id\", publishOptions.runId);\n        }\n        publishOptions.topics.forEach((topic) => {\n            url.searchParams.append(\"topic\", topic);\n        });\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: Object.assign({ method: \"POST\", body: isStream\n                    ? data\n                    : typeof data === \"string\"\n                        ? data\n                        : JSON.stringify(data), headers: {\n                    \"Content-Type\": isStream ? \"text/stream\" : \"application/json\",\n                } }, (isStream ? { duplex: \"half\" } : {})),\n        })\n            .then((res) => {\n            if (!res.ok) {\n                throw new Error(`Failed to publish event: ${res.status} ${res.statusText}`);\n            }\n            return (0, types_js_1.ok)(undefined);\n        })\n            .catch((error) => {\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error publishing event\"),\n                status: 500,\n            });\n        });\n    }\n    async sendSignal(signalOptions, options) {\n        const url = await this.getTargetUrl(\"/v1/signals\");\n        const body = {\n            signal: signalOptions.signal,\n            data: signalOptions.data,\n        };\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: Object.assign({ \"Content-Type\": \"application/json\" }, options === null || options === void 0 ? void 0 : options.headers),\n            },\n        })\n            .then(async (res) => {\n            // A 404 is valid if the signal was not found.\n            if (res.status === 404) {\n                return (0, types_js_1.ok)({\n                    runId: undefined,\n                });\n            }\n            // Save a clone of the response we can use to get the text of if we fail\n            // to parse the JSON.\n            const resClone = res.clone();\n            // JSON!\n            let json;\n            try {\n                json = await res.json();\n            }\n            catch (error) {\n                // res.json() failed so not a valid JSON response\n                return (0, types_js_1.err)({\n                    error: `Failed to send signal: ${res.status} ${res.statusText} - ${await resClone.text()}`,\n                    status: res.status,\n                });\n            }\n            // If we're not 2xx, something went wrong.\n            if (!res.ok) {\n                try {\n                    return (0, types_js_1.err)(schema_js_1.errorSchema.parse(json));\n                }\n                catch (_a) {\n                    // schema parse failed\n                    return (0, types_js_1.err)({\n                        error: `Failed to send signal: ${res.status} ${res.statusText} - ${await res.text()}`,\n                        status: res.status,\n                    });\n                }\n            }\n            // If we are 2xx, we should have a run_id.\n            const parseRes = sendSignalSuccessResponseSchema.safeParse(json);\n            if (!parseRes.success) {\n                return (0, types_js_1.err)({\n                    error: `Successfully sent signal, but response parsing failed: ${res.status} ${res.statusText} - ${await resClone.text()}`,\n                    status: res.status,\n                });\n            }\n            return (0, types_js_1.ok)({\n                runId: parseRes.data.data.run_id,\n            });\n        })\n            .catch((error) => {\n            // Catch-all if various things go wrong\n            return (0, types_js_1.err)({\n                error: (0, errors_js_1.getErrorMessage)(error, \"Unknown error sending signal\"),\n                status: 500,\n            });\n        });\n    }\n    async getSubscriptionToken(channel, topics) {\n        const url = await this.getTargetUrl(\"/v1/realtime/token\");\n        const body = topics.map((topic) => ({\n            channel,\n            name: topic,\n            kind: \"run\",\n        }));\n        return (0, net_js_1.fetchWithAuthFallback)({\n            authToken: this.hashedKey,\n            authTokenFallback: this.hashedFallbackKey,\n            fetch: this.fetch,\n            url,\n            options: {\n                method: \"POST\",\n                body: JSON.stringify(body),\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n            },\n        })\n            .then(async (res) => {\n            if (!res.ok) {\n                throw new Error(`Failed to get subscription token: ${res.status} ${res.statusText} - ${await res.text()}`);\n            }\n            const data = realtimeSubscriptionTokenSchema.parse(await res.json());\n            return data.jwt;\n        })\n            .catch((error) => {\n            throw new Error((0, errors_js_1.getErrorMessage)(error, \"Unknown error getting subscription token\"));\n        });\n    }\n}\nexports.InngestApi = InngestApi;\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvYXBpLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtCQUFrQjtBQUNsQixjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLGtGQUF5QjtBQUN4RCxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsaUJBQWlCLG1CQUFPLENBQUMsc0VBQW1CO0FBQzVDLHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQywwREFBYTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQywrREFBYTtBQUN6QztBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQSxrQkFBa0IsdURBQXVEO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsTUFBTTtBQUMzRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0QsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0IsaUJBQWlCLElBQUk7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQSw0REFBNEQsWUFBWSxFQUFFLGVBQWU7QUFDekY7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9DQUFvQztBQUM3RSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFlBQVksRUFBRSxnQkFBZ0IsSUFBSSxzQkFBc0I7QUFDN0c7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFlBQVksRUFBRSxnQkFBZ0IsSUFBSSxpQkFBaUI7QUFDNUc7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUZBQXFGLFlBQVksRUFBRSxnQkFBZ0IsSUFBSSxzQkFBc0I7QUFDN0k7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxxRUFBcUUsWUFBWSxFQUFFLGdCQUFnQixJQUFJLGlCQUFpQjtBQUN4SDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCIiwic291cmNlcyI6WyIvVXNlcnMvaGFyc2hzaHJpdmFzdGF2L0Rlc2t0b3AvQ29kaW5nIFByb2plY3RzL0pvYi1Bc3Npc3RhbnQtQWdlbnQvbm9kZV9tb2R1bGVzL2lubmdlc3QvYXBpL2FwaS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5uZ2VzdEFwaSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuY29uc3QgZGV2c2VydmVyX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9kZXZzZXJ2ZXIuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Vycm9ycy5qc1wiKTtcbmNvbnN0IG5ldF9qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvbmV0LmpzXCIpO1xuY29uc3Qgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RyaW5ncy5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuanNcIik7XG5jb25zdCBzY2hlbWFfanNfMSA9IHJlcXVpcmUoXCIuL3NjaGVtYS5qc1wiKTtcbmNvbnN0IHJlYWx0aW1lU3Vic2NyaXB0aW9uVG9rZW5TY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgand0OiB6b2RfMS56LnN0cmluZygpLFxufSk7XG5jb25zdCBzZW5kU2lnbmFsU3VjY2Vzc1Jlc3BvbnNlU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIGRhdGE6IHpvZF8xLnoub2JqZWN0KHtcbiAgICAgICAgcnVuX2lkOiB6b2RfMS56LnN0cmluZygpLm1pbigxKSxcbiAgICB9KSxcbn0pO1xuY2xhc3MgSW5uZ2VzdEFwaSB7XG4gICAgY29uc3RydWN0b3IoeyBiYXNlVXJsLCBzaWduaW5nS2V5LCBzaWduaW5nS2V5RmFsbGJhY2ssIGZldGNoLCBtb2RlLCB9KSB7XG4gICAgICAgIHRoaXMuYXBpQmFzZVVybCA9IGJhc2VVcmw7XG4gICAgICAgIHRoaXMuc2lnbmluZ0tleSA9IHNpZ25pbmdLZXk7XG4gICAgICAgIHRoaXMuc2lnbmluZ0tleUZhbGxiYWNrID0gc2lnbmluZ0tleUZhbGxiYWNrO1xuICAgICAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgfVxuICAgIGdldCBoYXNoZWRLZXkoKSB7XG4gICAgICAgIHJldHVybiAoMCwgc3RyaW5nc19qc18xLmhhc2hTaWduaW5nS2V5KSh0aGlzLnNpZ25pbmdLZXkpO1xuICAgIH1cbiAgICBnZXQgaGFzaGVkRmFsbGJhY2tLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduaW5nS2V5RmFsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHN0cmluZ3NfanNfMS5oYXNoU2lnbmluZ0tleSkodGhpcy5zaWduaW5nS2V5RmFsbGJhY2spO1xuICAgIH1cbiAgICAvLyBzZXQgdGhlIHNpZ25pbmcga2V5IGluIGNhc2UgaXQgd2FzIG5vdCBpbnN0YW50aWF0ZWQgcHJldmlvdXNseVxuICAgIHNldFNpZ25pbmdLZXkoa2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIHRoaXMuc2lnbmluZ0tleSA9PT0gXCJcIikge1xuICAgICAgICAgICAgdGhpcy5zaWduaW5nS2V5ID0ga2V5O1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFNpZ25pbmdLZXlGYWxsYmFjayhrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYgIXRoaXMuc2lnbmluZ0tleUZhbGxiYWNrKSB7XG4gICAgICAgICAgICB0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayA9IGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUYXJnZXRVcmwocGF0aCkge1xuICAgICAgICBpZiAodGhpcy5hcGlCYXNlVXJsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVSTChwYXRoLCB0aGlzLmFwaUJhc2VVcmwpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB1cmwgPSBuZXcgVVJMKHBhdGgsIGNvbnN0c19qc18xLmRlZmF1bHRJbm5nZXN0QXBpQmFzZVVybCk7XG4gICAgICAgIGlmICh0aGlzLm1vZGUuaXNEZXYgJiYgdGhpcy5tb2RlLmlzSW5mZXJyZWQgJiYgIXRoaXMuYXBpQmFzZVVybCkge1xuICAgICAgICAgICAgY29uc3QgZGV2QXZhaWxhYmxlID0gYXdhaXQgKDAsIGRldnNlcnZlcl9qc18xLmRldlNlcnZlckF2YWlsYWJsZSkoY29uc3RzX2pzXzEuZGVmYXVsdERldlNlcnZlckhvc3QsIHRoaXMuZmV0Y2gpO1xuICAgICAgICAgICAgaWYgKGRldkF2YWlsYWJsZSkge1xuICAgICAgICAgICAgICAgIHVybCA9IG5ldyBVUkwocGF0aCwgY29uc3RzX2pzXzEuZGVmYXVsdERldlNlcnZlckhvc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmw7XG4gICAgfVxuICAgIGFzeW5jIGdldFJ1blN0ZXBzKHJ1bklkLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiAoMCwgbmV0X2pzXzEuZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKSh7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuaGFzaGVkS2V5LFxuICAgICAgICAgICAgYXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkRmFsbGJhY2tLZXksXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIHVybDogYXdhaXQgdGhpcy5nZXRUYXJnZXRVcmwoYC92MC9ydW5zLyR7cnVuSWR9L2FjdGlvbnNgKSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcC5qc29uKCk7XG4gICAgICAgICAgICBpZiAocmVzcC5vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vaykoc2NoZW1hX2pzXzEuc3RlcHNTY2hlbWFzW3ZlcnNpb25dLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHNjaGVtYV9qc18xLmVycm9yU2NoZW1hLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yc19qc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IsIFwiVW5rbm93biBlcnJvciByZXRyaWV2aW5nIHN0ZXAgZGF0YVwiKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UnVuQmF0Y2gocnVuSWQpIHtcbiAgICAgICAgcmV0dXJuICgwLCBuZXRfanNfMS5mZXRjaFdpdGhBdXRoRmFsbGJhY2spKHtcbiAgICAgICAgICAgIGF1dGhUb2tlbjogdGhpcy5oYXNoZWRLZXksXG4gICAgICAgICAgICBhdXRoVG9rZW5GYWxsYmFjazogdGhpcy5oYXNoZWRGYWxsYmFja0tleSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgdXJsOiBhd2FpdCB0aGlzLmdldFRhcmdldFVybChgL3YwL3J1bnMvJHtydW5JZH0vYmF0Y2hgKSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKGFzeW5jIChyZXNwKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcC5qc29uKCk7XG4gICAgICAgICAgICBpZiAocmVzcC5vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vaykoc2NoZW1hX2pzXzEuYmF0Y2hTY2hlbWEucGFyc2UoZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikoc2NoZW1hX2pzXzEuZXJyb3JTY2hlbWEucGFyc2UoZGF0YSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikoe1xuICAgICAgICAgICAgICAgIGVycm9yOiAoMCwgZXJyb3JzX2pzXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnJvciwgXCJVbmtub3duIGVycm9yIHJldHJpZXZpbmcgZXZlbnQgYmF0Y2hcIiksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHB1Ymxpc2gocHVibGlzaE9wdGlvbnMsIFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgZGF0YSkge1xuICAgICAgICAvLyB0b2RvIGl0IG1heSBub3QgYmUgYSBcInRleHQvc3RyZWFtXCJcbiAgICAgICAgY29uc3QgaXNTdHJlYW0gPSBkYXRhIGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW07XG4gICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0VGFyZ2V0VXJsKFwiL3YxL3JlYWx0aW1lL3B1Ymxpc2hcIik7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwiY2hhbm5lbFwiLCBwdWJsaXNoT3B0aW9ucy5jaGFubmVsIHx8IFwiXCIpO1xuICAgICAgICBpZiAocHVibGlzaE9wdGlvbnMucnVuSWQpIHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KFwicnVuX2lkXCIsIHB1Ymxpc2hPcHRpb25zLnJ1bklkKTtcbiAgICAgICAgfVxuICAgICAgICBwdWJsaXNoT3B0aW9ucy50b3BpY3MuZm9yRWFjaCgodG9waWMpID0+IHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKFwidG9waWNcIiwgdG9waWMpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgwLCBuZXRfanNfMS5mZXRjaFdpdGhBdXRoRmFsbGJhY2spKHtcbiAgICAgICAgICAgIGF1dGhUb2tlbjogdGhpcy5oYXNoZWRLZXksXG4gICAgICAgICAgICBhdXRoVG9rZW5GYWxsYmFjazogdGhpcy5oYXNoZWRGYWxsYmFja0tleSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7IG1ldGhvZDogXCJQT1NUXCIsIGJvZHk6IGlzU3RyZWFtXG4gICAgICAgICAgICAgICAgICAgID8gZGF0YVxuICAgICAgICAgICAgICAgICAgICA6IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogSlNPTi5zdHJpbmdpZnkoZGF0YSksIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogaXNTdHJlYW0gPyBcInRleHQvc3RyZWFtXCIgOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9IH0sIChpc1N0cmVhbSA/IHsgZHVwbGV4OiBcImhhbGZcIiB9IDoge30pKSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcHVibGlzaCBldmVudDogJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLm9rKSh1bmRlZmluZWQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikoe1xuICAgICAgICAgICAgICAgIGVycm9yOiAoMCwgZXJyb3JzX2pzXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnJvciwgXCJVbmtub3duIGVycm9yIHB1Ymxpc2hpbmcgZXZlbnRcIiksXG4gICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmRTaWduYWwoc2lnbmFsT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB1cmwgPSBhd2FpdCB0aGlzLmdldFRhcmdldFVybChcIi92MS9zaWduYWxzXCIpO1xuICAgICAgICBjb25zdCBib2R5ID0ge1xuICAgICAgICAgICAgc2lnbmFsOiBzaWduYWxPcHRpb25zLnNpZ25hbCxcbiAgICAgICAgICAgIGRhdGE6IHNpZ25hbE9wdGlvbnMuZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICgwLCBuZXRfanNfMS5mZXRjaFdpdGhBdXRoRmFsbGJhY2spKHtcbiAgICAgICAgICAgIGF1dGhUb2tlbjogdGhpcy5oYXNoZWRLZXksXG4gICAgICAgICAgICBhdXRoVG9rZW5GYWxsYmFjazogdGhpcy5oYXNoZWRGYWxsYmFja0tleSxcbiAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgICAvLyBBIDQwNCBpcyB2YWxpZCBpZiB0aGUgc2lnbmFsIHdhcyBub3QgZm91bmQuXG4gICAgICAgICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLm9rKSh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bklkOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTYXZlIGEgY2xvbmUgb2YgdGhlIHJlc3BvbnNlIHdlIGNhbiB1c2UgdG8gZ2V0IHRoZSB0ZXh0IG9mIGlmIHdlIGZhaWxcbiAgICAgICAgICAgIC8vIHRvIHBhcnNlIHRoZSBKU09OLlxuICAgICAgICAgICAgY29uc3QgcmVzQ2xvbmUgPSByZXMuY2xvbmUoKTtcbiAgICAgICAgICAgIC8vIEpTT04hXG4gICAgICAgICAgICBsZXQganNvbjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAganNvbiA9IGF3YWl0IHJlcy5qc29uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyByZXMuanNvbigpIGZhaWxlZCBzbyBub3QgYSB2YWxpZCBKU09OIHJlc3BvbnNlXG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikoe1xuICAgICAgICAgICAgICAgICAgICBlcnJvcjogYEZhaWxlZCB0byBzZW5kIHNpZ25hbDogJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fSAtICR7YXdhaXQgcmVzQ2xvbmUudGV4dCgpfWAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzLnN0YXR1cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCAyeHgsIHNvbWV0aGluZyB3ZW50IHdyb25nLlxuICAgICAgICAgICAgaWYgKCFyZXMub2spIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKShzY2hlbWFfanNfMS5lcnJvclNjaGVtYS5wYXJzZShqc29uKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzY2hlbWEgcGFyc2UgZmFpbGVkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgRmFpbGVkIHRvIHNlbmQgc2lnbmFsOiAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9IC0gJHthd2FpdCByZXMudGV4dCgpfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSAyeHgsIHdlIHNob3VsZCBoYXZlIGEgcnVuX2lkLlxuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXMgPSBzZW5kU2lnbmFsU3VjY2Vzc1Jlc3BvbnNlU2NoZW1hLnNhZmVQYXJzZShqc29uKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VSZXMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGBTdWNjZXNzZnVsbHkgc2VudCBzaWduYWwsIGJ1dCByZXNwb25zZSBwYXJzaW5nIGZhaWxlZDogJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fSAtICR7YXdhaXQgcmVzQ2xvbmUudGV4dCgpfWAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzLnN0YXR1cyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5vaykoe1xuICAgICAgICAgICAgICAgIHJ1bklkOiBwYXJzZVJlcy5kYXRhLmRhdGEucnVuX2lkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBDYXRjaC1hbGwgaWYgdmFyaW91cyB0aGluZ3MgZ28gd3JvbmdcbiAgICAgICAgICAgIHJldHVybiAoMCwgdHlwZXNfanNfMS5lcnIpKHtcbiAgICAgICAgICAgICAgICBlcnJvcjogKDAsIGVycm9yc19qc18xLmdldEVycm9yTWVzc2FnZSkoZXJyb3IsIFwiVW5rbm93biBlcnJvciBzZW5kaW5nIHNpZ25hbFwiKSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U3Vic2NyaXB0aW9uVG9rZW4oY2hhbm5lbCwgdG9waWNzKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IHRoaXMuZ2V0VGFyZ2V0VXJsKFwiL3YxL3JlYWx0aW1lL3Rva2VuXCIpO1xuICAgICAgICBjb25zdCBib2R5ID0gdG9waWNzLm1hcCgodG9waWMpID0+ICh7XG4gICAgICAgICAgICBjaGFubmVsLFxuICAgICAgICAgICAgbmFtZTogdG9waWMsXG4gICAgICAgICAgICBraW5kOiBcInJ1blwiLFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiAoMCwgbmV0X2pzXzEuZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKSh7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuaGFzaGVkS2V5LFxuICAgICAgICAgICAgYXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkRmFsbGJhY2tLZXksXG4gICAgICAgICAgICBmZXRjaDogdGhpcy5mZXRjaCxcbiAgICAgICAgICAgIHVybCxcbiAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbihhc3luYyAocmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGdldCBzdWJzY3JpcHRpb24gdG9rZW46ICR7cmVzLnN0YXR1c30gJHtyZXMuc3RhdHVzVGV4dH0gLSAke2F3YWl0IHJlcy50ZXh0KCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gcmVhbHRpbWVTdWJzY3JpcHRpb25Ub2tlblNjaGVtYS5wYXJzZShhd2FpdCByZXMuanNvbigpKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLmp3dDtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoMCwgZXJyb3JzX2pzXzEuZ2V0RXJyb3JNZXNzYWdlKShlcnJvciwgXCJVbmtub3duIGVycm9yIGdldHRpbmcgc3Vic2NyaXB0aW9uIHRva2VuXCIpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5Jbm5nZXN0QXBpID0gSW5uZ2VzdEFwaTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/api/api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/api/schema.js":
/*!********************************************!*\
  !*** ./node_modules/inngest/api/schema.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.batchSchema = exports.stepsSchemas = exports.errorSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ../components/execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nexports.errorSchema = zod_1.z.object({\n    error: zod_1.z.string(),\n    status: zod_1.z.number(),\n});\nconst v0StepSchema = zod_1.z\n    .record(zod_1.z.any().refine((v) => typeof v !== \"undefined\", {\n    message: \"Values in steps must be defined\",\n}))\n    .optional()\n    .nullable();\nconst v1StepSchema = zod_1.z\n    .record(zod_1.z\n    .object({\n    type: zod_1.z.literal(\"data\").optional().default(\"data\"),\n    data: zod_1.z.any().refine((v) => typeof v !== \"undefined\", {\n        message: \"Data in steps must be defined\",\n    }),\n})\n    .strict()\n    .or(zod_1.z\n    .object({\n    type: zod_1.z.literal(\"error\").optional().default(\"error\"),\n    error: types_js_1.jsonErrorSchema,\n})\n    .strict())\n    .or(zod_1.z\n    .object({\n    type: zod_1.z.literal(\"input\").optional().default(\"input\"),\n    input: zod_1.z.any().refine((v) => typeof v !== \"undefined\", {\n        message: \"If input is present it must not be `undefined`\",\n    }),\n})\n    .strict())\n    /**\n     * If the result isn't a distcint `data` or `error` object, then it's\n     * likely that the executor has set this directly to a value, for example\n     * in the case of `sleep` or `waitForEvent`.\n     *\n     * In this case, pull the entire value through as data.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n    .or(zod_1.z.any().transform((v) => ({ type: \"data\", data: v }))))\n    .default({});\nconst v2StepSchema = v1StepSchema;\nexports.stepsSchemas = {\n    [InngestExecution_js_1.ExecutionVersion.V0]: v0StepSchema,\n    [InngestExecution_js_1.ExecutionVersion.V1]: v1StepSchema,\n    [InngestExecution_js_1.ExecutionVersion.V2]: v2StepSchema,\n};\nexports.batchSchema = zod_1.z.array(zod_1.z.record(zod_1.z.any()).transform((v) => v));\n//# sourceMappingURL=schema.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvc2NoZW1hLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLG9CQUFvQixHQUFHLG1CQUFtQjtBQUNoRSxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IsOEJBQThCLG1CQUFPLENBQUMsMEhBQTZDO0FBQ25GLG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHVCQUF1QjtBQUNqRSxlQUFlO0FBQ2Y7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9hcGkvc2NoZW1hLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5iYXRjaFNjaGVtYSA9IGV4cG9ydHMuc3RlcHNTY2hlbWFzID0gZXhwb3J0cy5lcnJvclNjaGVtYSA9IHZvaWQgMDtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IElubmdlc3RFeGVjdXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbmV4cG9ydHMuZXJyb3JTY2hlbWEgPSB6b2RfMS56Lm9iamVjdCh7XG4gICAgZXJyb3I6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgc3RhdHVzOiB6b2RfMS56Lm51bWJlcigpLFxufSk7XG5jb25zdCB2MFN0ZXBTY2hlbWEgPSB6b2RfMS56XG4gICAgLnJlY29yZCh6b2RfMS56LmFueSgpLnJlZmluZSgodikgPT4gdHlwZW9mIHYgIT09IFwidW5kZWZpbmVkXCIsIHtcbiAgICBtZXNzYWdlOiBcIlZhbHVlcyBpbiBzdGVwcyBtdXN0IGJlIGRlZmluZWRcIixcbn0pKVxuICAgIC5vcHRpb25hbCgpXG4gICAgLm51bGxhYmxlKCk7XG5jb25zdCB2MVN0ZXBTY2hlbWEgPSB6b2RfMS56XG4gICAgLnJlY29yZCh6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHlwZTogem9kXzEuei5saXRlcmFsKFwiZGF0YVwiKS5vcHRpb25hbCgpLmRlZmF1bHQoXCJkYXRhXCIpLFxuICAgIGRhdGE6IHpvZF8xLnouYW55KCkucmVmaW5lKCh2KSA9PiB0eXBlb2YgdiAhPT0gXCJ1bmRlZmluZWRcIiwge1xuICAgICAgICBtZXNzYWdlOiBcIkRhdGEgaW4gc3RlcHMgbXVzdCBiZSBkZWZpbmVkXCIsXG4gICAgfSksXG59KVxuICAgIC5zdHJpY3QoKVxuICAgIC5vcih6b2RfMS56XG4gICAgLm9iamVjdCh7XG4gICAgdHlwZTogem9kXzEuei5saXRlcmFsKFwiZXJyb3JcIikub3B0aW9uYWwoKS5kZWZhdWx0KFwiZXJyb3JcIiksXG4gICAgZXJyb3I6IHR5cGVzX2pzXzEuanNvbkVycm9yU2NoZW1hLFxufSlcbiAgICAuc3RyaWN0KCkpXG4gICAgLm9yKHpvZF8xLnpcbiAgICAub2JqZWN0KHtcbiAgICB0eXBlOiB6b2RfMS56LmxpdGVyYWwoXCJpbnB1dFwiKS5vcHRpb25hbCgpLmRlZmF1bHQoXCJpbnB1dFwiKSxcbiAgICBpbnB1dDogem9kXzEuei5hbnkoKS5yZWZpbmUoKHYpID0+IHR5cGVvZiB2ICE9PSBcInVuZGVmaW5lZFwiLCB7XG4gICAgICAgIG1lc3NhZ2U6IFwiSWYgaW5wdXQgaXMgcHJlc2VudCBpdCBtdXN0IG5vdCBiZSBgdW5kZWZpbmVkYFwiLFxuICAgIH0pLFxufSlcbiAgICAuc3RyaWN0KCkpXG4gICAgLyoqXG4gICAgICogSWYgdGhlIHJlc3VsdCBpc24ndCBhIGRpc3RjaW50IGBkYXRhYCBvciBgZXJyb3JgIG9iamVjdCwgdGhlbiBpdCdzXG4gICAgICogbGlrZWx5IHRoYXQgdGhlIGV4ZWN1dG9yIGhhcyBzZXQgdGhpcyBkaXJlY3RseSB0byBhIHZhbHVlLCBmb3IgZXhhbXBsZVxuICAgICAqIGluIHRoZSBjYXNlIG9mIGBzbGVlcGAgb3IgYHdhaXRGb3JFdmVudGAuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGNhc2UsIHB1bGwgdGhlIGVudGlyZSB2YWx1ZSB0aHJvdWdoIGFzIGRhdGEuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgIC5vcih6b2RfMS56LmFueSgpLnRyYW5zZm9ybSgodikgPT4gKHsgdHlwZTogXCJkYXRhXCIsIGRhdGE6IHYgfSkpKSlcbiAgICAuZGVmYXVsdCh7fSk7XG5jb25zdCB2MlN0ZXBTY2hlbWEgPSB2MVN0ZXBTY2hlbWE7XG5leHBvcnRzLnN0ZXBzU2NoZW1hcyA9IHtcbiAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjBdOiB2MFN0ZXBTY2hlbWEsXG4gICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYxXTogdjFTdGVwU2NoZW1hLFxuICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMl06IHYyU3RlcFNjaGVtYSxcbn07XG5leHBvcnRzLmJhdGNoU2NoZW1hID0gem9kXzEuei5hcnJheSh6b2RfMS56LnJlY29yZCh6b2RfMS56LmFueSgpKS50cmFuc2Zvcm0oKHYpID0+IHYpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjaGVtYS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/api/schema.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/EventSchemas.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/EventSchemas.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventSchemas = void 0;\n/**\n * Provide an `EventSchemas` class to type events, providing type safety when\n * sending events and running functions via Inngest.\n *\n * You can provide generated Inngest types, custom types, types using Zod, or\n * a combination of the above. See {@link EventSchemas} for more information.\n *\n * @example\n *\n * ```ts\n * export const inngest = new Inngest({\n *   id: \"my-app\",\n *   schemas: new EventSchemas().fromZod({\n *     \"app/user.created\": {\n *       data: z.object({\n *         id: z.string(),\n *         name: z.string(),\n *       }),\n *     },\n *   }),\n * });\n * ```\n *\n * @public\n */\nclass EventSchemas {\n    constructor() {\n        this.runtimeSchemas = {};\n    }\n    addRuntimeSchemas(schemas) {\n        this.runtimeSchemas = Object.assign(Object.assign({}, this.runtimeSchemas), schemas);\n    }\n    /**\n     * Use generated Inngest types to type events.\n     */\n    fromGenerated() {\n        return this;\n    }\n    /**\n     * Use a `Record<>` type to type events.\n     *\n     * @example\n     *\n     * ```ts\n     * export const inngest = new Inngest({\n     *   id: \"my-app\",\n     *   schemas: new EventSchemas().fromRecord<{\n     *     \"app/user.created\": {\n     *       data: {\n     *         id: string;\n     *         name: string;\n     *       };\n     *     };\n     *   }>(),\n     * });\n     * ```\n     */\n    fromRecord(..._args) {\n        return this;\n    }\n    /**\n     * Use a union type to type events.\n     *\n     * @example\n     *\n     * ```ts\n     * type AccountCreated = {\n     *   name: \"app/account.created\";\n     *   data: { org: string };\n     *   user: { id: string };\n     * };\n     *\n     * type AccountDeleted = {\n     *   name: \"app/account.deleted\";\n     *   data: { org: string };\n     *   user: { id: string };\n     * };\n     *\n     * type Events = AccountCreated | AccountDeleted;\n     *\n     * export const inngest = new Inngest({\n     *   id: \"my-app\",\n     *   schemas: new EventSchemas().fromUnion<Events>(),\n     * });\n     * ```\n     */\n    fromUnion() {\n        return this;\n    }\n    /**\n     * Use Zod to type events.\n     *\n     * @example\n     *\n     * ```ts\n     * export const inngest = new Inngest({\n     *   id: \"my-app\",\n     *   schemas: new EventSchemas().fromZod({\n     *     \"app/user.created\": {\n     *       data: z.object({\n     *         id: z.string(),\n     *         name: z.string(),\n     *       }),\n     *     },\n     *   }),\n     * });\n     * ```\n     */\n    fromZod(schemas) {\n        let runtimeSchemas;\n        if (Array.isArray(schemas)) {\n            runtimeSchemas = schemas.reduce((acc, schema) => {\n                const _a = schema.shape, { name: { value: name } } = _a, rest = __rest(_a, [\"name\"]);\n                return Object.assign(Object.assign({}, acc), { [name]: rest });\n            }, {});\n        }\n        else {\n            runtimeSchemas = schemas;\n        }\n        this.addRuntimeSchemas(runtimeSchemas);\n        return this;\n    }\n}\nexports.EventSchemas = EventSchemas;\n//# sourceMappingURL=EventSchemas.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0V2ZW50U2NoZW1hcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUixNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsWUFBWTtBQUNaLFVBQVU7QUFDVixRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsZ0JBQWdCO0FBQ25FLHFEQUFxRCxVQUFVLGNBQWM7QUFDN0UsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0V2ZW50U2NoZW1hcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3Jlc3QgPSAodGhpcyAmJiB0aGlzLl9fcmVzdCkgfHwgZnVuY3Rpb24gKHMsIGUpIHtcbiAgICB2YXIgdCA9IHt9O1xuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgICB0W3BdID0gc1twXTtcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgICAgfVxuICAgIHJldHVybiB0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRXZlbnRTY2hlbWFzID0gdm9pZCAwO1xuLyoqXG4gKiBQcm92aWRlIGFuIGBFdmVudFNjaGVtYXNgIGNsYXNzIHRvIHR5cGUgZXZlbnRzLCBwcm92aWRpbmcgdHlwZSBzYWZldHkgd2hlblxuICogc2VuZGluZyBldmVudHMgYW5kIHJ1bm5pbmcgZnVuY3Rpb25zIHZpYSBJbm5nZXN0LlxuICpcbiAqIFlvdSBjYW4gcHJvdmlkZSBnZW5lcmF0ZWQgSW5uZ2VzdCB0eXBlcywgY3VzdG9tIHR5cGVzLCB0eXBlcyB1c2luZyBab2QsIG9yXG4gKiBhIGNvbWJpbmF0aW9uIG9mIHRoZSBhYm92ZS4gU2VlIHtAbGluayBFdmVudFNjaGVtYXN9IGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGV4cG9ydCBjb25zdCBpbm5nZXN0ID0gbmV3IElubmdlc3Qoe1xuICogICBpZDogXCJteS1hcHBcIixcbiAqICAgc2NoZW1hczogbmV3IEV2ZW50U2NoZW1hcygpLmZyb21ab2Qoe1xuICogICAgIFwiYXBwL3VzZXIuY3JlYXRlZFwiOiB7XG4gKiAgICAgICBkYXRhOiB6Lm9iamVjdCh7XG4gKiAgICAgICAgIGlkOiB6LnN0cmluZygpLFxuICogICAgICAgICBuYW1lOiB6LnN0cmluZygpLFxuICogICAgICAgfSksXG4gKiAgICAgfSxcbiAqICAgfSksXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRXZlbnRTY2hlbWFzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ydW50aW1lU2NoZW1hcyA9IHt9O1xuICAgIH1cbiAgICBhZGRSdW50aW1lU2NoZW1hcyhzY2hlbWFzKSB7XG4gICAgICAgIHRoaXMucnVudGltZVNjaGVtYXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMucnVudGltZVNjaGVtYXMpLCBzY2hlbWFzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIGdlbmVyYXRlZCBJbm5nZXN0IHR5cGVzIHRvIHR5cGUgZXZlbnRzLlxuICAgICAqL1xuICAgIGZyb21HZW5lcmF0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgYSBgUmVjb3JkPD5gIHR5cGUgdG8gdHlwZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBleHBvcnQgY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHtcbiAgICAgKiAgIGlkOiBcIm15LWFwcFwiLFxuICAgICAqICAgc2NoZW1hczogbmV3IEV2ZW50U2NoZW1hcygpLmZyb21SZWNvcmQ8e1xuICAgICAqICAgICBcImFwcC91c2VyLmNyZWF0ZWRcIjoge1xuICAgICAqICAgICAgIGRhdGE6IHtcbiAgICAgKiAgICAgICAgIGlkOiBzdHJpbmc7XG4gICAgICogICAgICAgICBuYW1lOiBzdHJpbmc7XG4gICAgICogICAgICAgfTtcbiAgICAgKiAgICAgfTtcbiAgICAgKiAgIH0+KCksXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnJvbVJlY29yZCguLi5fYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNlIGEgdW5pb24gdHlwZSB0byB0eXBlIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIHR5cGUgQWNjb3VudENyZWF0ZWQgPSB7XG4gICAgICogICBuYW1lOiBcImFwcC9hY2NvdW50LmNyZWF0ZWRcIjtcbiAgICAgKiAgIGRhdGE6IHsgb3JnOiBzdHJpbmcgfTtcbiAgICAgKiAgIHVzZXI6IHsgaWQ6IHN0cmluZyB9O1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB0eXBlIEFjY291bnREZWxldGVkID0ge1xuICAgICAqICAgbmFtZTogXCJhcHAvYWNjb3VudC5kZWxldGVkXCI7XG4gICAgICogICBkYXRhOiB7IG9yZzogc3RyaW5nIH07XG4gICAgICogICB1c2VyOiB7IGlkOiBzdHJpbmcgfTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdHlwZSBFdmVudHMgPSBBY2NvdW50Q3JlYXRlZCB8IEFjY291bnREZWxldGVkO1xuICAgICAqXG4gICAgICogZXhwb3J0IGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4gICAgICogICBpZDogXCJteS1hcHBcIixcbiAgICAgKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tVW5pb248RXZlbnRzPigpLFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZyb21VbmlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSBab2QgdG8gdHlwZSBldmVudHMuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBleHBvcnQgY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHtcbiAgICAgKiAgIGlkOiBcIm15LWFwcFwiLFxuICAgICAqICAgc2NoZW1hczogbmV3IEV2ZW50U2NoZW1hcygpLmZyb21ab2Qoe1xuICAgICAqICAgICBcImFwcC91c2VyLmNyZWF0ZWRcIjoge1xuICAgICAqICAgICAgIGRhdGE6IHoub2JqZWN0KHtcbiAgICAgKiAgICAgICAgIGlkOiB6LnN0cmluZygpLFxuICAgICAqICAgICAgICAgbmFtZTogei5zdHJpbmcoKSxcbiAgICAgKiAgICAgICB9KSxcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0pLFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZyb21ab2Qoc2NoZW1hcykge1xuICAgICAgICBsZXQgcnVudGltZVNjaGVtYXM7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYXMpKSB7XG4gICAgICAgICAgICBydW50aW1lU2NoZW1hcyA9IHNjaGVtYXMucmVkdWNlKChhY2MsIHNjaGVtYSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9hID0gc2NoZW1hLnNoYXBlLCB7IG5hbWU6IHsgdmFsdWU6IG5hbWUgfSB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcIm5hbWVcIl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW25hbWVdOiByZXN0IH0pO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcnVudGltZVNjaGVtYXMgPSBzY2hlbWFzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRkUnVudGltZVNjaGVtYXMocnVudGltZVNjaGVtYXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG59XG5leHBvcnRzLkV2ZW50U2NoZW1hcyA9IEV2ZW50U2NoZW1hcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUV2ZW50U2NoZW1hcy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/EventSchemas.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/Fetch.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/components/Fetch.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetch = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst als_js_1 = __webpack_require__(/*! ./execution/als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ./InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst globalFetch = globalThis.fetch;\nconst debug = (0, debug_1.default)(\"inngest:fetch\");\nconst createFetchShim = () => {\n    // eslint-disable-next-line prefer-const\n    let stepFetch;\n    const fetch = async (input, init) => {\n        const ctx = await (0, als_js_1.getAsyncCtx)();\n        if (!ctx) {\n            // Not in a function run\n            if (!stepFetch.fallback) {\n                // TODO Tell the user how to solve\n                throw new Error(\"step.fetch() called outside of a function and had no fallback set\");\n            }\n            debug(\"step.fetch() called outside of a function; falling back to global fetch\");\n            return stepFetch.fallback(input, init);\n        }\n        // In a function run\n        if (ctx.executingStep) {\n            // Inside a step\n            if (!stepFetch.fallback) {\n                // TODO Tell the user how to solve\n                throw new Error(`step.fetch() called inside step \"${ctx.executingStep.id}\" and had no fallback set`);\n            }\n            debug(`step.fetch() called inside step \"${ctx.executingStep.id}\"; falling back to global fetch`);\n            return stepFetch.fallback(input, init);\n        }\n        const targetUrl = new URL(input instanceof Request ? input.url : input.toString());\n        debug(\"step.fetch() shimming request to\", targetUrl.hostname);\n        // Purposefully do not try/cacth this; if it throws then we treat that as a\n        // regular `fetch()` throw, which also would not return a `Response`.\n        const jsonRes = await ctx.ctx.step[InngestStepTools_js_1.gatewaySymbol](`step.fetch: ${targetUrl.hostname}`, input, init);\n        return new Response(jsonRes.body, {\n            headers: jsonRes.headers,\n            status: jsonRes.status,\n        });\n    };\n    const optionsRef = {\n        fallback: globalFetch,\n    };\n    const extras = Object.assign({ config: (options) => {\n            Object.assign(optionsRef, options);\n            Object.assign(stepFetch, optionsRef);\n            return stepFetch;\n        } }, optionsRef);\n    stepFetch = Object.assign(fetch, extras);\n    return stepFetch;\n};\n/**\n * `fetch` is a Fetch API-compatible function that can be used to make any HTTP\n * code durable if it's called within an Inngest function.\n *\n * It will gracefully fall back to the global `fetch` if called outside of this\n * context, and a custom fallback can be set using the `config` method.\n *\n * @example Basic usage\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({ fetch });\n * ```\n *\n * @example Setting a custom fallback\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({\n *            fetch: fetch.config({ fallback: myCustomFetch }),\n * });\n * ```\n *\n * @example Do not allow fallback\n * ```ts\n * import { fetch } from \"inngest\";\n *\n * const api = new MyProductApi({\n *            fetch: fetch.config({ fallback: undefined }),\n * });\n * ```\n */\nexports.fetch = createFetchShim();\n//# sourceMappingURL=Fetch.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0ZldGNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYTtBQUNiLGdDQUFnQyxtQkFBTyxDQUFDLHNEQUFPO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLG9GQUFvQjtBQUM3Qyw4QkFBOEIsbUJBQU8sQ0FBQywwRkFBdUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UscUJBQXFCO0FBQ3pGO0FBQ0Esc0RBQXNELHFCQUFxQixHQUFHO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0EsK0ZBQStGLG1CQUFtQjtBQUNsSDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQSxvQ0FBb0MseUJBQXlCO0FBQzdELElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0Esb0NBQW9DLHFCQUFxQjtBQUN6RCxJQUFJO0FBQ0o7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvRmV0Y2guanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZldGNoID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgYWxzX2pzXzEgPSByZXF1aXJlKFwiLi9leGVjdXRpb24vYWxzLmpzXCIpO1xuY29uc3QgSW5uZ2VzdFN0ZXBUb29sc19qc18xID0gcmVxdWlyZShcIi4vSW5uZ2VzdFN0ZXBUb29scy5qc1wiKTtcbmNvbnN0IGdsb2JhbEZldGNoID0gZ2xvYmFsVGhpcy5mZXRjaDtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJpbm5nZXN0OmZldGNoXCIpO1xuY29uc3QgY3JlYXRlRmV0Y2hTaGltID0gKCkgPT4ge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQgc3RlcEZldGNoO1xuICAgIGNvbnN0IGZldGNoID0gYXN5bmMgKGlucHV0LCBpbml0KSA9PiB7XG4gICAgICAgIGNvbnN0IGN0eCA9IGF3YWl0ICgwLCBhbHNfanNfMS5nZXRBc3luY0N0eCkoKTtcbiAgICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgICAgIC8vIE5vdCBpbiBhIGZ1bmN0aW9uIHJ1blxuICAgICAgICAgICAgaWYgKCFzdGVwRmV0Y2guZmFsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFRlbGwgdGhlIHVzZXIgaG93IHRvIHNvbHZlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic3RlcC5mZXRjaCgpIGNhbGxlZCBvdXRzaWRlIG9mIGEgZnVuY3Rpb24gYW5kIGhhZCBubyBmYWxsYmFjayBzZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZyhcInN0ZXAuZmV0Y2goKSBjYWxsZWQgb3V0c2lkZSBvZiBhIGZ1bmN0aW9uOyBmYWxsaW5nIGJhY2sgdG8gZ2xvYmFsIGZldGNoXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXBGZXRjaC5mYWxsYmFjayhpbnB1dCwgaW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW4gYSBmdW5jdGlvbiBydW5cbiAgICAgICAgaWYgKGN0eC5leGVjdXRpbmdTdGVwKSB7XG4gICAgICAgICAgICAvLyBJbnNpZGUgYSBzdGVwXG4gICAgICAgICAgICBpZiAoIXN0ZXBGZXRjaC5mYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gVGVsbCB0aGUgdXNlciBob3cgdG8gc29sdmVcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0ZXAuZmV0Y2goKSBjYWxsZWQgaW5zaWRlIHN0ZXAgXCIke2N0eC5leGVjdXRpbmdTdGVwLmlkfVwiIGFuZCBoYWQgbm8gZmFsbGJhY2sgc2V0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1Zyhgc3RlcC5mZXRjaCgpIGNhbGxlZCBpbnNpZGUgc3RlcCBcIiR7Y3R4LmV4ZWN1dGluZ1N0ZXAuaWR9XCI7IGZhbGxpbmcgYmFjayB0byBnbG9iYWwgZmV0Y2hgKTtcbiAgICAgICAgICAgIHJldHVybiBzdGVwRmV0Y2guZmFsbGJhY2soaW5wdXQsIGluaXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldFVybCA9IG5ldyBVUkwoaW5wdXQgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gaW5wdXQudXJsIDogaW5wdXQudG9TdHJpbmcoKSk7XG4gICAgICAgIGRlYnVnKFwic3RlcC5mZXRjaCgpIHNoaW1taW5nIHJlcXVlc3QgdG9cIiwgdGFyZ2V0VXJsLmhvc3RuYW1lKTtcbiAgICAgICAgLy8gUHVycG9zZWZ1bGx5IGRvIG5vdCB0cnkvY2FjdGggdGhpczsgaWYgaXQgdGhyb3dzIHRoZW4gd2UgdHJlYXQgdGhhdCBhcyBhXG4gICAgICAgIC8vIHJlZ3VsYXIgYGZldGNoKClgIHRocm93LCB3aGljaCBhbHNvIHdvdWxkIG5vdCByZXR1cm4gYSBgUmVzcG9uc2VgLlxuICAgICAgICBjb25zdCBqc29uUmVzID0gYXdhaXQgY3R4LmN0eC5zdGVwW0lubmdlc3RTdGVwVG9vbHNfanNfMS5nYXRld2F5U3ltYm9sXShgc3RlcC5mZXRjaDogJHt0YXJnZXRVcmwuaG9zdG5hbWV9YCwgaW5wdXQsIGluaXQpO1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGpzb25SZXMuYm9keSwge1xuICAgICAgICAgICAgaGVhZGVyczoganNvblJlcy5oZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzOiBqc29uUmVzLnN0YXR1cyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvcHRpb25zUmVmID0ge1xuICAgICAgICBmYWxsYmFjazogZ2xvYmFsRmV0Y2gsXG4gICAgfTtcbiAgICBjb25zdCBleHRyYXMgPSBPYmplY3QuYXNzaWduKHsgY29uZmlnOiAob3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zUmVmLCBvcHRpb25zKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc3RlcEZldGNoLCBvcHRpb25zUmVmKTtcbiAgICAgICAgICAgIHJldHVybiBzdGVwRmV0Y2g7XG4gICAgICAgIH0gfSwgb3B0aW9uc1JlZik7XG4gICAgc3RlcEZldGNoID0gT2JqZWN0LmFzc2lnbihmZXRjaCwgZXh0cmFzKTtcbiAgICByZXR1cm4gc3RlcEZldGNoO1xufTtcbi8qKlxuICogYGZldGNoYCBpcyBhIEZldGNoIEFQSS1jb21wYXRpYmxlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gbWFrZSBhbnkgSFRUUFxuICogY29kZSBkdXJhYmxlIGlmIGl0J3MgY2FsbGVkIHdpdGhpbiBhbiBJbm5nZXN0IGZ1bmN0aW9uLlxuICpcbiAqIEl0IHdpbGwgZ3JhY2VmdWxseSBmYWxsIGJhY2sgdG8gdGhlIGdsb2JhbCBgZmV0Y2hgIGlmIGNhbGxlZCBvdXRzaWRlIG9mIHRoaXNcbiAqIGNvbnRleHQsIGFuZCBhIGN1c3RvbSBmYWxsYmFjayBjYW4gYmUgc2V0IHVzaW5nIHRoZSBgY29uZmlnYCBtZXRob2QuXG4gKlxuICogQGV4YW1wbGUgQmFzaWMgdXNhZ2VcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmZXRjaCB9IGZyb20gXCJpbm5nZXN0XCI7XG4gKlxuICogY29uc3QgYXBpID0gbmV3IE15UHJvZHVjdEFwaSh7IGZldGNoIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGUgU2V0dGluZyBhIGN1c3RvbSBmYWxsYmFja1xuICogYGBgdHNcbiAqIGltcG9ydCB7IGZldGNoIH0gZnJvbSBcImlubmdlc3RcIjtcbiAqXG4gKiBjb25zdCBhcGkgPSBuZXcgTXlQcm9kdWN0QXBpKHtcbiAqICAgICAgICAgICAgZmV0Y2g6IGZldGNoLmNvbmZpZyh7IGZhbGxiYWNrOiBteUN1c3RvbUZldGNoIH0pLFxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAZXhhbXBsZSBEbyBub3QgYWxsb3cgZmFsbGJhY2tcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBmZXRjaCB9IGZyb20gXCJpbm5nZXN0XCI7XG4gKlxuICogY29uc3QgYXBpID0gbmV3IE15UHJvZHVjdEFwaSh7XG4gKiAgICAgICAgICAgIGZldGNoOiBmZXRjaC5jb25maWcoeyBmYWxsYmFjazogdW5kZWZpbmVkIH0pLFxuICogfSk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0cy5mZXRjaCA9IGNyZWF0ZUZldGNoU2hpbSgpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmV0Y2guanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/Fetch.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/Inngest.js":
/*!****************************************************!*\
  !*** ./node_modules/inngest/components/Inngest.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.builtInMiddleware = exports.Inngest = void 0;\nconst api_js_1 = __webpack_require__(/*! ../api/api.js */ \"(rsc)/./node_modules/inngest/api/api.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst crypto_js_1 = __webpack_require__(/*! ../helpers/crypto.js */ \"(rsc)/./node_modules/inngest/helpers/crypto.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst env_js_1 = __webpack_require__(/*! ../helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst promises_js_1 = __webpack_require__(/*! ../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst logger_js_1 = __webpack_require__(/*! ../middleware/logger.js */ \"(rsc)/./node_modules/inngest/middleware/logger.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst InngestFunction_js_1 = __webpack_require__(/*! ./InngestFunction.js */ \"(rsc)/./node_modules/inngest/components/InngestFunction.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ./InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\n/**\n * A client used to interact with the Inngest API by sending or reacting to\n * events.\n *\n * To provide event typing, see {@link EventSchemas}.\n *\n * ```ts\n * const inngest = new Inngest({ id: \"my-app\" });\n *\n * // or to provide event typing too\n * const inngest = new Inngest({\n *   id: \"my-app\",\n *   schemas: new EventSchemas().fromRecord<{\n *     \"app/user.created\": {\n *       data: { userId: string };\n *     };\n *   }>(),\n * });\n * ```\n *\n * @public\n */\nclass Inngest {\n    get apiBaseUrl() {\n        return this._apiBaseUrl;\n    }\n    get eventBaseUrl() {\n        return this._eventBaseUrl;\n    }\n    get env() {\n        var _a;\n        return (_a = this.headers[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;\n    }\n    get appVersion() {\n        return this._appVersion;\n    }\n    /**\n     * A client used to interact with the Inngest API by sending or reacting to\n     * events.\n     *\n     * To provide event typing, see {@link EventSchemas}.\n     *\n     * ```ts\n     * const inngest = new Inngest({ name: \"My App\" });\n     *\n     * // or to provide event typing too\n     * const inngest = new Inngest({\n     *   name: \"My App\",\n     *   schemas: new EventSchemas().fromRecord<{\n     *     \"app/user.created\": {\n     *       data: { userId: string };\n     *     };\n     *   }>(),\n     * });\n     * ```\n     */\n    constructor(options) {\n        /**\n         * Inngest event key, used to send events to Inngest Cloud.\n         */\n        this.eventKey = \"\";\n        /**\n         * The absolute URL of the Inngest Cloud API.\n         */\n        this.sendEventUrl = new URL(`e/${this.eventKey}`, consts_js_1.defaultInngestEventBaseUrl);\n        this.localFns = [];\n        this.createFunction = (rawOptions, rawTrigger, handler) => {\n            const fn = this._createFunction(rawOptions, rawTrigger, handler);\n            this.localFns.push(fn);\n            return fn;\n        };\n        this._createFunction = (rawOptions, rawTrigger, handler) => {\n            const options = this.sanitizeOptions(rawOptions);\n            const triggers = this.sanitizeTriggers(rawTrigger);\n            return new InngestFunction_js_1.InngestFunction(this, Object.assign(Object.assign({}, options), { triggers }), handler);\n        };\n        this.options = options;\n        const { id, fetch, logger = new logger_js_1.DefaultLogger(), middleware, isDev, schemas, appVersion, } = this.options;\n        if (!id) {\n            // TODO PrettyError\n            throw new Error(\"An `id` must be passed to create an Inngest instance.\");\n        }\n        this.id = id;\n        this._mode = (0, env_js_1.getMode)({\n            explicitMode: typeof isDev === \"boolean\" ? (isDev ? \"dev\" : \"cloud\") : undefined,\n        });\n        this.fetch = (0, env_js_1.getFetch)(fetch);\n        this.inngestApi = new api_js_1.InngestApi({\n            baseUrl: this.apiBaseUrl,\n            signingKey: (0, env_js_1.processEnv)(consts_js_1.envKeys.InngestSigningKey) || \"\",\n            signingKeyFallback: (0, env_js_1.processEnv)(consts_js_1.envKeys.InngestSigningKeyFallback),\n            fetch: this.fetch,\n            mode: this.mode,\n        });\n        this.schemas = schemas;\n        this.loadModeEnvVars();\n        this.logger = logger;\n        this.middleware = this.initializeMiddleware([\n            ...exports.builtInMiddleware,\n            ...(middleware || []),\n        ]);\n        this._appVersion = appVersion;\n    }\n    /**\n     * Returns a `Promise` that resolves when the app is ready and all middleware\n     * has been initialized.\n     */\n    get ready() {\n        return this.middleware.then(() => { });\n    }\n    /**\n     * Set the environment variables for this client. This is useful if you are\n     * passed environment variables at runtime instead of as globals and need to\n     * update the client with those values as requests come in.\n     */\n    setEnvVars(env = (0, env_js_1.allProcessEnv)()) {\n        this.mode = (0, env_js_1.getMode)({ env, client: this });\n        return this;\n    }\n    loadModeEnvVars() {\n        this._apiBaseUrl =\n            this.options.baseUrl ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestApiBaseUrl] ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestBaseUrl] ||\n                this.mode.getExplicitUrl(consts_js_1.defaultInngestApiBaseUrl);\n        this._eventBaseUrl =\n            this.options.baseUrl ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestEventApiBaseUrl] ||\n                this.mode[\"env\"][consts_js_1.envKeys.InngestBaseUrl] ||\n                this.mode.getExplicitUrl(consts_js_1.defaultInngestEventBaseUrl);\n        this.setEventKey(this.options.eventKey || this.mode[\"env\"][consts_js_1.envKeys.InngestEventKey] || \"\");\n        this.headers = (0, env_js_1.inngestHeaders)({\n            inngestEnv: this.options.env,\n            env: this.mode[\"env\"],\n        });\n        this.inngestApi[\"mode\"] = this.mode;\n        this.inngestApi[\"apiBaseUrl\"] = this._apiBaseUrl;\n    }\n    /**\n     * Initialize all passed middleware, running the `register` function on each\n     * in sequence and returning the requested hook registrations.\n     */\n    async initializeMiddleware(middleware = [], opts) {\n        var _a;\n        /**\n         * Wait for the prefix stack to run first; do not trigger ours before this\n         * is complete.\n         */\n        const prefix = await ((_a = opts === null || opts === void 0 ? void 0 : opts.prefixStack) !== null && _a !== void 0 ? _a : []);\n        const stack = middleware.reduce(async (acc, m) => {\n            // Be explicit about waiting for the previous middleware to finish\n            const prev = await acc;\n            const next = await m.init(Object.assign({ client: this }, opts === null || opts === void 0 ? void 0 : opts.registerInput));\n            return [...prev, next];\n        }, Promise.resolve([]));\n        return [...prefix, ...(await stack)];\n    }\n    get mode() {\n        return this._mode;\n    }\n    set mode(m) {\n        this._mode = m;\n        this.loadModeEnvVars();\n    }\n    /**\n     * Given a response from Inngest, relay the error to the caller.\n     */\n    async getResponseError(response, rawBody, foundErr = \"Unknown error\") {\n        let errorMessage = foundErr;\n        if (errorMessage === \"Unknown error\") {\n            switch (response.status) {\n                case 401:\n                    errorMessage = \"Event key Not Found\";\n                    break;\n                case 400:\n                    errorMessage = \"Cannot process event payload\";\n                    break;\n                case 403:\n                    errorMessage = \"Forbidden\";\n                    break;\n                case 404:\n                    errorMessage = \"Event key not found\";\n                    break;\n                case 406:\n                    errorMessage = `${JSON.stringify(await rawBody)}`;\n                    break;\n                case 409:\n                case 412:\n                    errorMessage = \"Event transformation failed\";\n                    break;\n                case 413:\n                    errorMessage = \"Event payload too large\";\n                    break;\n                case 500:\n                    errorMessage = \"Internal server error\";\n                    break;\n                default:\n                    try {\n                        errorMessage = await response.text();\n                    }\n                    catch (err) {\n                        errorMessage = `${JSON.stringify(await rawBody)}`;\n                    }\n                    break;\n            }\n        }\n        return new Error(`Inngest API Error: ${response.status} ${errorMessage}`);\n    }\n    /**\n     * Set the event key for this instance of Inngest. This is useful if for some\n     * reason the key is not available at time of instantiation or present in the\n     * `INNGEST_EVENT_KEY` environment variable.\n     */\n    setEventKey(\n    /**\n     * Inngest event key, used to send events to Inngest Cloud. Use this is your\n     * key is for some reason not available at time of instantiation or present\n     * in the `INNGEST_EVENT_KEY` environment variable.\n     */\n    eventKey) {\n        this.eventKey = eventKey || consts_js_1.dummyEventKey;\n        this.sendEventUrl = new URL(`e/${this.eventKey}`, this.eventBaseUrl || consts_js_1.defaultInngestEventBaseUrl);\n    }\n    eventKeySet() {\n        return Boolean(this.eventKey) && this.eventKey !== consts_js_1.dummyEventKey;\n    }\n    /**\n     * EXPERIMENTAL: This API is not yet stable and may change in the future\n     * without a major version bump.\n     *\n     * Send a Signal to Inngest.\n     */\n    async sendSignal({ signal, data, env, }) {\n        const headers = Object.assign({}, (env ? { [consts_js_1.headerKeys.Environment]: env } : {}));\n        return this._sendSignal({ signal, data, headers });\n    }\n    async _sendSignal({ signal, data, headers, }) {\n        var _a;\n        const res = await this.inngestApi.sendSignal({ signal, data }, Object.assign(Object.assign({}, this.headers), headers));\n        if (res.ok) {\n            return res.value;\n        }\n        throw new Error(`Failed to send signal: ${((_a = res.error) === null || _a === void 0 ? void 0 : _a.error) || \"Unknown error\"}`);\n    }\n    /**\n     * Send one or many events to Inngest. Takes an entire payload (including\n     * name) as each input.\n     *\n     * ```ts\n     * await inngest.send({ name: \"app/user.created\", data: { id: 123 } });\n     * ```\n     *\n     * Returns a promise that will resolve if the event(s) were sent successfully,\n     * else throws with an error explaining what went wrong.\n     *\n     * If you wish to send an event with custom types (i.e. one that hasn't been\n     * generated), make sure to add it when creating your Inngest instance, like\n     * so:\n     *\n     * ```ts\n     * const inngest = new Inngest({\n     *   name: \"My App\",\n     *   schemas: new EventSchemas().fromRecord<{\n     *     \"my/event\": {\n     *       name: \"my/event\";\n     *       data: { bar: string };\n     *     };\n     *   }>(),\n     * });\n     * ```\n     */\n    async send(payload, options) {\n        const headers = Object.assign({}, ((options === null || options === void 0 ? void 0 : options.env) ? { [consts_js_1.headerKeys.Environment]: options.env } : {}));\n        return this._send({ payload, headers });\n    }\n    /**\n     * Internal method for sending an event, used to allow Inngest internals to\n     * further customize the request sent to an Inngest Server.\n     */\n    async _send({ payload, headers, }) {\n        var _a;\n        const nowMillis = new Date().getTime();\n        let maxAttempts = 5;\n        // Attempt to set the event ID seed header. If it fails then disable retries\n        // (but we still want to send the event).\n        try {\n            const entropy = (0, crypto_js_1.createEntropy)(10);\n            const entropyBase64 = Buffer.from(entropy).toString(\"base64\");\n            headers = Object.assign(Object.assign({}, headers), { [consts_js_1.headerKeys.EventIdSeed]: `${nowMillis},${entropyBase64}` });\n        }\n        catch (err) {\n            let message = \"Event-sending retries disabled\";\n            if (err instanceof Error) {\n                message += `: ${err.message}`;\n            }\n            console.debug(message);\n            // Disable retries.\n            maxAttempts = 1;\n        }\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.middleware, \"onSendEvent\", undefined, {\n            transformInput: (prev, output) => {\n                return Object.assign(Object.assign({}, prev), output);\n            },\n            transformOutput(prev, output) {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                };\n            },\n        });\n        let payloads = Array.isArray(payload)\n            ? payload\n            : payload\n                ? [payload]\n                : [];\n        const inputChanges = await ((_a = hooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(hooks, {\n            payloads: [...payloads],\n        }));\n        if (inputChanges === null || inputChanges === void 0 ? void 0 : inputChanges.payloads) {\n            payloads = [...inputChanges.payloads];\n        }\n        // Ensure that we always add \"ts\" and \"data\" fields to events. \"ts\" is auto-\n        // filled by the event server so is safe, and adding here fixes Next.js\n        // server action cache issues.\n        payloads = payloads.map((p) => {\n            return Object.assign(Object.assign({}, p), { \n                // Always generate an idempotency ID for an event for retries\n                id: p.id, ts: p.ts || nowMillis, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                data: p.data || {} });\n        });\n        const applyHookToOutput = async (arg) => {\n            var _a;\n            const hookOutput = await ((_a = hooks.transformOutput) === null || _a === void 0 ? void 0 : _a.call(hooks, arg));\n            return Object.assign(Object.assign({}, arg.result), hookOutput === null || hookOutput === void 0 ? void 0 : hookOutput.result);\n        };\n        /**\n         * It can be valid for a user to send an empty list of events; if this\n         * happens, show a warning that this may not be intended, but don't throw.\n         */\n        if (!payloads.length) {\n            console.warn((0, errors_js_1.prettyError)({\n                type: \"warn\",\n                whatHappened: \"`inngest.send()` called with no events\",\n                reassurance: \"This is not an error, but you may not have intended to do this.\",\n                consequences: \"The returned promise will resolve, but no events have been sent to Inngest.\",\n                stack: true,\n            }));\n            return await applyHookToOutput({ result: { ids: [] } });\n        }\n        // When sending events, check if the dev server is available.  If so, use the\n        // dev server.\n        let url = this.sendEventUrl.href;\n        /**\n         * If in prod mode and key is not present, fail now.\n         */\n        if (this.mode.isCloud && !this.eventKeySet()) {\n            throw new Error((0, errors_js_1.prettyError)({\n                whatHappened: \"Failed to send event\",\n                consequences: \"Your event or events were not sent to Inngest.\",\n                why: \"We couldn't find an event key to use to send events to Inngest.\",\n                toFixNow: errors_js_1.fixEventKeyMissingSteps,\n            }));\n        }\n        /**\n         * If dev mode has been inferred, try to hit the dev server first to see if\n         * it exists. If it does, use it, otherwise fall back to whatever server we\n         * have configured.\n         *\n         * `INNGEST_BASE_URL` is used to set both dev server and prod URLs, so if a\n         * user has set this it means they have already chosen a URL to hit.\n         */\n        if (this.mode.isDev && this.mode.isInferred && !this.eventBaseUrl) {\n            const devAvailable = await (0, devserver_js_1.devServerAvailable)(consts_js_1.defaultDevServerHost, this.fetch);\n            if (devAvailable) {\n                url = (0, devserver_js_1.devServerUrl)(consts_js_1.defaultDevServerHost, `e/${this.eventKey}`).href;\n            }\n        }\n        const body = await (0, promises_js_1.retryWithBackoff)(async () => {\n            let rawBody;\n            let body;\n            // We don't need to do fallback auth here because this uses event keys and\n            // not signing keys\n            const response = await this.fetch(url, {\n                method: \"POST\",\n                body: (0, strings_js_1.stringify)(payloads),\n                headers: Object.assign(Object.assign({}, this.headers), headers),\n            });\n            try {\n                rawBody = await response.json();\n                body = await types_js_1.sendEventResponseSchema.parseAsync(rawBody);\n            }\n            catch (err) {\n                throw await this.getResponseError(response, rawBody);\n            }\n            if (body.status !== 200 || body.error) {\n                throw await this.getResponseError(response, rawBody, body.error);\n            }\n            return body;\n        }, {\n            maxAttempts,\n            baseDelay: 100,\n        });\n        return await applyHookToOutput({ result: { ids: body.ids } });\n    }\n    get funcs() {\n        return this.localFns;\n    }\n    /**\n     * Runtime-only validation.\n     */\n    sanitizeOptions(options) {\n        if (Object.prototype.hasOwnProperty.call(options, \"fns\")) {\n            // v2 -> v3 migration warning\n            console.warn(`${consts_js_1.logPrefix} InngestFunction: \\`fns\\` option has been deprecated in v3; use \\`middleware\\` instead. See https://www.inngest.com/docs/sdk/migration`);\n        }\n        if (typeof options === \"string\") {\n            // v2 -> v3 runtime migraton warning\n            console.warn(`${consts_js_1.logPrefix} InngestFunction: Creating a function with a string as the first argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);\n            return { id: options };\n        }\n        return options;\n    }\n    /**\n     * Runtime-only validation.\n     */\n    sanitizeTriggers(triggers) {\n        if (typeof triggers === \"string\") {\n            // v2 -> v3 migration warning\n            console.warn(`${consts_js_1.logPrefix} InngestFunction: Creating a function with a string as the second argument has been deprecated in v3; pass an object instead. See https://www.inngest.com/docs/sdk/migration`);\n            return [{ event: triggers }];\n        }\n        if (!Array.isArray(triggers)) {\n            return [triggers];\n        }\n        return triggers;\n    }\n}\nexports.Inngest = Inngest;\n/**\n * Default middleware that is included in every client, placed after the user's\n * middleware on the client but before function-level middleware.\n *\n * It is defined here to ensure that comments are included in the generated TS\n * definitions. Without this, we infer the stack of built-in middleware without\n * comments, losing a lot of value.\n *\n * If this is moved, please ensure that using this package in another project\n * can correctly access comments on mutated input and output.\n *\n * This return pattern mimics the output of a `satisfies` suffix; it's used as\n * we support versions of TypeScript prior to the introduction of `satisfies`.\n */\nexports.builtInMiddleware = ((m) => m)([\n    new InngestMiddleware_js_1.InngestMiddleware({\n        name: \"Inngest: Logger\",\n        init({ client }) {\n            return {\n                onFunctionRun(arg) {\n                    const { ctx } = arg;\n                    const metadata = {\n                        runID: ctx.runId,\n                        eventName: ctx.event.name,\n                        functionName: arg.fn.name,\n                    };\n                    let providedLogger = client[\"logger\"];\n                    // create a child logger if the provided logger has child logger implementation\n                    try {\n                        if (\"child\" in providedLogger) {\n                            providedLogger = providedLogger.child(metadata);\n                        }\n                    }\n                    catch (err) {\n                        console.error('failed to create \"childLogger\" with error: ', err);\n                        // no-op\n                    }\n                    const logger = new logger_js_1.ProxyLogger(providedLogger);\n                    return {\n                        transformInput() {\n                            return {\n                                ctx: {\n                                    /**\n                                     * The passed in logger from the user.\n                                     * Defaults to a console logger if not provided.\n                                     */\n                                    logger: logger,\n                                },\n                            };\n                        },\n                        beforeExecution() {\n                            logger.enable();\n                        },\n                        transformOutput({ result: { error } }) {\n                            if (error) {\n                                logger.error(error);\n                            }\n                        },\n                        async beforeResponse() {\n                            await logger.flush();\n                        },\n                    };\n                },\n            };\n        },\n    }),\n]);\n//# sourceMappingURL=Inngest.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsZUFBZTtBQUMzQyxpQkFBaUIsbUJBQU8sQ0FBQyw4REFBZTtBQUN4QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHVCQUF1QixtQkFBTyxDQUFDLGtGQUF5QjtBQUN4RCxpQkFBaUIsbUJBQU8sQ0FBQyxzRUFBbUI7QUFDNUMsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHNCQUFzQixtQkFBTyxDQUFDLGdGQUF3QjtBQUN0RCxxQkFBcUIsbUJBQU8sQ0FBQyw4RUFBdUI7QUFDcEQsb0JBQW9CLG1CQUFPLENBQUMsa0ZBQXlCO0FBQ3JELG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDLDZCQUE2QixtQkFBTyxDQUFDLHdGQUFzQjtBQUMzRCwrQkFBK0IsbUJBQU8sQ0FBQyw0RkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CO0FBQ3BEO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLG1CQUFtQjtBQUN4RDtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGNBQWM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLGNBQWMsVUFBVTtBQUN4SDtBQUNBO0FBQ0EsZ0JBQWdCLCtGQUErRjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1CQUFtQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsOEJBQThCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDhCQUE4QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxpQkFBaUIsRUFBRSxhQUFhO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsY0FBYztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvQkFBb0I7QUFDM0Msd0NBQXdDLFdBQVcsNENBQTRDLElBQUk7QUFDbkcsa0NBQWtDLHVCQUF1QjtBQUN6RDtBQUNBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQSx1REFBdUQsY0FBYyxnQ0FBZ0M7QUFDckc7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELG9GQUFvRjtBQUN0STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDLFdBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsdUVBQXVFLG9EQUFvRCxJQUFJO0FBQ3ZLLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjLHlDQUF5QyxVQUFVLEdBQUcsY0FBYyxHQUFHO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFlBQVk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDZDQUE2QyxVQUFVLFdBQVc7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGNBQWM7QUFDNUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCx5Q0FBeUMsVUFBVSxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCLDJEQUEyRDtBQUM5RztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsdUJBQXVCLG9HQUFvRztBQUN2SixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHVCQUF1QixxR0FBcUc7QUFDeEosc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EsNEJBQTRCLE1BQU07QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLDBDQUEwQyxVQUFVLFNBQVM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJ1aWx0SW5NaWRkbGV3YXJlID0gZXhwb3J0cy5Jbm5nZXN0ID0gdm9pZCAwO1xuY29uc3QgYXBpX2pzXzEgPSByZXF1aXJlKFwiLi4vYXBpL2FwaS5qc1wiKTtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuY29uc3QgY3J5cHRvX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9jcnlwdG8uanNcIik7XG5jb25zdCBkZXZzZXJ2ZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2RldnNlcnZlci5qc1wiKTtcbmNvbnN0IGVudl9qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZW52LmpzXCIpO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lcnJvcnMuanNcIik7XG5jb25zdCBwcm9taXNlc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvcHJvbWlzZXMuanNcIik7XG5jb25zdCBzdHJpbmdzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zdHJpbmdzLmpzXCIpO1xuY29uc3QgbG9nZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi4vbWlkZGxld2FyZS9sb2dnZXIuanNcIik7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4uL3R5cGVzLmpzXCIpO1xuY29uc3QgSW5uZ2VzdEZ1bmN0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9Jbm5nZXN0RnVuY3Rpb24uanNcIik7XG5jb25zdCBJbm5nZXN0TWlkZGxld2FyZV9qc18xID0gcmVxdWlyZShcIi4vSW5uZ2VzdE1pZGRsZXdhcmUuanNcIik7XG4vKipcbiAqIEEgY2xpZW50IHVzZWQgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgSW5uZ2VzdCBBUEkgYnkgc2VuZGluZyBvciByZWFjdGluZyB0b1xuICogZXZlbnRzLlxuICpcbiAqIFRvIHByb3ZpZGUgZXZlbnQgdHlwaW5nLCBzZWUge0BsaW5rIEV2ZW50U2NoZW1hc30uXG4gKlxuICogYGBgdHNcbiAqIGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7IGlkOiBcIm15LWFwcFwiIH0pO1xuICpcbiAqIC8vIG9yIHRvIHByb3ZpZGUgZXZlbnQgdHlwaW5nIHRvb1xuICogY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHtcbiAqICAgaWQ6IFwibXktYXBwXCIsXG4gKiAgIHNjaGVtYXM6IG5ldyBFdmVudFNjaGVtYXMoKS5mcm9tUmVjb3JkPHtcbiAqICAgICBcImFwcC91c2VyLmNyZWF0ZWRcIjoge1xuICogICAgICAgZGF0YTogeyB1c2VySWQ6IHN0cmluZyB9O1xuICogICAgIH07XG4gKiAgIH0+KCksXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSW5uZ2VzdCB7XG4gICAgZ2V0IGFwaUJhc2VVcmwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcGlCYXNlVXJsO1xuICAgIH1cbiAgICBnZXQgZXZlbnRCYXNlVXJsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRCYXNlVXJsO1xuICAgIH1cbiAgICBnZXQgZW52KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLmhlYWRlcnNbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5FbnZpcm9ubWVudF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBhcHBWZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwVmVyc2lvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBjbGllbnQgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBJbm5nZXN0IEFQSSBieSBzZW5kaW5nIG9yIHJlYWN0aW5nIHRvXG4gICAgICogZXZlbnRzLlxuICAgICAqXG4gICAgICogVG8gcHJvdmlkZSBldmVudCB0eXBpbmcsIHNlZSB7QGxpbmsgRXZlbnRTY2hlbWFzfS5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHsgbmFtZTogXCJNeSBBcHBcIiB9KTtcbiAgICAgKlxuICAgICAqIC8vIG9yIHRvIHByb3ZpZGUgZXZlbnQgdHlwaW5nIHRvb1xuICAgICAqIGNvbnN0IGlubmdlc3QgPSBuZXcgSW5uZ2VzdCh7XG4gICAgICogICBuYW1lOiBcIk15IEFwcFwiLFxuICAgICAqICAgc2NoZW1hczogbmV3IEV2ZW50U2NoZW1hcygpLmZyb21SZWNvcmQ8e1xuICAgICAqICAgICBcImFwcC91c2VyLmNyZWF0ZWRcIjoge1xuICAgICAqICAgICAgIGRhdGE6IHsgdXNlcklkOiBzdHJpbmcgfTtcbiAgICAgKiAgICAgfTtcbiAgICAgKiAgIH0+KCksXG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5uZ2VzdCBldmVudCBrZXksIHVzZWQgdG8gc2VuZCBldmVudHMgdG8gSW5uZ2VzdCBDbG91ZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZXZlbnRLZXkgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFic29sdXRlIFVSTCBvZiB0aGUgSW5uZ2VzdCBDbG91ZCBBUEkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbmRFdmVudFVybCA9IG5ldyBVUkwoYGUvJHt0aGlzLmV2ZW50S2V5fWAsIGNvbnN0c19qc18xLmRlZmF1bHRJbm5nZXN0RXZlbnRCYXNlVXJsKTtcbiAgICAgICAgdGhpcy5sb2NhbEZucyA9IFtdO1xuICAgICAgICB0aGlzLmNyZWF0ZUZ1bmN0aW9uID0gKHJhd09wdGlvbnMsIHJhd1RyaWdnZXIsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZuID0gdGhpcy5fY3JlYXRlRnVuY3Rpb24ocmF3T3B0aW9ucywgcmF3VHJpZ2dlciwgaGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLmxvY2FsRm5zLnB1c2goZm4pO1xuICAgICAgICAgICAgcmV0dXJuIGZuO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9jcmVhdGVGdW5jdGlvbiA9IChyYXdPcHRpb25zLCByYXdUcmlnZ2VyLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5zYW5pdGl6ZU9wdGlvbnMocmF3T3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuc2FuaXRpemVUcmlnZ2VycyhyYXdUcmlnZ2VyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5uZ2VzdEZ1bmN0aW9uX2pzXzEuSW5uZ2VzdEZ1bmN0aW9uKHRoaXMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgdHJpZ2dlcnMgfSksIGhhbmRsZXIpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBjb25zdCB7IGlkLCBmZXRjaCwgbG9nZ2VyID0gbmV3IGxvZ2dlcl9qc18xLkRlZmF1bHRMb2dnZXIoKSwgbWlkZGxld2FyZSwgaXNEZXYsIHNjaGVtYXMsIGFwcFZlcnNpb24sIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gUHJldHR5RXJyb3JcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFuIGBpZGAgbXVzdCBiZSBwYXNzZWQgdG8gY3JlYXRlIGFuIElubmdlc3QgaW5zdGFuY2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5fbW9kZSA9ICgwLCBlbnZfanNfMS5nZXRNb2RlKSh7XG4gICAgICAgICAgICBleHBsaWNpdE1vZGU6IHR5cGVvZiBpc0RldiA9PT0gXCJib29sZWFuXCIgPyAoaXNEZXYgPyBcImRldlwiIDogXCJjbG91ZFwiKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSAoMCwgZW52X2pzXzEuZ2V0RmV0Y2gpKGZldGNoKTtcbiAgICAgICAgdGhpcy5pbm5nZXN0QXBpID0gbmV3IGFwaV9qc18xLklubmdlc3RBcGkoe1xuICAgICAgICAgICAgYmFzZVVybDogdGhpcy5hcGlCYXNlVXJsLFxuICAgICAgICAgICAgc2lnbmluZ0tleTogKDAsIGVudl9qc18xLnByb2Nlc3NFbnYpKGNvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFNpZ25pbmdLZXkpIHx8IFwiXCIsXG4gICAgICAgICAgICBzaWduaW5nS2V5RmFsbGJhY2s6ICgwLCBlbnZfanNfMS5wcm9jZXNzRW52KShjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTaWduaW5nS2V5RmFsbGJhY2spLFxuICAgICAgICAgICAgZmV0Y2g6IHRoaXMuZmV0Y2gsXG4gICAgICAgICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNjaGVtYXMgPSBzY2hlbWFzO1xuICAgICAgICB0aGlzLmxvYWRNb2RlRW52VmFycygpO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgdGhpcy5taWRkbGV3YXJlID0gdGhpcy5pbml0aWFsaXplTWlkZGxld2FyZShbXG4gICAgICAgICAgICAuLi5leHBvcnRzLmJ1aWx0SW5NaWRkbGV3YXJlLFxuICAgICAgICAgICAgLi4uKG1pZGRsZXdhcmUgfHwgW10pLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5fYXBwVmVyc2lvbiA9IGFwcFZlcnNpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBhcHAgaXMgcmVhZHkgYW5kIGFsbCBtaWRkbGV3YXJlXG4gICAgICogaGFzIGJlZW4gaW5pdGlhbGl6ZWQuXG4gICAgICovXG4gICAgZ2V0IHJlYWR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWRkbGV3YXJlLnRoZW4oKCkgPT4geyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgZm9yIHRoaXMgY2xpZW50LiBUaGlzIGlzIHVzZWZ1bCBpZiB5b3UgYXJlXG4gICAgICogcGFzc2VkIGVudmlyb25tZW50IHZhcmlhYmxlcyBhdCBydW50aW1lIGluc3RlYWQgb2YgYXMgZ2xvYmFscyBhbmQgbmVlZCB0b1xuICAgICAqIHVwZGF0ZSB0aGUgY2xpZW50IHdpdGggdGhvc2UgdmFsdWVzIGFzIHJlcXVlc3RzIGNvbWUgaW4uXG4gICAgICovXG4gICAgc2V0RW52VmFycyhlbnYgPSAoMCwgZW52X2pzXzEuYWxsUHJvY2Vzc0VudikoKSkge1xuICAgICAgICB0aGlzLm1vZGUgPSAoMCwgZW52X2pzXzEuZ2V0TW9kZSkoeyBlbnYsIGNsaWVudDogdGhpcyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGxvYWRNb2RlRW52VmFycygpIHtcbiAgICAgICAgdGhpcy5fYXBpQmFzZVVybCA9XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMuYmFzZVVybCB8fFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZVtcImVudlwiXVtjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RBcGlCYXNlVXJsXSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZVtcImVudlwiXVtjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RCYXNlVXJsXSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZS5nZXRFeHBsaWNpdFVybChjb25zdHNfanNfMS5kZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwpO1xuICAgICAgICB0aGlzLl9ldmVudEJhc2VVcmwgPVxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmJhc2VVcmwgfHxcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVbXCJlbnZcIl1bY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RXZlbnRBcGlCYXNlVXJsXSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZVtcImVudlwiXVtjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RCYXNlVXJsXSB8fFxuICAgICAgICAgICAgICAgIHRoaXMubW9kZS5nZXRFeHBsaWNpdFVybChjb25zdHNfanNfMS5kZWZhdWx0SW5uZ2VzdEV2ZW50QmFzZVVybCk7XG4gICAgICAgIHRoaXMuc2V0RXZlbnRLZXkodGhpcy5vcHRpb25zLmV2ZW50S2V5IHx8IHRoaXMubW9kZVtcImVudlwiXVtjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RFdmVudEtleV0gfHwgXCJcIik7XG4gICAgICAgIHRoaXMuaGVhZGVycyA9ICgwLCBlbnZfanNfMS5pbm5nZXN0SGVhZGVycykoe1xuICAgICAgICAgICAgaW5uZ2VzdEVudjogdGhpcy5vcHRpb25zLmVudixcbiAgICAgICAgICAgIGVudjogdGhpcy5tb2RlW1wiZW52XCJdLFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5pbm5nZXN0QXBpW1wibW9kZVwiXSA9IHRoaXMubW9kZTtcbiAgICAgICAgdGhpcy5pbm5nZXN0QXBpW1wiYXBpQmFzZVVybFwiXSA9IHRoaXMuX2FwaUJhc2VVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgYWxsIHBhc3NlZCBtaWRkbGV3YXJlLCBydW5uaW5nIHRoZSBgcmVnaXN0ZXJgIGZ1bmN0aW9uIG9uIGVhY2hcbiAgICAgKiBpbiBzZXF1ZW5jZSBhbmQgcmV0dXJuaW5nIHRoZSByZXF1ZXN0ZWQgaG9vayByZWdpc3RyYXRpb25zLlxuICAgICAqL1xuICAgIGFzeW5jIGluaXRpYWxpemVNaWRkbGV3YXJlKG1pZGRsZXdhcmUgPSBbXSwgb3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYWl0IGZvciB0aGUgcHJlZml4IHN0YWNrIHRvIHJ1biBmaXJzdDsgZG8gbm90IHRyaWdnZXIgb3VycyBiZWZvcmUgdGhpc1xuICAgICAgICAgKiBpcyBjb21wbGV0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHByZWZpeCA9IGF3YWl0ICgoX2EgPSBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMucHJlZml4U3RhY2spICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdKTtcbiAgICAgICAgY29uc3Qgc3RhY2sgPSBtaWRkbGV3YXJlLnJlZHVjZShhc3luYyAoYWNjLCBtKSA9PiB7XG4gICAgICAgICAgICAvLyBCZSBleHBsaWNpdCBhYm91dCB3YWl0aW5nIGZvciB0aGUgcHJldmlvdXMgbWlkZGxld2FyZSB0byBmaW5pc2hcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBhd2FpdCBhY2M7XG4gICAgICAgICAgICBjb25zdCBuZXh0ID0gYXdhaXQgbS5pbml0KE9iamVjdC5hc3NpZ24oeyBjbGllbnQ6IHRoaXMgfSwgb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnJlZ2lzdGVySW5wdXQpKTtcbiAgICAgICAgICAgIHJldHVybiBbLi4ucHJldiwgbmV4dF07XG4gICAgICAgIH0sIFByb21pc2UucmVzb2x2ZShbXSkpO1xuICAgICAgICByZXR1cm4gWy4uLnByZWZpeCwgLi4uKGF3YWl0IHN0YWNrKV07XG4gICAgfVxuICAgIGdldCBtb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9kZTtcbiAgICB9XG4gICAgc2V0IG1vZGUobSkge1xuICAgICAgICB0aGlzLl9tb2RlID0gbTtcbiAgICAgICAgdGhpcy5sb2FkTW9kZUVudlZhcnMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSByZXNwb25zZSBmcm9tIElubmdlc3QsIHJlbGF5IHRoZSBlcnJvciB0byB0aGUgY2FsbGVyLlxuICAgICAqL1xuICAgIGFzeW5jIGdldFJlc3BvbnNlRXJyb3IocmVzcG9uc2UsIHJhd0JvZHksIGZvdW5kRXJyID0gXCJVbmtub3duIGVycm9yXCIpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9IGZvdW5kRXJyO1xuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlID09PSBcIlVua25vd24gZXJyb3JcIikge1xuICAgICAgICAgICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDQwMTpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJFdmVudCBrZXkgTm90IEZvdW5kXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDAwOlxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIkNhbm5vdCBwcm9jZXNzIGV2ZW50IHBheWxvYWRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0MDM6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IFwiRm9yYmlkZGVuXCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDA0OlxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIkV2ZW50IGtleSBub3QgZm91bmRcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0MDY6XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGAke0pTT04uc3RyaW5naWZ5KGF3YWl0IHJhd0JvZHkpfWA7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDA5OlxuICAgICAgICAgICAgICAgIGNhc2UgNDEyOlxuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIkV2ZW50IHRyYW5zZm9ybWF0aW9uIGZhaWxlZFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQxMzpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJFdmVudCBwYXlsb2FkIHRvbyBsYXJnZVwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDUwMDpcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0gXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBgJHtKU09OLnN0cmluZ2lmeShhd2FpdCByYXdCb2R5KX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3IoYElubmdlc3QgQVBJIEVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtlcnJvck1lc3NhZ2V9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgZXZlbnQga2V5IGZvciB0aGlzIGluc3RhbmNlIG9mIElubmdlc3QuIFRoaXMgaXMgdXNlZnVsIGlmIGZvciBzb21lXG4gICAgICogcmVhc29uIHRoZSBrZXkgaXMgbm90IGF2YWlsYWJsZSBhdCB0aW1lIG9mIGluc3RhbnRpYXRpb24gb3IgcHJlc2VudCBpbiB0aGVcbiAgICAgKiBgSU5OR0VTVF9FVkVOVF9LRVlgIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgICAqL1xuICAgIHNldEV2ZW50S2V5KFxuICAgIC8qKlxuICAgICAqIElubmdlc3QgZXZlbnQga2V5LCB1c2VkIHRvIHNlbmQgZXZlbnRzIHRvIElubmdlc3QgQ2xvdWQuIFVzZSB0aGlzIGlzIHlvdXJcbiAgICAgKiBrZXkgaXMgZm9yIHNvbWUgcmVhc29uIG5vdCBhdmFpbGFibGUgYXQgdGltZSBvZiBpbnN0YW50aWF0aW9uIG9yIHByZXNlbnRcbiAgICAgKiBpbiB0aGUgYElOTkdFU1RfRVZFTlRfS0VZYCBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICAgKi9cbiAgICBldmVudEtleSkge1xuICAgICAgICB0aGlzLmV2ZW50S2V5ID0gZXZlbnRLZXkgfHwgY29uc3RzX2pzXzEuZHVtbXlFdmVudEtleTtcbiAgICAgICAgdGhpcy5zZW5kRXZlbnRVcmwgPSBuZXcgVVJMKGBlLyR7dGhpcy5ldmVudEtleX1gLCB0aGlzLmV2ZW50QmFzZVVybCB8fCBjb25zdHNfanNfMS5kZWZhdWx0SW5uZ2VzdEV2ZW50QmFzZVVybCk7XG4gICAgfVxuICAgIGV2ZW50S2V5U2V0KCkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbih0aGlzLmV2ZW50S2V5KSAmJiB0aGlzLmV2ZW50S2V5ICE9PSBjb25zdHNfanNfMS5kdW1teUV2ZW50S2V5O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFWFBFUklNRU5UQUw6IFRoaXMgQVBJIGlzIG5vdCB5ZXQgc3RhYmxlIGFuZCBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmVcbiAgICAgKiB3aXRob3V0IGEgbWFqb3IgdmVyc2lvbiBidW1wLlxuICAgICAqXG4gICAgICogU2VuZCBhIFNpZ25hbCB0byBJbm5nZXN0LlxuICAgICAqL1xuICAgIGFzeW5jIHNlbmRTaWduYWwoeyBzaWduYWwsIGRhdGEsIGVudiwgfSkge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgKGVudiA/IHsgW2NvbnN0c19qc18xLmhlYWRlcktleXMuRW52aXJvbm1lbnRdOiBlbnYgfSA6IHt9KSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW5kU2lnbmFsKHsgc2lnbmFsLCBkYXRhLCBoZWFkZXJzIH0pO1xuICAgIH1cbiAgICBhc3luYyBfc2VuZFNpZ25hbCh7IHNpZ25hbCwgZGF0YSwgaGVhZGVycywgfSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuaW5uZ2VzdEFwaS5zZW5kU2lnbmFsKHsgc2lnbmFsLCBkYXRhIH0sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKSwgaGVhZGVycykpO1xuICAgICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHNlbmQgc2lnbmFsOiAkeygoX2EgPSByZXMuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lcnJvcikgfHwgXCJVbmtub3duIGVycm9yXCJ9YCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgb25lIG9yIG1hbnkgZXZlbnRzIHRvIElubmdlc3QuIFRha2VzIGFuIGVudGlyZSBwYXlsb2FkIChpbmNsdWRpbmdcbiAgICAgKiBuYW1lKSBhcyBlYWNoIGlucHV0LlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBhd2FpdCBpbm5nZXN0LnNlbmQoeyBuYW1lOiBcImFwcC91c2VyLmNyZWF0ZWRcIiwgZGF0YTogeyBpZDogMTIzIH0gfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBpZiB0aGUgZXZlbnQocykgd2VyZSBzZW50IHN1Y2Nlc3NmdWxseSxcbiAgICAgKiBlbHNlIHRocm93cyB3aXRoIGFuIGVycm9yIGV4cGxhaW5pbmcgd2hhdCB3ZW50IHdyb25nLlxuICAgICAqXG4gICAgICogSWYgeW91IHdpc2ggdG8gc2VuZCBhbiBldmVudCB3aXRoIGN1c3RvbSB0eXBlcyAoaS5lLiBvbmUgdGhhdCBoYXNuJ3QgYmVlblxuICAgICAqIGdlbmVyYXRlZCksIG1ha2Ugc3VyZSB0byBhZGQgaXQgd2hlbiBjcmVhdGluZyB5b3VyIElubmdlc3QgaW5zdGFuY2UsIGxpa2VcbiAgICAgKiBzbzpcbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogY29uc3QgaW5uZ2VzdCA9IG5ldyBJbm5nZXN0KHtcbiAgICAgKiAgIG5hbWU6IFwiTXkgQXBwXCIsXG4gICAgICogICBzY2hlbWFzOiBuZXcgRXZlbnRTY2hlbWFzKCkuZnJvbVJlY29yZDx7XG4gICAgICogICAgIFwibXkvZXZlbnRcIjoge1xuICAgICAqICAgICAgIG5hbWU6IFwibXkvZXZlbnRcIjtcbiAgICAgKiAgICAgICBkYXRhOiB7IGJhcjogc3RyaW5nIH07XG4gICAgICogICAgIH07XG4gICAgICogICB9PigpLFxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFzeW5jIHNlbmQocGF5bG9hZCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZW52KSA/IHsgW2NvbnN0c19qc18xLmhlYWRlcktleXMuRW52aXJvbm1lbnRdOiBvcHRpb25zLmVudiB9IDoge30pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmQoeyBwYXlsb2FkLCBoZWFkZXJzIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgZm9yIHNlbmRpbmcgYW4gZXZlbnQsIHVzZWQgdG8gYWxsb3cgSW5uZ2VzdCBpbnRlcm5hbHMgdG9cbiAgICAgKiBmdXJ0aGVyIGN1c3RvbWl6ZSB0aGUgcmVxdWVzdCBzZW50IHRvIGFuIElubmdlc3QgU2VydmVyLlxuICAgICAqL1xuICAgIGFzeW5jIF9zZW5kKHsgcGF5bG9hZCwgaGVhZGVycywgfSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IG5vd01pbGxpcyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgICAgICBsZXQgbWF4QXR0ZW1wdHMgPSA1O1xuICAgICAgICAvLyBBdHRlbXB0IHRvIHNldCB0aGUgZXZlbnQgSUQgc2VlZCBoZWFkZXIuIElmIGl0IGZhaWxzIHRoZW4gZGlzYWJsZSByZXRyaWVzXG4gICAgICAgIC8vIChidXQgd2Ugc3RpbGwgd2FudCB0byBzZW5kIHRoZSBldmVudCkuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlbnRyb3B5ID0gKDAsIGNyeXB0b19qc18xLmNyZWF0ZUVudHJvcHkpKDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJvcHlCYXNlNjQgPSBCdWZmZXIuZnJvbShlbnRyb3B5KS50b1N0cmluZyhcImJhc2U2NFwiKTtcbiAgICAgICAgICAgIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGhlYWRlcnMpLCB7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLkV2ZW50SWRTZWVkXTogYCR7bm93TWlsbGlzfSwke2VudHJvcHlCYXNlNjR9YCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IFwiRXZlbnQtc2VuZGluZyByZXRyaWVzIGRpc2FibGVkXCI7XG4gICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlICs9IGA6ICR7ZXJyLm1lc3NhZ2V9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcobWVzc2FnZSk7XG4gICAgICAgICAgICAvLyBEaXNhYmxlIHJldHJpZXMuXG4gICAgICAgICAgICBtYXhBdHRlbXB0cyA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaG9va3MgPSBhd2FpdCAoMCwgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5nZXRIb29rU3RhY2spKHRoaXMubWlkZGxld2FyZSwgXCJvblNlbmRFdmVudFwiLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0OiAocHJldiwgb3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldiksIG91dHB1dCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdHJhbnNmb3JtT3V0cHV0KHByZXYsIG91dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2LnJlc3VsdCksIG91dHB1dCA9PT0gbnVsbCB8fCBvdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG91dHB1dC5yZXN1bHQpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHBheWxvYWRzID0gQXJyYXkuaXNBcnJheShwYXlsb2FkKVxuICAgICAgICAgICAgPyBwYXlsb2FkXG4gICAgICAgICAgICA6IHBheWxvYWRcbiAgICAgICAgICAgICAgICA/IFtwYXlsb2FkXVxuICAgICAgICAgICAgICAgIDogW107XG4gICAgICAgIGNvbnN0IGlucHV0Q2hhbmdlcyA9IGF3YWl0ICgoX2EgPSBob29rcy50cmFuc2Zvcm1JbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaG9va3MsIHtcbiAgICAgICAgICAgIHBheWxvYWRzOiBbLi4ucGF5bG9hZHNdLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChpbnB1dENoYW5nZXMgPT09IG51bGwgfHwgaW5wdXRDaGFuZ2VzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dENoYW5nZXMucGF5bG9hZHMpIHtcbiAgICAgICAgICAgIHBheWxvYWRzID0gWy4uLmlucHV0Q2hhbmdlcy5wYXlsb2Fkc107XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgYWx3YXlzIGFkZCBcInRzXCIgYW5kIFwiZGF0YVwiIGZpZWxkcyB0byBldmVudHMuIFwidHNcIiBpcyBhdXRvLVxuICAgICAgICAvLyBmaWxsZWQgYnkgdGhlIGV2ZW50IHNlcnZlciBzbyBpcyBzYWZlLCBhbmQgYWRkaW5nIGhlcmUgZml4ZXMgTmV4dC5qc1xuICAgICAgICAvLyBzZXJ2ZXIgYWN0aW9uIGNhY2hlIGlzc3Vlcy5cbiAgICAgICAgcGF5bG9hZHMgPSBwYXlsb2Fkcy5tYXAoKHApID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHApLCB7IFxuICAgICAgICAgICAgICAgIC8vIEFsd2F5cyBnZW5lcmF0ZSBhbiBpZGVtcG90ZW5jeSBJRCBmb3IgYW4gZXZlbnQgZm9yIHJldHJpZXNcbiAgICAgICAgICAgICAgICBpZDogcC5pZCwgdHM6IHAudHMgfHwgbm93TWlsbGlzLCBcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgZGF0YTogcC5kYXRhIHx8IHt9IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYXBwbHlIb29rVG9PdXRwdXQgPSBhc3luYyAoYXJnKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCBob29rT3V0cHV0ID0gYXdhaXQgKChfYSA9IGhvb2tzLnRyYW5zZm9ybU91dHB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoaG9va3MsIGFyZykpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYXJnLnJlc3VsdCksIGhvb2tPdXRwdXQgPT09IG51bGwgfHwgaG9va091dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaG9va091dHB1dC5yZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSXQgY2FuIGJlIHZhbGlkIGZvciBhIHVzZXIgdG8gc2VuZCBhbiBlbXB0eSBsaXN0IG9mIGV2ZW50czsgaWYgdGhpc1xuICAgICAgICAgKiBoYXBwZW5zLCBzaG93IGEgd2FybmluZyB0aGF0IHRoaXMgbWF5IG5vdCBiZSBpbnRlbmRlZCwgYnV0IGRvbid0IHRocm93LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFwYXlsb2Fkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybigoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIndhcm5cIixcbiAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiYGlubmdlc3Quc2VuZCgpYCBjYWxsZWQgd2l0aCBubyBldmVudHNcIixcbiAgICAgICAgICAgICAgICByZWFzc3VyYW5jZTogXCJUaGlzIGlzIG5vdCBhbiBlcnJvciwgYnV0IHlvdSBtYXkgbm90IGhhdmUgaW50ZW5kZWQgdG8gZG8gdGhpcy5cIixcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW5jZXM6IFwiVGhlIHJldHVybmVkIHByb21pc2Ugd2lsbCByZXNvbHZlLCBidXQgbm8gZXZlbnRzIGhhdmUgYmVlbiBzZW50IHRvIElubmdlc3QuXCIsXG4gICAgICAgICAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgYXBwbHlIb29rVG9PdXRwdXQoeyByZXN1bHQ6IHsgaWRzOiBbXSB9IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdoZW4gc2VuZGluZyBldmVudHMsIGNoZWNrIGlmIHRoZSBkZXYgc2VydmVyIGlzIGF2YWlsYWJsZS4gIElmIHNvLCB1c2UgdGhlXG4gICAgICAgIC8vIGRldiBzZXJ2ZXIuXG4gICAgICAgIGxldCB1cmwgPSB0aGlzLnNlbmRFdmVudFVybC5ocmVmO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaW4gcHJvZCBtb2RlIGFuZCBrZXkgaXMgbm90IHByZXNlbnQsIGZhaWwgbm93LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMubW9kZS5pc0Nsb3VkICYmICF0aGlzLmV2ZW50S2V5U2V0KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiRmFpbGVkIHRvIHNlbmQgZXZlbnRcIixcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW5jZXM6IFwiWW91ciBldmVudCBvciBldmVudHMgd2VyZSBub3Qgc2VudCB0byBJbm5nZXN0LlwiLFxuICAgICAgICAgICAgICAgIHdoeTogXCJXZSBjb3VsZG4ndCBmaW5kIGFuIGV2ZW50IGtleSB0byB1c2UgdG8gc2VuZCBldmVudHMgdG8gSW5uZ2VzdC5cIixcbiAgICAgICAgICAgICAgICB0b0ZpeE5vdzogZXJyb3JzX2pzXzEuZml4RXZlbnRLZXlNaXNzaW5nU3RlcHMsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGRldiBtb2RlIGhhcyBiZWVuIGluZmVycmVkLCB0cnkgdG8gaGl0IHRoZSBkZXYgc2VydmVyIGZpcnN0IHRvIHNlZSBpZlxuICAgICAgICAgKiBpdCBleGlzdHMuIElmIGl0IGRvZXMsIHVzZSBpdCwgb3RoZXJ3aXNlIGZhbGwgYmFjayB0byB3aGF0ZXZlciBzZXJ2ZXIgd2VcbiAgICAgICAgICogaGF2ZSBjb25maWd1cmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgSU5OR0VTVF9CQVNFX1VSTGAgaXMgdXNlZCB0byBzZXQgYm90aCBkZXYgc2VydmVyIGFuZCBwcm9kIFVSTHMsIHNvIGlmIGFcbiAgICAgICAgICogdXNlciBoYXMgc2V0IHRoaXMgaXQgbWVhbnMgdGhleSBoYXZlIGFscmVhZHkgY2hvc2VuIGEgVVJMIHRvIGhpdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLm1vZGUuaXNEZXYgJiYgdGhpcy5tb2RlLmlzSW5mZXJyZWQgJiYgIXRoaXMuZXZlbnRCYXNlVXJsKSB7XG4gICAgICAgICAgICBjb25zdCBkZXZBdmFpbGFibGUgPSBhd2FpdCAoMCwgZGV2c2VydmVyX2pzXzEuZGV2U2VydmVyQXZhaWxhYmxlKShjb25zdHNfanNfMS5kZWZhdWx0RGV2U2VydmVySG9zdCwgdGhpcy5mZXRjaCk7XG4gICAgICAgICAgICBpZiAoZGV2QXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIGRldnNlcnZlcl9qc18xLmRldlNlcnZlclVybCkoY29uc3RzX2pzXzEuZGVmYXVsdERldlNlcnZlckhvc3QsIGBlLyR7dGhpcy5ldmVudEtleX1gKS5ocmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCAoMCwgcHJvbWlzZXNfanNfMS5yZXRyeVdpdGhCYWNrb2ZmKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmF3Qm9keTtcbiAgICAgICAgICAgIGxldCBib2R5O1xuICAgICAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBkbyBmYWxsYmFjayBhdXRoIGhlcmUgYmVjYXVzZSB0aGlzIHVzZXMgZXZlbnQga2V5cyBhbmRcbiAgICAgICAgICAgIC8vIG5vdCBzaWduaW5nIGtleXNcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5mZXRjaCh1cmwsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KShwYXlsb2FkcyksXG4gICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpLCBoZWFkZXJzKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByYXdCb2R5ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgICAgICAgIGJvZHkgPSBhd2FpdCB0eXBlc19qc18xLnNlbmRFdmVudFJlc3BvbnNlU2NoZW1hLnBhcnNlQXN5bmMocmF3Qm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgYXdhaXQgdGhpcy5nZXRSZXNwb25zZUVycm9yKHJlc3BvbnNlLCByYXdCb2R5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChib2R5LnN0YXR1cyAhPT0gMjAwIHx8IGJvZHkuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBhd2FpdCB0aGlzLmdldFJlc3BvbnNlRXJyb3IocmVzcG9uc2UsIHJhd0JvZHksIGJvZHkuZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1heEF0dGVtcHRzLFxuICAgICAgICAgICAgYmFzZURlbGF5OiAxMDAsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gYXdhaXQgYXBwbHlIb29rVG9PdXRwdXQoeyByZXN1bHQ6IHsgaWRzOiBib2R5LmlkcyB9IH0pO1xuICAgIH1cbiAgICBnZXQgZnVuY3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsRm5zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSdW50aW1lLW9ubHkgdmFsaWRhdGlvbi5cbiAgICAgKi9cbiAgICBzYW5pdGl6ZU9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdGlvbnMsIFwiZm5zXCIpKSB7XG4gICAgICAgICAgICAvLyB2MiAtPiB2MyBtaWdyYXRpb24gd2FybmluZ1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2NvbnN0c19qc18xLmxvZ1ByZWZpeH0gSW5uZ2VzdEZ1bmN0aW9uOiBcXGBmbnNcXGAgb3B0aW9uIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gdjM7IHVzZSBcXGBtaWRkbGV3YXJlXFxgIGluc3RlYWQuIFNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL3Nkay9taWdyYXRpb25gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIHYyIC0+IHYzIHJ1bnRpbWUgbWlncmF0b24gd2FybmluZ1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGAke2NvbnN0c19qc18xLmxvZ1ByZWZpeH0gSW5uZ2VzdEZ1bmN0aW9uOiBDcmVhdGluZyBhIGZ1bmN0aW9uIHdpdGggYSBzdHJpbmcgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gdjM7IHBhc3MgYW4gb2JqZWN0IGluc3RlYWQuIFNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL3Nkay9taWdyYXRpb25gKTtcbiAgICAgICAgICAgIHJldHVybiB7IGlkOiBvcHRpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnRpbWUtb25seSB2YWxpZGF0aW9uLlxuICAgICAqL1xuICAgIHNhbml0aXplVHJpZ2dlcnModHJpZ2dlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmlnZ2VycyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gdjIgLT4gdjMgbWlncmF0aW9uIHdhcm5pbmdcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjb25zdHNfanNfMS5sb2dQcmVmaXh9IElubmdlc3RGdW5jdGlvbjogQ3JlYXRpbmcgYSBmdW5jdGlvbiB3aXRoIGEgc3RyaW5nIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiB2MzsgcGFzcyBhbiBvYmplY3QgaW5zdGVhZC4gU2VlIGh0dHBzOi8vd3d3Lmlubmdlc3QuY29tL2RvY3Mvc2RrL21pZ3JhdGlvbmApO1xuICAgICAgICAgICAgcmV0dXJuIFt7IGV2ZW50OiB0cmlnZ2VycyB9XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodHJpZ2dlcnMpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RyaWdnZXJzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJpZ2dlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5Jbm5nZXN0ID0gSW5uZ2VzdDtcbi8qKlxuICogRGVmYXVsdCBtaWRkbGV3YXJlIHRoYXQgaXMgaW5jbHVkZWQgaW4gZXZlcnkgY2xpZW50LCBwbGFjZWQgYWZ0ZXIgdGhlIHVzZXInc1xuICogbWlkZGxld2FyZSBvbiB0aGUgY2xpZW50IGJ1dCBiZWZvcmUgZnVuY3Rpb24tbGV2ZWwgbWlkZGxld2FyZS5cbiAqXG4gKiBJdCBpcyBkZWZpbmVkIGhlcmUgdG8gZW5zdXJlIHRoYXQgY29tbWVudHMgYXJlIGluY2x1ZGVkIGluIHRoZSBnZW5lcmF0ZWQgVFNcbiAqIGRlZmluaXRpb25zLiBXaXRob3V0IHRoaXMsIHdlIGluZmVyIHRoZSBzdGFjayBvZiBidWlsdC1pbiBtaWRkbGV3YXJlIHdpdGhvdXRcbiAqIGNvbW1lbnRzLCBsb3NpbmcgYSBsb3Qgb2YgdmFsdWUuXG4gKlxuICogSWYgdGhpcyBpcyBtb3ZlZCwgcGxlYXNlIGVuc3VyZSB0aGF0IHVzaW5nIHRoaXMgcGFja2FnZSBpbiBhbm90aGVyIHByb2plY3RcbiAqIGNhbiBjb3JyZWN0bHkgYWNjZXNzIGNvbW1lbnRzIG9uIG11dGF0ZWQgaW5wdXQgYW5kIG91dHB1dC5cbiAqXG4gKiBUaGlzIHJldHVybiBwYXR0ZXJuIG1pbWljcyB0aGUgb3V0cHV0IG9mIGEgYHNhdGlzZmllc2Agc3VmZml4OyBpdCdzIHVzZWQgYXNcbiAqIHdlIHN1cHBvcnQgdmVyc2lvbnMgb2YgVHlwZVNjcmlwdCBwcmlvciB0byB0aGUgaW50cm9kdWN0aW9uIG9mIGBzYXRpc2ZpZXNgLlxuICovXG5leHBvcnRzLmJ1aWx0SW5NaWRkbGV3YXJlID0gKChtKSA9PiBtKShbXG4gICAgbmV3IElubmdlc3RNaWRkbGV3YXJlX2pzXzEuSW5uZ2VzdE1pZGRsZXdhcmUoe1xuICAgICAgICBuYW1lOiBcIklubmdlc3Q6IExvZ2dlclwiLFxuICAgICAgICBpbml0KHsgY2xpZW50IH0pIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb25GdW5jdGlvblJ1bihhcmcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBjdHggfSA9IGFyZztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5JRDogY3R4LnJ1bklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lOiBjdHguZXZlbnQubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogYXJnLmZuLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGxldCBwcm92aWRlZExvZ2dlciA9IGNsaWVudFtcImxvZ2dlclwiXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY3JlYXRlIGEgY2hpbGQgbG9nZ2VyIGlmIHRoZSBwcm92aWRlZCBsb2dnZXIgaGFzIGNoaWxkIGxvZ2dlciBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwiY2hpbGRcIiBpbiBwcm92aWRlZExvZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVkTG9nZ2VyID0gcHJvdmlkZWRMb2dnZXIuY2hpbGQobWV0YWRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2ZhaWxlZCB0byBjcmVhdGUgXCJjaGlsZExvZ2dlclwiIHdpdGggZXJyb3I6ICcsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZ2dlciA9IG5ldyBsb2dnZXJfanNfMS5Qcm94eUxvZ2dlcihwcm92aWRlZExvZ2dlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1JbnB1dCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIHBhc3NlZCBpbiBsb2dnZXIgZnJvbSB0aGUgdXNlci5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIERlZmF1bHRzIHRvIGEgY29uc29sZSBsb2dnZXIgaWYgbm90IHByb3ZpZGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXI6IGxvZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZm9yZUV4ZWN1dGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZW5hYmxlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtT3V0cHV0KHsgcmVzdWx0OiB7IGVycm9yIH0gfSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhc3luYyBiZWZvcmVSZXNwb25zZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBsb2dnZXIuZmx1c2goKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfSksXG5dKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmdlc3QuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/Inngest.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestCommHandler.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/components/InngestCommHandler.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _RequestSignature_instances, _RequestSignature_verifySignature;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestCommHandler = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst ServerTiming_js_1 = __webpack_require__(/*! ../helpers/ServerTiming.js */ \"(rsc)/./node_modules/inngest/helpers/ServerTiming.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst enum_js_1 = __webpack_require__(/*! ../helpers/enum.js */ \"(rsc)/./node_modules/inngest/helpers/enum.js\");\nconst env_js_1 = __webpack_require__(/*! ../helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst net_js_1 = __webpack_require__(/*! ../helpers/net.js */ \"(rsc)/./node_modules/inngest/helpers/net.js\");\nconst promises_js_1 = __webpack_require__(/*! ../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst stream_js_1 = __webpack_require__(/*! ../helpers/stream.js */ \"(rsc)/./node_modules/inngest/helpers/stream.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst version_js_1 = __webpack_require__(/*! ../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\n/**\n * A schema for the response from Inngest when registering.\n */\nconst registerResSchema = zod_1.z.object({\n    status: zod_1.z.number().default(200),\n    skipped: zod_1.z.boolean().optional().default(false),\n    modified: zod_1.z.boolean().optional().default(false),\n    error: zod_1.z.string().default(\"Successfully registered\"),\n});\n/**\n * `InngestCommHandler` is a class for handling incoming requests from Inngest (or\n * Inngest's tooling such as the dev server or CLI) and taking appropriate\n * action for any served functions.\n *\n * All handlers (Next.js, RedwoodJS, Remix, Deno Fresh, etc.) are created using\n * this class; the exposed `serve` function will - most commonly - create an\n * instance of `InngestCommHandler` and then return `instance.createHandler()`.\n *\n * See individual parameter details for more information, or see the\n * source code for an existing handler, e.g.\n * {@link https://github.com/inngest/inngest-js/blob/main/src/next.ts}\n *\n * @example\n * ```\n * // my-custom-handler.ts\n * import {\n *   InngestCommHandler,\n *   type ServeHandlerOptions,\n * } from \"./components/InngestCommHandler\";\n *\n * export const serve = (options: ServeHandlerOptions) => {\n *   const handler = new InngestCommHandler({\n *     frameworkName: \"my-custom-handler\",\n *     ...options,\n *     handler: (req: Request) => {\n *       return {\n *         body: () => req.json(),\n *         headers: (key) => req.headers.get(key),\n *         method: () => req.method,\n *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n *         transformResponse: ({ body, status, headers }) => {\n *           return new Response(body, { status, headers });\n *         },\n *       };\n *     },\n *   });\n *\n *   return handler.createHandler();\n * };\n * ```\n *\n * @public\n */\nclass InngestCommHandler {\n    constructor(options) {\n        var _a;\n        /**\n         * A private collection of functions that are being served. This map is used\n         * to find and register functions when interacting with Inngest Cloud.\n         */\n        this.fns = {};\n        this.env = (0, env_js_1.allProcessEnv)();\n        // Set input options directly so we can reference them later\n        this._options = options;\n        /**\n         * v2 -> v3 migration error.\n         *\n         * If a serve handler is passed a client as the first argument, it'll be\n         * spread in to these options. We should be able to detect this by picking\n         * up a unique property on the object.\n         */\n        if (Object.prototype.hasOwnProperty.call(options, \"eventKey\")) {\n            throw new Error(`${consts_js_1.logPrefix} You've passed an Inngest client as the first argument to your serve handler. This is no longer supported in v3; please pass the Inngest client as the \\`client\\` property of an options object instead. See https://www.inngest.com/docs/sdk/migration`);\n        }\n        this.frameworkName = options.frameworkName;\n        this.client = options.client;\n        if (options.id) {\n            console.warn(`${consts_js_1.logPrefix} The \\`id\\` serve option is deprecated and will be removed in v4`);\n        }\n        this.id = options.id || this.client.id;\n        this.handler = options.handler;\n        /**\n         * Provide a hidden option to allow expired signatures to be accepted during\n         * testing.\n         */\n        this.allowExpiredSignatures = Boolean(\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, prefer-rest-params\n        (_a = arguments[\"0\"]) === null || _a === void 0 ? void 0 : _a.__testingAllowExpiredSignatures);\n        // Ensure we filter any undefined functions in case of missing imports.\n        this.rawFns = options.functions.filter(Boolean);\n        if (this.rawFns.length !== options.functions.length) {\n            // TODO PrettyError\n            console.warn(`Some functions passed to serve() are undefined and misconfigured.  Please check your imports.`);\n        }\n        this.fns = this.rawFns.reduce((acc, fn) => {\n            const configs = fn[\"getConfig\"]({\n                baseUrl: new URL(\"https://example.com\"),\n                appPrefix: this.id,\n            });\n            const fns = configs.reduce((acc, { id }, index) => {\n                return Object.assign(Object.assign({}, acc), { [id]: { fn, onFailure: Boolean(index) } });\n            }, {});\n            configs.forEach(({ id }) => {\n                if (acc[id]) {\n                    // TODO PrettyError\n                    throw new Error(`Duplicate function ID \"${id}\"; please change a function's name or provide an explicit ID to avoid conflicts.`);\n                }\n            });\n            return Object.assign(Object.assign({}, acc), fns);\n        }, {});\n        this.inngestRegisterUrl = new URL(\"/fn/register\", this.apiBaseUrl);\n        this.signingKey = options.signingKey;\n        this.signingKeyFallback = options.signingKeyFallback;\n        this._serveHost = options.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];\n        this._servePath = options.servePath || this.env[consts_js_1.envKeys.InngestServePath];\n        this.skipSignatureValidation = options.skipSignatureValidation || false;\n        const defaultLogLevel = \"info\";\n        this.logLevel = zod_1.z\n            .enum(types_js_1.logLevels)\n            .default(defaultLogLevel)\n            .catch((ctx) => {\n            this.log(\"warn\", `Unknown log level passed: ${String(ctx.input)}; defaulting to ${defaultLogLevel}`);\n            return defaultLogLevel;\n        })\n            .parse(options.logLevel || this.env[consts_js_1.envKeys.InngestLogLevel]);\n        if (this.logLevel === \"debug\") {\n            /**\n             * `debug` is an old library; sometimes its runtime detection doesn't work\n             * for newer pairings of framework/runtime.\n             *\n             * One silly symptom of this is that `Debug()` returns an anonymous\n             * function with no extra properties instead of a `Debugger` instance if\n             * the wrong code is consumed following a bad detection. This results in\n             * the following `.enable()` call failing, so we just try carefully to\n             * enable it here.\n             */\n            if (debug_1.default.enable && typeof debug_1.default.enable === \"function\") {\n                debug_1.default.enable(`${consts_js_1.debugPrefix}:*`);\n            }\n        }\n        const defaultStreamingOption = false;\n        this.streaming = zod_1.z\n            .union([zod_1.z.enum([\"allow\", \"force\"]), zod_1.z.literal(false)])\n            .default(defaultStreamingOption)\n            .catch((ctx) => {\n            this.log(\"warn\", `Unknown streaming option passed: ${String(ctx.input)}; defaulting to ${String(defaultStreamingOption)}`);\n            return defaultStreamingOption;\n        })\n            .parse(options.streaming || this.env[consts_js_1.envKeys.InngestStreaming]);\n        this.fetch = options.fetch ? (0, env_js_1.getFetch)(options.fetch) : this.client[\"fetch\"];\n    }\n    /**\n     * Get the API base URL for the Inngest API.\n     *\n     * This is a getter to encourage checking the environment for the API base URL\n     * each time it's accessed, as it may change during execution.\n     */\n    get apiBaseUrl() {\n        return (this._options.baseUrl ||\n            this.env[consts_js_1.envKeys.InngestApiBaseUrl] ||\n            this.env[consts_js_1.envKeys.InngestBaseUrl] ||\n            this.client.apiBaseUrl ||\n            consts_js_1.defaultInngestApiBaseUrl);\n    }\n    /**\n     * Get the event API base URL for the Inngest API.\n     *\n     * This is a getter to encourage checking the environment for the event API\n     * base URL each time it's accessed, as it may change during execution.\n     */\n    get eventApiBaseUrl() {\n        return (this._options.baseUrl ||\n            this.env[consts_js_1.envKeys.InngestEventApiBaseUrl] ||\n            this.env[consts_js_1.envKeys.InngestBaseUrl] ||\n            this.client.eventBaseUrl ||\n            consts_js_1.defaultInngestEventBaseUrl);\n    }\n    /**\n     * The host used to access the Inngest serve endpoint, e.g.:\n     *\n     *     \"https://myapp.com\"\n     *\n     * By default, the library will try to infer this using request details such\n     * as the \"Host\" header and request path, but sometimes this isn't possible\n     * (e.g. when running in a more controlled environments such as AWS Lambda or\n     * when dealing with proxies/redirects).\n     *\n     * Provide the custom hostname here to ensure that the path is reported\n     * correctly when registering functions with Inngest.\n     *\n     * To also provide a custom path, use `servePath`.\n     */\n    get serveHost() {\n        return this._serveHost || this.env[consts_js_1.envKeys.InngestServeHost];\n    }\n    /**\n     * The path to the Inngest serve endpoint. e.g.:\n     *\n     *     \"/some/long/path/to/inngest/endpoint\"\n     *\n     * By default, the library will try to infer this using request details such\n     * as the \"Host\" header and request path, but sometimes this isn't possible\n     * (e.g. when running in a more controlled environments such as AWS Lambda or\n     * when dealing with proxies/redirects).\n     *\n     * Provide the custom path (excluding the hostname) here to ensure that the\n     * path is reported correctly when registering functions with Inngest.\n     *\n     * To also provide a custom hostname, use `serveHost`.\n     *\n     * This is a getter to encourage checking the environment for the serve path\n     * each time it's accessed, as it may change during execution.\n     */\n    get servePath() {\n        return this._servePath || this.env[consts_js_1.envKeys.InngestServePath];\n    }\n    get hashedEventKey() {\n        if (!this.client[\"eventKey\"] || this.client[\"eventKey\"] === consts_js_1.dummyEventKey) {\n            return undefined;\n        }\n        return (0, strings_js_1.hashEventKey)(this.client[\"eventKey\"]);\n    }\n    // hashedSigningKey creates a sha256 checksum of the signing key with the\n    // same signing key prefix.\n    get hashedSigningKey() {\n        if (!this.signingKey) {\n            return undefined;\n        }\n        return (0, strings_js_1.hashSigningKey)(this.signingKey);\n    }\n    get hashedSigningKeyFallback() {\n        if (!this.signingKeyFallback) {\n            return undefined;\n        }\n        return (0, strings_js_1.hashSigningKey)(this.signingKeyFallback);\n    }\n    /**\n     * Returns a `boolean` representing whether this handler will stream responses\n     * or not. Takes into account the user's preference and the platform's\n     * capabilities.\n     */\n    async shouldStream(actions) {\n        const rawProbe = await actions.queryStringWithDefaults(\"testing for probe\", consts_js_1.queryKeys.Probe);\n        if (rawProbe !== undefined) {\n            return false;\n        }\n        // We must be able to stream responses to continue.\n        if (!actions.transformStreamingResponse) {\n            return false;\n        }\n        // If the user has forced streaming, we should always stream.\n        if (this.streaming === \"force\") {\n            return true;\n        }\n        // If the user has allowed streaming, we should stream if the platform\n        // supports it.\n        return (this.streaming === \"allow\" &&\n            (0, env_js_1.platformSupportsStreaming)(this.frameworkName, this.env));\n    }\n    /**\n     * `createHandler` should be used to return a type-equivalent version of the\n     * `handler` specified during instantiation.\n     *\n     * @example\n     * ```\n     * // my-custom-handler.ts\n     * import {\n     *   InngestCommHandler,\n     *   type ServeHandlerOptions,\n     * } from \"./components/InngestCommHandler\";\n     *\n     * export const serve = (options: ServeHandlerOptions) => {\n     *   const handler = new InngestCommHandler({\n     *     frameworkName: \"my-custom-handler\",\n     *     ...options,\n     *     handler: (req: Request) => {\n     *       return {\n     *         body: () => req.json(),\n     *         headers: (key) => req.headers.get(key),\n     *         method: () => req.method,\n     *         url: () => new URL(req.url, `https://${req.headers.get(\"host\") || \"\"}`),\n     *         transformResponse: ({ body, status, headers }) => {\n     *           return new Response(body, { status, headers });\n     *         },\n     *       };\n     *     },\n     *   });\n     *\n     *   return handler.createHandler();\n     * };\n     * ```\n     */\n    createHandler() {\n        const handler = async (...args) => {\n            var _a, _b;\n            const timer = new ServerTiming_js_1.ServerTiming();\n            /**\n             * Used for testing, allow setting action overrides externally when\n             * calling the handler. Always search the final argument.\n             */\n            const lastArg = args[args.length - 1];\n            const actionOverrides = typeof lastArg === \"object\" &&\n                lastArg !== null &&\n                \"actionOverrides\" in lastArg &&\n                typeof lastArg[\"actionOverrides\"] === \"object\" &&\n                lastArg[\"actionOverrides\"] !== null\n                ? lastArg[\"actionOverrides\"]\n                : {};\n            /**\n             * We purposefully `await` the handler, as it could be either sync or\n             * async.\n             */\n            const rawActions = Object.assign(Object.assign({}, (await timer\n                .wrap(\"handler\", () => this.handler(...args))\n                .catch((0, errors_js_1.rethrowError)(\"Serve handler failed to run\")))), actionOverrides);\n            /**\n             * Map over every `action` in `rawActions` and create a new `actions`\n             * object where each function is safely promisified with each access\n             * requiring a reason.\n             *\n             * This helps us provide high quality errors about what's going wrong for\n             * each access without having to wrap every access in a try/catch.\n             */\n            const promisifiedActions = Object.entries(rawActions).reduce((acc, [key, value]) => {\n                if (typeof value !== \"function\") {\n                    return acc;\n                }\n                return Object.assign(Object.assign({}, acc), { [key]: (reason, ...args) => {\n                        const errMessage = [\n                            `Failed calling \\`${key}\\` from serve handler`,\n                            reason,\n                        ]\n                            .filter(Boolean)\n                            .join(\" when \");\n                        const fn = () => value(...args);\n                        return (0, promises_js_1.runAsPromise)(fn)\n                            .catch((0, errors_js_1.rethrowError)(errMessage))\n                            .catch((err) => {\n                            this.log(\"error\", err);\n                            throw err;\n                        });\n                    } });\n            }, {});\n            /**\n             * Mapped promisified handlers from userland `serve()` function mixed in\n             * with some helpers.\n             */\n            const actions = Object.assign(Object.assign(Object.assign({}, promisifiedActions), { queryStringWithDefaults: async (reason, key) => {\n                    var _a;\n                    const url = await actions.url(reason);\n                    const ret = (await ((_a = actions.queryString) === null || _a === void 0 ? void 0 : _a.call(actions, reason, key, url))) ||\n                        url.searchParams.get(key) ||\n                        undefined;\n                    return ret;\n                } }), actionOverrides);\n            const [env, expectedServerKind] = await Promise.all([\n                (_a = actions.env) === null || _a === void 0 ? void 0 : _a.call(actions, \"starting to handle request\"),\n                actions.headers(\"checking expected server kind\", consts_js_1.headerKeys.InngestServerKind),\n            ]);\n            // Always make sure to merge whatever env we've been given with\n            // `process.env`; some platforms may not provide all the necessary\n            // environment variables or may use two sources.\n            this.env = Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), env);\n            const getInngestHeaders = () => (0, env_js_1.inngestHeaders)({\n                env: this.env,\n                framework: this.frameworkName,\n                client: this.client,\n                expectedServerKind: expectedServerKind || undefined,\n                extras: {\n                    \"Server-Timing\": timer.getHeader(),\n                },\n            });\n            const assumedMode = (0, env_js_1.getMode)({ env: this.env, client: this.client });\n            if (assumedMode.isExplicit) {\n                this._mode = assumedMode;\n            }\n            else {\n                const serveIsProd = await ((_b = actions.isProduction) === null || _b === void 0 ? void 0 : _b.call(actions, \"starting to handle request\"));\n                if (typeof serveIsProd === \"boolean\") {\n                    this._mode = new env_js_1.Mode({\n                        type: serveIsProd ? \"cloud\" : \"dev\",\n                        isExplicit: false,\n                    });\n                }\n                else {\n                    this._mode = assumedMode;\n                }\n            }\n            this.upsertKeysFromEnv();\n            const methodP = actions.method(\"starting to handle request\");\n            const headerPromises = [\n                consts_js_1.headerKeys.TraceParent,\n                consts_js_1.headerKeys.TraceState,\n            ].map(async (header) => {\n                const value = await actions.headers(`fetching ${header} for forwarding`, header);\n                return { header, value };\n            });\n            const contentLength = await actions\n                .headers(\"checking signature for request\", consts_js_1.headerKeys.ContentLength)\n                .then((value) => {\n                if (!value) {\n                    return undefined;\n                }\n                return parseInt(value, 10);\n            });\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const [signature, method, body] = await Promise.all([\n                actions\n                    .headers(\"checking signature for request\", consts_js_1.headerKeys.Signature)\n                    .then((headerSignature) => {\n                    return headerSignature !== null && headerSignature !== void 0 ? headerSignature : undefined;\n                }),\n                methodP,\n                methodP.then((method) => {\n                    if (method === \"POST\" || method === \"PUT\") {\n                        if (!contentLength) {\n                            // Return empty string because req.json() will throw an error.\n                            return \"\";\n                        }\n                        return actions.body(`checking body for request signing as method is ${method}`);\n                    }\n                    return \"\";\n                }),\n            ]);\n            const signatureValidation = this.validateSignature(signature, body);\n            const headersToForwardP = Promise.all(headerPromises).then((fetchedHeaders) => {\n                return fetchedHeaders.reduce((acc, { header, value }) => {\n                    if (value) {\n                        acc[header] = value;\n                    }\n                    return acc;\n                }, {});\n            });\n            const actionRes = timer.wrap(\"action\", () => this.handleAction({\n                actions,\n                timer,\n                getInngestHeaders,\n                reqArgs: args,\n                signatureValidation,\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                body,\n                method,\n                headers: headersToForwardP,\n            }));\n            /**\n             * Prepares an action response by merging returned data to provide\n             * trailing information such as `Server-Timing` headers.\n             *\n             * It should always prioritize the headers returned by the action, as they\n             * may contain important information such as `Content-Type`.\n             */\n            const prepareActionRes = async (res) => {\n                var _a;\n                const headers = Object.assign(Object.assign(Object.assign(Object.assign({}, getInngestHeaders()), (await headersToForwardP)), res.headers), (res.version === null\n                    ? {}\n                    : {\n                        [consts_js_1.headerKeys.RequestVersion]: ((_a = res.version) !== null && _a !== void 0 ? _a : InngestExecution_js_1.PREFERRED_EXECUTION_VERSION).toString(),\n                    }));\n                let signature;\n                try {\n                    signature = await signatureValidation.then((result) => {\n                        if (!result.success || !result.keyUsed) {\n                            return undefined;\n                        }\n                        return this.getResponseSignature(result.keyUsed, res.body);\n                    });\n                }\n                catch (err) {\n                    // If we fail to sign, retun a 500 with the error.\n                    return Object.assign(Object.assign({}, res), { headers, body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(err)), status: 500 });\n                }\n                if (signature) {\n                    headers[consts_js_1.headerKeys.Signature] = signature;\n                }\n                return Object.assign(Object.assign({}, res), { headers });\n            };\n            if (await this.shouldStream(actions)) {\n                const method = await actions.method(\"starting streaming response\");\n                if (method === \"POST\") {\n                    const { stream, finalize } = await (0, stream_js_1.createStream)();\n                    /**\n                     * Errors are handled by `handleAction` here to ensure that an\n                     * appropriate response is always given.\n                     */\n                    void actionRes.then((res) => {\n                        return finalize(prepareActionRes(res));\n                    });\n                    return timer.wrap(\"res\", () => {\n                        var _a;\n                        return (_a = actions.transformStreamingResponse) === null || _a === void 0 ? void 0 : _a.call(actions, \"starting streaming response\", {\n                            status: 201,\n                            headers: getInngestHeaders(),\n                            body: stream,\n                            version: null,\n                        });\n                    });\n                }\n            }\n            return timer.wrap(\"res\", async () => {\n                return actionRes.then(prepareActionRes).then((actionRes) => {\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                    return actions.transformResponse(\"sending back response\", actionRes);\n                });\n            });\n        };\n        /**\n         * Some platforms check (at runtime) the length of the function being used\n         * to handle an endpoint. If this is a variadic function, it will fail that\n         * check.\n         *\n         * Therefore, we expect the arguments accepted to be the same length as the\n         * `handler` function passed internally.\n         *\n         * We also set a name to avoid a common useless name in tracing such as\n         * `\"anonymous\"` or `\"bound function\"`.\n         *\n         * https://github.com/getsentry/sentry-javascript/issues/3284\n         */\n        Object.defineProperties(handler, {\n            name: {\n                value: \"InngestHandler\",\n            },\n            length: {\n                value: this.handler.length,\n            },\n        });\n        return handler;\n    }\n    get mode() {\n        return this._mode;\n    }\n    set mode(m) {\n        this._mode = m;\n        if (m) {\n            this.client[\"mode\"] = m;\n        }\n    }\n    /**\n     * Given a set of functions to check if an action is available from the\n     * instance's handler, enact any action that is found.\n     *\n     * This method can fetch varying payloads of data, but ultimately is the place\n     * where _decisions_ are made regarding functionality.\n     *\n     * For example, if we find that we should be viewing the UI, this function\n     * will decide whether the UI should be visible based on the payload it has\n     * found (e.g. env vars, options, etc).\n     */\n    async handleAction({ actions, timer, getInngestHeaders, reqArgs, signatureValidation, body, method, headers, }) {\n        var _a;\n        // This is when the request body is completely missing; it does not\n        // include an empty body. This commonly happens when the HTTP framework\n        // doesn't have body parsing middleware.\n        const isMissingBody = body === undefined;\n        try {\n            let url = await actions.url(\"starting to handle request\");\n            if (method === \"POST\") {\n                if (isMissingBody) {\n                    this.log(\"error\", \"Missing body when executing, possibly due to missing request body middleware\");\n                    return {\n                        status: 500,\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                        },\n                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(\"Missing request body when executing, possibly due to missing request body middleware\"))),\n                        version: undefined,\n                    };\n                }\n                const validationResult = await signatureValidation;\n                if (!validationResult.success) {\n                    return {\n                        status: 401,\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                        },\n                        body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(validationResult.err)),\n                        version: undefined,\n                    };\n                }\n                const rawProbe = await actions.queryStringWithDefaults(\"testing for probe\", consts_js_1.queryKeys.Probe);\n                if (rawProbe) {\n                    const probe = (0, enum_js_1.enumFromValue)(consts_js_1.probe, rawProbe);\n                    if (!probe) {\n                        // If we're here, we've received a probe that we don't recognize.\n                        // Fail.\n                        return {\n                            status: 400,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(`Unknown probe \"${rawProbe}\"`))),\n                            version: undefined,\n                        };\n                    }\n                    // Provide actions for every probe available.\n                    const probeActions = {\n                        [consts_js_1.probe.Trust]: () => ({\n                            status: 200,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: \"\",\n                            version: undefined,\n                        }),\n                    };\n                    return probeActions[probe]();\n                }\n                const fnId = await actions.queryStringWithDefaults(\"processing run request\", consts_js_1.queryKeys.FnId);\n                if (!fnId) {\n                    // TODO PrettyError\n                    throw new Error(\"No function ID found in request\");\n                }\n                const stepId = (await actions.queryStringWithDefaults(\"processing run request\", consts_js_1.queryKeys.StepId)) || null;\n                const { version, result } = this.runStep({\n                    functionId: fnId,\n                    data: body,\n                    stepId,\n                    timer,\n                    reqArgs,\n                    headers: await headers,\n                });\n                const stepOutput = await result;\n                /**\n                 * Functions can return `undefined`, but we'll always convert this to\n                 * `null`, as this is appropriately serializable by JSON.\n                 */\n                const opDataUndefinedToNull = (op) => {\n                    op.data = (0, functions_js_1.undefinedToNull)(op.data);\n                    return op;\n                };\n                const resultHandlers = {\n                    \"function-rejected\": (result) => {\n                        return {\n                            status: result.retriable ? 500 : 400,\n                            headers: Object.assign({ \"Content-Type\": \"application/json\", [consts_js_1.headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\" }, (typeof result.retriable === \"string\"\n                                ? { [consts_js_1.headerKeys.RetryAfter]: result.retriable }\n                                : {})),\n                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.error)),\n                            version,\n                        };\n                    },\n                    \"function-resolved\": (result) => {\n                        return {\n                            status: 200,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)((0, functions_js_1.undefinedToNull)(result.data)),\n                            version,\n                        };\n                    },\n                    \"step-not-found\": (result) => {\n                        return {\n                            status: 500,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                                [consts_js_1.headerKeys.NoRetry]: \"false\",\n                            },\n                            body: (0, strings_js_1.stringify)({\n                                error: `Could not find step \"${result.step.displayName || result.step.id}\" to run; timed out`,\n                            }),\n                            version,\n                        };\n                    },\n                    \"step-ran\": (result) => {\n                        const step = opDataUndefinedToNull(result.step);\n                        return {\n                            status: 206,\n                            headers: Object.assign({ \"Content-Type\": \"application/json\" }, (typeof result.retriable !== \"undefined\"\n                                ? Object.assign({ [consts_js_1.headerKeys.NoRetry]: result.retriable ? \"false\" : \"true\" }, (typeof result.retriable === \"string\"\n                                    ? { [consts_js_1.headerKeys.RetryAfter]: result.retriable }\n                                    : {})) : {})),\n                            body: (0, strings_js_1.stringify)([step]),\n                            version,\n                        };\n                    },\n                    \"steps-found\": (result) => {\n                        const steps = result.steps.map(opDataUndefinedToNull);\n                        return {\n                            status: 206,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)(steps),\n                            version,\n                        };\n                    },\n                };\n                const handler = resultHandlers[stepOutput.type];\n                try {\n                    return await handler(stepOutput);\n                }\n                catch (err) {\n                    this.log(\"error\", \"Error handling execution result\", err);\n                    throw err;\n                }\n            }\n            // TODO: This feels hacky, so we should probably make it not hacky.\n            const env = (_a = getInngestHeaders()[consts_js_1.headerKeys.Environment]) !== null && _a !== void 0 ? _a : null;\n            if (method === \"GET\") {\n                return {\n                    status: 200,\n                    body: (0, strings_js_1.stringify)(await this.introspectionBody({\n                        actions,\n                        env,\n                        signatureValidation,\n                        url,\n                    })),\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    version: undefined,\n                };\n            }\n            if (method === \"PUT\") {\n                const [deployId, inBandSyncRequested] = await Promise.all([\n                    actions\n                        .queryStringWithDefaults(\"processing deployment request\", consts_js_1.queryKeys.DeployId)\n                        .then((deployId) => {\n                        return deployId === \"undefined\" ? undefined : deployId;\n                    }),\n                    Promise.resolve((0, env_js_1.parseAsBoolean)(this.env[consts_js_1.envKeys.InngestAllowInBandSync]))\n                        .then((allowInBandSync) => {\n                        if (allowInBandSync !== undefined && !allowInBandSync) {\n                            return consts_js_1.syncKind.OutOfBand;\n                        }\n                        return actions.headers(\"processing deployment request\", consts_js_1.headerKeys.InngestSyncKind);\n                    })\n                        .then((kind) => {\n                        return kind === consts_js_1.syncKind.InBand;\n                    }),\n                ]);\n                if (inBandSyncRequested) {\n                    if (isMissingBody) {\n                        this.log(\"error\", \"Missing body when syncing, possibly due to missing request body middleware\");\n                        return {\n                            status: 500,\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            body: (0, strings_js_1.stringify)((0, errors_js_1.serializeError)(new Error(\"Missing request body when syncing, possibly due to missing request body middleware\"))),\n                            version: undefined,\n                        };\n                    }\n                    // Validation can be successful if we're in dev mode and did not\n                    // actually validate a key. In this case, also check that we did indeed\n                    // use a particular key to validate.\n                    const sigCheck = await signatureValidation;\n                    if (!sigCheck.success) {\n                        return {\n                            status: 401,\n                            body: (0, strings_js_1.stringify)({\n                                code: \"sig_verification_failed\",\n                            }),\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            version: undefined,\n                        };\n                    }\n                    const res = types_js_1.inBandSyncRequestBodySchema.safeParse(body);\n                    if (!res.success) {\n                        return {\n                            status: 400,\n                            body: (0, strings_js_1.stringify)({\n                                code: \"invalid_request\",\n                                message: res.error.message,\n                            }),\n                            headers: {\n                                \"Content-Type\": \"application/json\",\n                            },\n                            version: undefined,\n                        };\n                    }\n                    // We can trust the URL here because it's coming from\n                    // signature-verified request.\n                    url = this.reqUrl(new URL(res.data.url));\n                    // This should be an in-band sync\n                    const respBody = await this.inBandRegisterBody({\n                        actions,\n                        deployId,\n                        env,\n                        signatureValidation,\n                        url,\n                    });\n                    return {\n                        status: 200,\n                        body: (0, strings_js_1.stringify)(respBody),\n                        headers: {\n                            \"Content-Type\": \"application/json\",\n                            [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.InBand,\n                        },\n                        version: undefined,\n                    };\n                }\n                // If we're here, this is a legacy out-of-band sync\n                const { status, message, modified } = await this.register(this.reqUrl(url), deployId, getInngestHeaders);\n                return {\n                    status,\n                    body: (0, strings_js_1.stringify)({ message, modified }),\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                        [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand,\n                    },\n                    version: undefined,\n                };\n            }\n        }\n        catch (err) {\n            return {\n                status: 500,\n                body: (0, strings_js_1.stringify)(Object.assign({ type: \"internal\" }, (0, errors_js_1.serializeError)(err))),\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                },\n                version: undefined,\n            };\n        }\n        return {\n            status: 405,\n            body: JSON.stringify({\n                message: \"No action found; request was likely not POST, PUT, or GET\",\n                mode: this._mode,\n            }),\n            headers: {},\n            version: undefined,\n        };\n    }\n    runStep({ functionId, stepId, data, timer, reqArgs, headers, }) {\n        var _a, _b;\n        const fn = this.fns[functionId];\n        if (!fn) {\n            // TODO PrettyError\n            throw new Error(`Could not find function with ID \"${functionId}\"`);\n        }\n        const immediateFnData = (0, functions_js_1.parseFnData)(data);\n        let { version } = immediateFnData;\n        // Handle opting in to optimized parallelism in v3.\n        if (version === InngestExecution_js_1.ExecutionVersion.V1 &&\n            ((_b = (_a = fn.fn)[\"shouldOptimizeParallelism\"]) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n            version = InngestExecution_js_1.ExecutionVersion.V2;\n        }\n        const result = (0, promises_js_1.runAsPromise)(async () => {\n            const anyFnData = await (0, functions_js_1.fetchAllFnData)({\n                data: immediateFnData,\n                api: this.client[\"inngestApi\"],\n                version,\n            });\n            if (!anyFnData.ok) {\n                throw new Error(anyFnData.error);\n            }\n            const executionStarters = ((s) => s)({\n                [InngestExecution_js_1.ExecutionVersion.V0]: ({ event, events, steps, ctx, version }) => {\n                    var _a, _b, _c;\n                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, data]) => {\n                        return Object.assign(Object.assign({}, acc), { \n                            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                            [id]: { id, data } });\n                    }, {});\n                    return {\n                        version,\n                        partialOptions: {\n                            client: this.client,\n                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                            data: {\n                                event: event,\n                                events: events,\n                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? undefined : stepId || undefined,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],\n                            reqArgs,\n                            headers,\n                        },\n                    };\n                },\n                [InngestExecution_js_1.ExecutionVersion.V1]: ({ event, events, steps, ctx, version }) => {\n                    var _a, _b, _c;\n                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result]) => {\n                        return Object.assign(Object.assign({}, acc), { [id]: result.type === \"data\"\n                                ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                    { id, data: result.data }\n                                : result.type === \"input\"\n                                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                        { id, input: result.input }\n                                    : { id, error: result.error } });\n                    }, {});\n                    return {\n                        version,\n                        partialOptions: {\n                            client: this.client,\n                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                            data: {\n                                event: event,\n                                events: events,\n                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? undefined : stepId || undefined,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,\n                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],\n                            reqArgs,\n                            headers,\n                        },\n                    };\n                },\n                [InngestExecution_js_1.ExecutionVersion.V2]: ({ event, events, steps, ctx, version }) => {\n                    var _a, _b, _c;\n                    const stepState = Object.entries(steps !== null && steps !== void 0 ? steps : {}).reduce((acc, [id, result]) => {\n                        return Object.assign(Object.assign({}, acc), { [id]: result.type === \"data\"\n                                ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                    { id, data: result.data }\n                                : result.type === \"input\"\n                                    ? // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                                        { id, input: result.input }\n                                    : { id, error: result.error } });\n                    }, {});\n                    return {\n                        version,\n                        partialOptions: {\n                            client: this.client,\n                            runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                            data: {\n                                event: event,\n                                events: events,\n                                runId: (ctx === null || ctx === void 0 ? void 0 : ctx.run_id) || \"\",\n                                attempt: (_a = ctx === null || ctx === void 0 ? void 0 : ctx.attempt) !== null && _a !== void 0 ? _a : 0,\n                            },\n                            stepState,\n                            requestedRunStep: stepId === \"step\" ? undefined : stepId || undefined,\n                            timer,\n                            isFailureHandler: fn.onFailure,\n                            disableImmediateExecution: ctx === null || ctx === void 0 ? void 0 : ctx.disable_immediate_execution,\n                            stepCompletionOrder: (_c = (_b = ctx === null || ctx === void 0 ? void 0 : ctx.stack) === null || _b === void 0 ? void 0 : _b.stack) !== null && _c !== void 0 ? _c : [],\n                            reqArgs,\n                            headers,\n                        },\n                    };\n                },\n            });\n            const executionOptions = await executionStarters[version](anyFnData.value);\n            return fn.fn[\"createExecution\"](executionOptions).start();\n        });\n        return { version, result };\n    }\n    configs(url) {\n        const configs = Object.values(this.rawFns).reduce((acc, fn) => [\n            ...acc,\n            ...fn[\"getConfig\"]({ baseUrl: url, appPrefix: this.id }),\n        ], []);\n        for (const config of configs) {\n            const check = types_js_1.functionConfigSchema.safeParse(config);\n            if (!check.success) {\n                const errors = check.error.errors.map((err) => err.message).join(\"; \");\n                this.log(\"warn\", `Config invalid for function \"${config.id}\" : ${errors}`);\n            }\n        }\n        return configs;\n    }\n    /**\n     * Return an Inngest serve endpoint URL given a potential `path` and `host`.\n     *\n     * Will automatically use the `serveHost` and `servePath` if they have been\n     * set when registering.\n     */\n    reqUrl(url) {\n        let ret = new URL(url);\n        const serveHost = this.serveHost || this.env[consts_js_1.envKeys.InngestServeHost];\n        const servePath = this.servePath || this.env[consts_js_1.envKeys.InngestServePath];\n        if (servePath) {\n            ret.pathname = servePath;\n        }\n        if (serveHost) {\n            ret = new URL(ret.pathname + ret.search, serveHost);\n        }\n        return ret;\n    }\n    registerBody({ url, deployId, }) {\n        const body = {\n            url: url.href,\n            deployType: \"ping\",\n            framework: this.frameworkName,\n            appName: this.id,\n            functions: this.configs(url),\n            sdk: `js:v${version_js_1.version}`,\n            v: \"0.1\",\n            deployId: deployId || undefined,\n            capabilities: {\n                trust_probe: \"v1\",\n                connect: \"v1\",\n            },\n            appVersion: this.client.appVersion,\n        };\n        return body;\n    }\n    async inBandRegisterBody({ actions, deployId, env, signatureValidation, url, }) {\n        const registerBody = this.registerBody({ deployId, url });\n        const introspectionBody = await this.introspectionBody({\n            actions,\n            env,\n            signatureValidation,\n            url,\n        });\n        const body = {\n            app_id: this.id,\n            appVersion: this.client.appVersion,\n            capabilities: registerBody.capabilities,\n            env,\n            framework: registerBody.framework,\n            functions: registerBody.functions,\n            inspection: introspectionBody,\n            platform: (0, env_js_1.getPlatformName)(Object.assign(Object.assign({}, (0, env_js_1.allProcessEnv)()), this.env)),\n            sdk_author: \"inngest\",\n            sdk_language: \"\",\n            sdk_version: \"\",\n            sdk: registerBody.sdk,\n            url: registerBody.url,\n        };\n        if (introspectionBody.authentication_succeeded) {\n            body.sdk_language = introspectionBody.sdk_language;\n            body.sdk_version = introspectionBody.sdk_version;\n        }\n        return body;\n    }\n    async introspectionBody({ actions, env, signatureValidation, url, }) {\n        var _a, _b, _c, _d, _e;\n        const registerBody = this.registerBody({\n            url: this.reqUrl(url),\n            deployId: null,\n        });\n        if (!this._mode) {\n            throw new Error(\"No mode set; cannot introspect without mode\");\n        }\n        let introspection = {\n            authentication_succeeded: null,\n            extra: {\n                is_mode_explicit: this._mode.isExplicit,\n            },\n            has_event_key: this.client[\"eventKeySet\"](),\n            has_signing_key: Boolean(this.signingKey),\n            function_count: registerBody.functions.length,\n            mode: this._mode.type,\n            schema_version: \"2024-05-24\",\n        };\n        // Only allow authenticated introspection in Cloud mode, since Dev mode skips\n        // signature validation\n        if (this._mode.type === \"cloud\") {\n            try {\n                const validationResult = await signatureValidation;\n                if (!validationResult.success) {\n                    throw new Error(\"Signature validation failed\");\n                }\n                introspection = Object.assign(Object.assign({}, introspection), { authentication_succeeded: true, api_origin: this.apiBaseUrl, app_id: this.id, capabilities: {\n                        trust_probe: \"v1\",\n                        connect: \"v1\",\n                    }, env, event_api_origin: this.eventApiBaseUrl, event_key_hash: (_a = this.hashedEventKey) !== null && _a !== void 0 ? _a : null, extra: Object.assign(Object.assign({}, introspection.extra), { is_streaming: await this.shouldStream(actions) }), framework: this.frameworkName, sdk_language: \"js\", sdk_version: version_js_1.version, serve_origin: (_b = this.serveHost) !== null && _b !== void 0 ? _b : null, serve_path: (_c = this.servePath) !== null && _c !== void 0 ? _c : null, signing_key_fallback_hash: (_d = this.hashedSigningKeyFallback) !== null && _d !== void 0 ? _d : null, signing_key_hash: (_e = this.hashedSigningKey) !== null && _e !== void 0 ? _e : null });\n            }\n            catch (_f) {\n                // Swallow signature validation error since we'll just return the\n                // unauthenticated introspection\n                introspection = Object.assign(Object.assign({}, introspection), { authentication_succeeded: false });\n            }\n        }\n        return introspection;\n    }\n    async register(url, deployId, getHeaders) {\n        var _a;\n        const body = this.registerBody({ url, deployId });\n        let res;\n        // Whenever we register, we check to see if the dev server is up.  This\n        // is a noop and returns false in production. Clone the URL object to avoid\n        // mutating the property between requests.\n        let registerURL = new URL(this.inngestRegisterUrl.href);\n        const inferredDevMode = this._mode && this._mode.isInferred && this._mode.isDev;\n        if (inferredDevMode) {\n            const host = (0, env_js_1.devServerHost)(this.env);\n            const hasDevServer = await (0, devserver_js_1.devServerAvailable)(host, this.fetch);\n            if (hasDevServer) {\n                registerURL = (0, devserver_js_1.devServerUrl)(host, \"/fn/register\");\n            }\n        }\n        else if ((_a = this._mode) === null || _a === void 0 ? void 0 : _a.explicitDevUrl) {\n            registerURL = (0, devserver_js_1.devServerUrl)(this._mode.explicitDevUrl.href, \"/fn/register\");\n        }\n        if (deployId) {\n            registerURL.searchParams.set(consts_js_1.queryKeys.DeployId, deployId);\n        }\n        try {\n            res = await (0, net_js_1.fetchWithAuthFallback)({\n                authToken: this.hashedSigningKey,\n                authTokenFallback: this.hashedSigningKeyFallback,\n                fetch: this.fetch,\n                url: registerURL.href,\n                options: {\n                    method: \"POST\",\n                    body: (0, strings_js_1.stringify)(body),\n                    headers: Object.assign(Object.assign({}, getHeaders()), { [consts_js_1.headerKeys.InngestSyncKind]: consts_js_1.syncKind.OutOfBand }),\n                    redirect: \"follow\",\n                },\n            });\n        }\n        catch (err) {\n            this.log(\"error\", err);\n            return {\n                status: 500,\n                message: `Failed to register${err instanceof Error ? `; ${err.message}` : \"\"}`,\n                modified: false,\n            };\n        }\n        const raw = await res.text();\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        let data = {};\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            data = JSON.parse(raw);\n        }\n        catch (err) {\n            this.log(\"warn\", \"Couldn't unpack register response:\", err);\n            let message = \"Failed to register\";\n            if (err instanceof Error) {\n                message += `; ${err.message}`;\n            }\n            message += `; status code: ${res.status}`;\n            return {\n                status: 500,\n                message,\n                modified: false,\n            };\n        }\n        let status;\n        let error;\n        let skipped;\n        let modified;\n        try {\n            ({ status, error, skipped, modified } = registerResSchema.parse(data));\n        }\n        catch (err) {\n            this.log(\"warn\", \"Invalid register response schema:\", err);\n            let message = \"Failed to register\";\n            if (err instanceof Error) {\n                message += `; ${err.message}`;\n            }\n            message += `; status code: ${res.status}`;\n            return {\n                status: 500,\n                message,\n                modified: false,\n            };\n        }\n        // The dev server polls this endpoint to register functions every few\n        // seconds, but we only want to log that we've registered functions if\n        // the function definitions change.  Therefore, we compare the body sent\n        // during registration with the body of the current functions and refuse\n        // to register if the functions are the same.\n        if (!skipped) {\n            this.log(\"debug\", \"registered inngest functions:\", res.status, res.statusText, data);\n        }\n        return { status, message: error, modified };\n    }\n    /**\n     * Given an environment, upsert any missing keys. This is useful in\n     * situations where environment variables are passed directly to handlers or\n     * are otherwise difficult to access during initialization.\n     */\n    upsertKeysFromEnv() {\n        if (this.env[consts_js_1.envKeys.InngestSigningKey]) {\n            if (!this.signingKey) {\n                this.signingKey = String(this.env[consts_js_1.envKeys.InngestSigningKey]);\n            }\n            this.client[\"inngestApi\"].setSigningKey(this.signingKey);\n        }\n        if (this.env[consts_js_1.envKeys.InngestSigningKeyFallback]) {\n            if (!this.signingKeyFallback) {\n                this.signingKeyFallback = String(this.env[consts_js_1.envKeys.InngestSigningKeyFallback]);\n            }\n            this.client[\"inngestApi\"].setSigningKeyFallback(this.signingKeyFallback);\n        }\n        if (!this.client[\"eventKeySet\"]() && this.env[consts_js_1.envKeys.InngestEventKey]) {\n            this.client.setEventKey(String(this.env[consts_js_1.envKeys.InngestEventKey]));\n        }\n        // v2 -> v3 migration warnings\n        if (this.env[consts_js_1.envKeys.InngestDevServerUrl]) {\n            this.log(\"warn\", `Use of ${consts_js_1.envKeys.InngestDevServerUrl} has been deprecated in v3; please use ${consts_js_1.envKeys.InngestBaseUrl} instead. See https://www.inngest.com/docs/sdk/migration`);\n        }\n    }\n    /**\n     * Validate the signature of a request and return the signing key used to\n     * validate it.\n     */\n    // eslint-disable-next-line @typescript-eslint/require-await\n    async validateSignature(sig, body) {\n        try {\n            // Skip signature validation if requested (used by connect)\n            if (this.skipSignatureValidation) {\n                return { success: true, keyUsed: \"\" };\n            }\n            // Never validate signatures outside of prod. Make sure to check the mode\n            // exists here instead of using nullish coalescing to confirm that the check\n            // has been completed.\n            if (this._mode && !this._mode.isCloud) {\n                return { success: true, keyUsed: \"\" };\n            }\n            // If we're here, we're in production; lack of a signing key is an error.\n            if (!this.signingKey) {\n                // TODO PrettyError\n                throw new Error(`No signing key found in client options or ${consts_js_1.envKeys.InngestSigningKey} env var. Find your keys at https://app.inngest.com/secrets`);\n            }\n            // If we're here, we're in production; lack of a req signature is an error.\n            if (!sig) {\n                // TODO PrettyError\n                throw new Error(`No ${consts_js_1.headerKeys.Signature} provided`);\n            }\n            // Validate the signature\n            return {\n                success: true,\n                keyUsed: new RequestSignature(sig).verifySignature({\n                    body,\n                    allowExpiredSignatures: this.allowExpiredSignatures,\n                    signingKey: this.signingKey,\n                    signingKeyFallback: this.signingKeyFallback,\n                }),\n            };\n        }\n        catch (err) {\n            return { success: false, err: err };\n        }\n    }\n    getResponseSignature(key, body) {\n        const now = Date.now();\n        const mac = (0, net_js_1.signDataWithKey)(body, key, now.toString());\n        return `t=${now}&s=${mac}`;\n    }\n    /**\n     * Log to stdout/stderr if the log level is set to include the given level.\n     * The default log level is `\"info\"`.\n     *\n     * This is an abstraction over `console.log` and will try to use the correct\n     * method for the given log level.  For example, `log(\"error\", \"foo\")` will\n     * call `console.error(\"foo\")`.\n     */\n    log(level, ...args) {\n        const logLevels = [\n            \"debug\",\n            \"info\",\n            \"warn\",\n            \"error\",\n            \"fatal\",\n            \"silent\",\n        ];\n        const logLevelSetting = logLevels.indexOf(this.logLevel);\n        const currentLevel = logLevels.indexOf(level);\n        if (currentLevel >= logLevelSetting) {\n            let logger = console.log;\n            if (Object.prototype.hasOwnProperty.call(console, level)) {\n                logger = console[level];\n            }\n            logger(`${consts_js_1.logPrefix} ${level} -`, ...args);\n        }\n    }\n}\nexports.InngestCommHandler = InngestCommHandler;\nclass RequestSignature {\n    constructor(sig) {\n        _RequestSignature_instances.add(this);\n        const params = new URLSearchParams(sig);\n        this.timestamp = params.get(\"t\") || \"\";\n        this.signature = params.get(\"s\") || \"\";\n        if (!this.timestamp || !this.signature) {\n            // TODO PrettyError\n            throw new Error(`Invalid ${consts_js_1.headerKeys.Signature} provided`);\n        }\n    }\n    hasExpired(allowExpiredSignatures) {\n        if (allowExpiredSignatures) {\n            return false;\n        }\n        const delta = Date.now() - new Date(parseInt(this.timestamp) * 1000).valueOf();\n        return delta > 1000 * 60 * 5;\n    }\n    verifySignature({ body, signingKey, signingKeyFallback, allowExpiredSignatures, }) {\n        try {\n            __classPrivateFieldGet(this, _RequestSignature_instances, \"m\", _RequestSignature_verifySignature).call(this, { body, signingKey, allowExpiredSignatures });\n            return signingKey;\n        }\n        catch (err) {\n            if (!signingKeyFallback) {\n                throw err;\n            }\n            __classPrivateFieldGet(this, _RequestSignature_instances, \"m\", _RequestSignature_verifySignature).call(this, {\n                body,\n                signingKey: signingKeyFallback,\n                allowExpiredSignatures,\n            });\n            return signingKeyFallback;\n        }\n    }\n}\n_RequestSignature_instances = new WeakSet(), _RequestSignature_verifySignature = function _RequestSignature_verifySignature({ body, signingKey, allowExpiredSignatures, }) {\n    if (this.hasExpired(allowExpiredSignatures)) {\n        // TODO PrettyError\n        throw new Error(\"Signature has expired\");\n    }\n    const mac = (0, net_js_1.signDataWithKey)(body, signingKey, this.timestamp);\n    if (mac !== this.signature) {\n        // TODO PrettyError\n        throw new Error(\"Invalid signature\");\n    }\n};\n//# sourceMappingURL=InngestCommHandler.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RDb21tSGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDBCQUEwQjtBQUMxQixnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQyxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IsMEJBQTBCLG1CQUFPLENBQUMsd0ZBQTRCO0FBQzlELG9CQUFvQixtQkFBTyxDQUFDLDRFQUFzQjtBQUNsRCx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBeUI7QUFDeEQsa0JBQWtCLG1CQUFPLENBQUMsd0VBQW9CO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjtBQUM1QyxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBc0I7QUFDbEQsdUJBQXVCLG1CQUFPLENBQUMsa0ZBQXlCO0FBQ3hELGlCQUFpQixtQkFBTyxDQUFDLHNFQUFtQjtBQUM1QyxzQkFBc0IsbUJBQU8sQ0FBQyxnRkFBd0I7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCxtQkFBbUIsbUJBQU8sQ0FBQywwREFBYTtBQUN4QyxxQkFBcUIsbUJBQU8sQ0FBQyw4REFBZTtBQUM1Qyw4QkFBOEIsbUJBQU8sQ0FBQyw4R0FBaUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsOEJBQThCO0FBQ2hGLGlDQUFpQyx1QkFBdUI7QUFDeEQseUNBQXlDLGlCQUFpQjtBQUMxRCxZQUFZO0FBQ1o7QUFDQSxRQUFRO0FBQ1IsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsdUJBQXVCLGdIQUFnSDtBQUN0SztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwrQ0FBK0MsSUFBSTtBQUNuRCxxREFBcUQsVUFBVSxRQUFRLGlDQUFpQztBQUN4RyxhQUFhLElBQUk7QUFDakIsK0JBQStCLElBQUk7QUFDbkM7QUFDQTtBQUNBLDhEQUE4RCxHQUFHLEdBQUc7QUFDcEU7QUFDQSxhQUFhO0FBQ2IsaURBQWlEO0FBQ2pELFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsb0JBQW9CLGdCQUFnQixnQkFBZ0I7QUFDOUc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyx3QkFBd0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsb0JBQW9CLGdCQUFnQiwrQkFBK0I7QUFDcEk7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsOEJBQThCO0FBQ3BGLHFDQUFxQyx1QkFBdUI7QUFDNUQsNkNBQTZDLGlCQUFpQjtBQUM5RCxnQkFBZ0I7QUFDaEI7QUFDQSxZQUFZO0FBQ1osVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsVUFBVTtBQUMvRDtBQUNBLGdEQUFnRCxJQUFJO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHVCQUF1QjtBQUN2QixhQUFhLElBQUk7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UseUJBQXlCO0FBQ2pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYix3REFBd0Qsb0NBQW9DO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFFBQVE7QUFDeEUseUJBQXlCO0FBQ3pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsT0FBTztBQUNyRztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxlQUFlO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLElBQUk7QUFDckIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseURBQXlELFVBQVUsK0ZBQStGO0FBQ2xLO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFVBQVUsU0FBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIseUZBQXlGO0FBQ2xIO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLDBIQUEwSCxTQUFTO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELDJHQUEyRztBQUNoSyxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSwrREFBK0QsMENBQTBDLFVBQVU7QUFDbkgsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsb0NBQW9DO0FBQ3pGLGtEQUFrRCx1RUFBdUU7QUFDekgsd0NBQXdDO0FBQ3hDLHdDQUF3QyxPQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0Esd0RBQXdELG1CQUFtQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0Usa0JBQWtCO0FBQ3BGO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0EsYUFBYTtBQUNiLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxjQUFjLG9EQUFvRDtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxXQUFXO0FBQzNFO0FBQ0E7QUFDQSxjQUFjLFVBQVU7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usb0NBQW9DO0FBQ3BHO0FBQ0Esb0dBQW9HO0FBQ3BHLDZEQUE2RDtBQUM3RDtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hELHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCLGdFQUFnRSxvQ0FBb0M7QUFDcEc7QUFDQSxvR0FBb0c7QUFDcEcsNkRBQTZELFVBQVU7QUFDdkU7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyx3Q0FBd0MsMkJBQTJCO0FBQ25FLHFCQUFxQixJQUFJO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakIsZ0VBQWdFLG9DQUFvQztBQUNwRztBQUNBLG9HQUFvRztBQUNwRyw2REFBNkQsVUFBVTtBQUN2RTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsMENBQTBDO0FBQzFDLHdDQUF3QywyQkFBMkI7QUFDbkUscUJBQXFCLElBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0ZBQW9GO0FBQ3BGLGlFQUFpRSxVQUFVLE1BQU0sT0FBTztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLG1EQUFtRDtBQUNsRixpREFBaUQsZUFBZTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHlDQUF5QztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsb0JBQW9CO0FBQ2xGO0FBQ0E7QUFDQSxxQkFBcUIsc0tBQXNLLDBCQUEwQixnREFBZ0QsMGFBQTBhO0FBQy9xQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCxvQkFBb0IsaUNBQWlDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxlQUFlO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJELG1CQUFtQiwwRUFBMEU7QUFDeEo7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCLEVBQUUsWUFBWSxPQUFPO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsRUFBRSxZQUFZO0FBQzVDO0FBQ0EsMEJBQTBCLGVBQWUsV0FBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQ0FBbUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixFQUFFLFlBQVk7QUFDNUM7QUFDQSwwQkFBMEIsZUFBZSxXQUFXO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHlDQUF5QywyQkFBMkIsYUFBYSxvQ0FBb0M7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSw2RUFBNkUsdUNBQXVDO0FBQ3BIO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSxzQ0FBc0Msa0NBQWtDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixJQUFJLEtBQUssSUFBSTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix1QkFBdUIsRUFBRSxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGtDQUFrQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsK0RBQStEO0FBQ3JGO0FBQ0EsMkhBQTJILDBDQUEwQztBQUNySztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SCwyQ0FBMkM7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvSW5uZ2VzdENvbW1IYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG52YXIgX1JlcXVlc3RTaWduYXR1cmVfaW5zdGFuY2VzLCBfUmVxdWVzdFNpZ25hdHVyZV92ZXJpZnlTaWduYXR1cmU7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklubmdlc3RDb21tSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IHpvZF8xID0gcmVxdWlyZShcInpvZFwiKTtcbmNvbnN0IFNlcnZlclRpbWluZ19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvU2VydmVyVGltaW5nLmpzXCIpO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9jb25zdHMuanNcIik7XG5jb25zdCBkZXZzZXJ2ZXJfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2RldnNlcnZlci5qc1wiKTtcbmNvbnN0IGVudW1fanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2VudW0uanNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL2Vudi5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZXJyb3JzLmpzXCIpO1xuY29uc3QgZnVuY3Rpb25zX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9mdW5jdGlvbnMuanNcIik7XG5jb25zdCBuZXRfanNfMSA9IHJlcXVpcmUoXCIuLi9oZWxwZXJzL25ldC5qc1wiKTtcbmNvbnN0IHByb21pc2VzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9wcm9taXNlcy5qc1wiKTtcbmNvbnN0IHN0cmVhbV9qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RyZWFtLmpzXCIpO1xuY29uc3Qgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvc3RyaW5ncy5qc1wiKTtcbmNvbnN0IHR5cGVzX2pzXzEgPSByZXF1aXJlKFwiLi4vdHlwZXMuanNcIik7XG5jb25zdCB2ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vdmVyc2lvbi5qc1wiKTtcbmNvbnN0IElubmdlc3RFeGVjdXRpb25fanNfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzXCIpO1xuLyoqXG4gKiBBIHNjaGVtYSBmb3IgdGhlIHJlc3BvbnNlIGZyb20gSW5uZ2VzdCB3aGVuIHJlZ2lzdGVyaW5nLlxuICovXG5jb25zdCByZWdpc3RlclJlc1NjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBzdGF0dXM6IHpvZF8xLnoubnVtYmVyKCkuZGVmYXVsdCgyMDApLFxuICAgIHNraXBwZWQ6IHpvZF8xLnouYm9vbGVhbigpLm9wdGlvbmFsKCkuZGVmYXVsdChmYWxzZSksXG4gICAgbW9kaWZpZWQ6IHpvZF8xLnouYm9vbGVhbigpLm9wdGlvbmFsKCkuZGVmYXVsdChmYWxzZSksXG4gICAgZXJyb3I6IHpvZF8xLnouc3RyaW5nKCkuZGVmYXVsdChcIlN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkXCIpLFxufSk7XG4vKipcbiAqIGBJbm5nZXN0Q29tbUhhbmRsZXJgIGlzIGEgY2xhc3MgZm9yIGhhbmRsaW5nIGluY29taW5nIHJlcXVlc3RzIGZyb20gSW5uZ2VzdCAob3JcbiAqIElubmdlc3QncyB0b29saW5nIHN1Y2ggYXMgdGhlIGRldiBzZXJ2ZXIgb3IgQ0xJKSBhbmQgdGFraW5nIGFwcHJvcHJpYXRlXG4gKiBhY3Rpb24gZm9yIGFueSBzZXJ2ZWQgZnVuY3Rpb25zLlxuICpcbiAqIEFsbCBoYW5kbGVycyAoTmV4dC5qcywgUmVkd29vZEpTLCBSZW1peCwgRGVubyBGcmVzaCwgZXRjLikgYXJlIGNyZWF0ZWQgdXNpbmdcbiAqIHRoaXMgY2xhc3M7IHRoZSBleHBvc2VkIGBzZXJ2ZWAgZnVuY3Rpb24gd2lsbCAtIG1vc3QgY29tbW9ubHkgLSBjcmVhdGUgYW5cbiAqIGluc3RhbmNlIG9mIGBJbm5nZXN0Q29tbUhhbmRsZXJgIGFuZCB0aGVuIHJldHVybiBgaW5zdGFuY2UuY3JlYXRlSGFuZGxlcigpYC5cbiAqXG4gKiBTZWUgaW5kaXZpZHVhbCBwYXJhbWV0ZXIgZGV0YWlscyBmb3IgbW9yZSBpbmZvcm1hdGlvbiwgb3Igc2VlIHRoZVxuICogc291cmNlIGNvZGUgZm9yIGFuIGV4aXN0aW5nIGhhbmRsZXIsIGUuZy5cbiAqIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vaW5uZ2VzdC9pbm5nZXN0LWpzL2Jsb2IvbWFpbi9zcmMvbmV4dC50c31cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiAvLyBteS1jdXN0b20taGFuZGxlci50c1xuICogaW1wb3J0IHtcbiAqICAgSW5uZ2VzdENvbW1IYW5kbGVyLFxuICogICB0eXBlIFNlcnZlSGFuZGxlck9wdGlvbnMsXG4gKiB9IGZyb20gXCIuL2NvbXBvbmVudHMvSW5uZ2VzdENvbW1IYW5kbGVyXCI7XG4gKlxuICogZXhwb3J0IGNvbnN0IHNlcnZlID0gKG9wdGlvbnM6IFNlcnZlSGFuZGxlck9wdGlvbnMpID0+IHtcbiAqICAgY29uc3QgaGFuZGxlciA9IG5ldyBJbm5nZXN0Q29tbUhhbmRsZXIoe1xuICogICAgIGZyYW1ld29ya05hbWU6IFwibXktY3VzdG9tLWhhbmRsZXJcIixcbiAqICAgICAuLi5vcHRpb25zLFxuICogICAgIGhhbmRsZXI6IChyZXE6IFJlcXVlc3QpID0+IHtcbiAqICAgICAgIHJldHVybiB7XG4gKiAgICAgICAgIGJvZHk6ICgpID0+IHJlcS5qc29uKCksXG4gKiAgICAgICAgIGhlYWRlcnM6IChrZXkpID0+IHJlcS5oZWFkZXJzLmdldChrZXkpLFxuICogICAgICAgICBtZXRob2Q6ICgpID0+IHJlcS5tZXRob2QsXG4gKiAgICAgICAgIHVybDogKCkgPT4gbmV3IFVSTChyZXEudXJsLCBgaHR0cHM6Ly8ke3JlcS5oZWFkZXJzLmdldChcImhvc3RcIikgfHwgXCJcIn1gKSxcbiAqICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6ICh7IGJvZHksIHN0YXR1cywgaGVhZGVycyB9KSA9PiB7XG4gKiAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCB7IHN0YXR1cywgaGVhZGVycyB9KTtcbiAqICAgICAgICAgfSxcbiAqICAgICAgIH07XG4gKiAgICAgfSxcbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gaGFuZGxlci5jcmVhdGVIYW5kbGVyKCk7XG4gKiB9O1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBJbm5nZXN0Q29tbUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBwcml2YXRlIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHRoYXQgYXJlIGJlaW5nIHNlcnZlZC4gVGhpcyBtYXAgaXMgdXNlZFxuICAgICAgICAgKiB0byBmaW5kIGFuZCByZWdpc3RlciBmdW5jdGlvbnMgd2hlbiBpbnRlcmFjdGluZyB3aXRoIElubmdlc3QgQ2xvdWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZucyA9IHt9O1xuICAgICAgICB0aGlzLmVudiA9ICgwLCBlbnZfanNfMS5hbGxQcm9jZXNzRW52KSgpO1xuICAgICAgICAvLyBTZXQgaW5wdXQgb3B0aW9ucyBkaXJlY3RseSBzbyB3ZSBjYW4gcmVmZXJlbmNlIHRoZW0gbGF0ZXJcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB2MiAtPiB2MyBtaWdyYXRpb24gZXJyb3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIGEgc2VydmUgaGFuZGxlciBpcyBwYXNzZWQgYSBjbGllbnQgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LCBpdCdsbCBiZVxuICAgICAgICAgKiBzcHJlYWQgaW4gdG8gdGhlc2Ugb3B0aW9ucy4gV2Ugc2hvdWxkIGJlIGFibGUgdG8gZGV0ZWN0IHRoaXMgYnkgcGlja2luZ1xuICAgICAgICAgKiB1cCBhIHVuaXF1ZSBwcm9wZXJ0eSBvbiB0aGUgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCBcImV2ZW50S2V5XCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7Y29uc3RzX2pzXzEubG9nUHJlZml4fSBZb3UndmUgcGFzc2VkIGFuIElubmdlc3QgY2xpZW50IGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB5b3VyIHNlcnZlIGhhbmRsZXIuIFRoaXMgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBpbiB2MzsgcGxlYXNlIHBhc3MgdGhlIElubmdlc3QgY2xpZW50IGFzIHRoZSBcXGBjbGllbnRcXGAgcHJvcGVydHkgb2YgYW4gb3B0aW9ucyBvYmplY3QgaW5zdGVhZC4gU2VlIGh0dHBzOi8vd3d3Lmlubmdlc3QuY29tL2RvY3Mvc2RrL21pZ3JhdGlvbmApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhbWV3b3JrTmFtZSA9IG9wdGlvbnMuZnJhbWV3b3JrTmFtZTtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBvcHRpb25zLmNsaWVudDtcbiAgICAgICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjb25zdHNfanNfMS5sb2dQcmVmaXh9IFRoZSBcXGBpZFxcYCBzZXJ2ZSBvcHRpb24gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHY0YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZCA9IG9wdGlvbnMuaWQgfHwgdGhpcy5jbGllbnQuaWQ7XG4gICAgICAgIHRoaXMuaGFuZGxlciA9IG9wdGlvbnMuaGFuZGxlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFByb3ZpZGUgYSBoaWRkZW4gb3B0aW9uIHRvIGFsbG93IGV4cGlyZWQgc2lnbmF0dXJlcyB0byBiZSBhY2NlcHRlZCBkdXJpbmdcbiAgICAgICAgICogdGVzdGluZy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYWxsb3dFeHBpcmVkU2lnbmF0dXJlcyA9IEJvb2xlYW4oXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAoX2EgPSBhcmd1bWVudHNbXCIwXCJdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuX190ZXN0aW5nQWxsb3dFeHBpcmVkU2lnbmF0dXJlcyk7XG4gICAgICAgIC8vIEVuc3VyZSB3ZSBmaWx0ZXIgYW55IHVuZGVmaW5lZCBmdW5jdGlvbnMgaW4gY2FzZSBvZiBtaXNzaW5nIGltcG9ydHMuXG4gICAgICAgIHRoaXMucmF3Rm5zID0gb3B0aW9ucy5mdW5jdGlvbnMuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgICBpZiAodGhpcy5yYXdGbnMubGVuZ3RoICE9PSBvcHRpb25zLmZ1bmN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gUHJldHR5RXJyb3JcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgU29tZSBmdW5jdGlvbnMgcGFzc2VkIHRvIHNlcnZlKCkgYXJlIHVuZGVmaW5lZCBhbmQgbWlzY29uZmlndXJlZC4gIFBsZWFzZSBjaGVjayB5b3VyIGltcG9ydHMuYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mbnMgPSB0aGlzLnJhd0Zucy5yZWR1Y2UoKGFjYywgZm4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ3MgPSBmbltcImdldENvbmZpZ1wiXSh7XG4gICAgICAgICAgICAgICAgYmFzZVVybDogbmV3IFVSTChcImh0dHBzOi8vZXhhbXBsZS5jb21cIiksXG4gICAgICAgICAgICAgICAgYXBwUHJlZml4OiB0aGlzLmlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBmbnMgPSBjb25maWdzLnJlZHVjZSgoYWNjLCB7IGlkIH0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwgeyBbaWRdOiB7IGZuLCBvbkZhaWx1cmU6IEJvb2xlYW4oaW5kZXgpIH0gfSk7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICBjb25maWdzLmZvckVhY2goKHsgaWQgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhY2NbaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gUHJldHR5RXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgZnVuY3Rpb24gSUQgXCIke2lkfVwiOyBwbGVhc2UgY2hhbmdlIGEgZnVuY3Rpb24ncyBuYW1lIG9yIHByb3ZpZGUgYW4gZXhwbGljaXQgSUQgdG8gYXZvaWQgY29uZmxpY3RzLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwgZm5zKTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICB0aGlzLmlubmdlc3RSZWdpc3RlclVybCA9IG5ldyBVUkwoXCIvZm4vcmVnaXN0ZXJcIiwgdGhpcy5hcGlCYXNlVXJsKTtcbiAgICAgICAgdGhpcy5zaWduaW5nS2V5ID0gb3B0aW9ucy5zaWduaW5nS2V5O1xuICAgICAgICB0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayA9IG9wdGlvbnMuc2lnbmluZ0tleUZhbGxiYWNrO1xuICAgICAgICB0aGlzLl9zZXJ2ZUhvc3QgPSBvcHRpb25zLnNlcnZlSG9zdCB8fCB0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTZXJ2ZUhvc3RdO1xuICAgICAgICB0aGlzLl9zZXJ2ZVBhdGggPSBvcHRpb25zLnNlcnZlUGF0aCB8fCB0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTZXJ2ZVBhdGhdO1xuICAgICAgICB0aGlzLnNraXBTaWduYXR1cmVWYWxpZGF0aW9uID0gb3B0aW9ucy5za2lwU2lnbmF0dXJlVmFsaWRhdGlvbiB8fCBmYWxzZTtcbiAgICAgICAgY29uc3QgZGVmYXVsdExvZ0xldmVsID0gXCJpbmZvXCI7XG4gICAgICAgIHRoaXMubG9nTGV2ZWwgPSB6b2RfMS56XG4gICAgICAgICAgICAuZW51bSh0eXBlc19qc18xLmxvZ0xldmVscylcbiAgICAgICAgICAgIC5kZWZhdWx0KGRlZmF1bHRMb2dMZXZlbClcbiAgICAgICAgICAgIC5jYXRjaCgoY3R4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIndhcm5cIiwgYFVua25vd24gbG9nIGxldmVsIHBhc3NlZDogJHtTdHJpbmcoY3R4LmlucHV0KX07IGRlZmF1bHRpbmcgdG8gJHtkZWZhdWx0TG9nTGV2ZWx9YCk7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdExvZ0xldmVsO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnBhcnNlKG9wdGlvbnMubG9nTGV2ZWwgfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0TG9nTGV2ZWxdKTtcbiAgICAgICAgaWYgKHRoaXMubG9nTGV2ZWwgPT09IFwiZGVidWdcIikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBgZGVidWdgIGlzIGFuIG9sZCBsaWJyYXJ5OyBzb21ldGltZXMgaXRzIHJ1bnRpbWUgZGV0ZWN0aW9uIGRvZXNuJ3Qgd29ya1xuICAgICAgICAgICAgICogZm9yIG5ld2VyIHBhaXJpbmdzIG9mIGZyYW1ld29yay9ydW50aW1lLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE9uZSBzaWxseSBzeW1wdG9tIG9mIHRoaXMgaXMgdGhhdCBgRGVidWcoKWAgcmV0dXJucyBhbiBhbm9ueW1vdXNcbiAgICAgICAgICAgICAqIGZ1bmN0aW9uIHdpdGggbm8gZXh0cmEgcHJvcGVydGllcyBpbnN0ZWFkIG9mIGEgYERlYnVnZ2VyYCBpbnN0YW5jZSBpZlxuICAgICAgICAgICAgICogdGhlIHdyb25nIGNvZGUgaXMgY29uc3VtZWQgZm9sbG93aW5nIGEgYmFkIGRldGVjdGlvbi4gVGhpcyByZXN1bHRzIGluXG4gICAgICAgICAgICAgKiB0aGUgZm9sbG93aW5nIGAuZW5hYmxlKClgIGNhbGwgZmFpbGluZywgc28gd2UganVzdCB0cnkgY2FyZWZ1bGx5IHRvXG4gICAgICAgICAgICAgKiBlbmFibGUgaXQgaGVyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGRlYnVnXzEuZGVmYXVsdC5lbmFibGUgJiYgdHlwZW9mIGRlYnVnXzEuZGVmYXVsdC5lbmFibGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGRlYnVnXzEuZGVmYXVsdC5lbmFibGUoYCR7Y29uc3RzX2pzXzEuZGVidWdQcmVmaXh9OipgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWZhdWx0U3RyZWFtaW5nT3B0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RyZWFtaW5nID0gem9kXzEuelxuICAgICAgICAgICAgLnVuaW9uKFt6b2RfMS56LmVudW0oW1wiYWxsb3dcIiwgXCJmb3JjZVwiXSksIHpvZF8xLnoubGl0ZXJhbChmYWxzZSldKVxuICAgICAgICAgICAgLmRlZmF1bHQoZGVmYXVsdFN0cmVhbWluZ09wdGlvbilcbiAgICAgICAgICAgIC5jYXRjaCgoY3R4KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIndhcm5cIiwgYFVua25vd24gc3RyZWFtaW5nIG9wdGlvbiBwYXNzZWQ6ICR7U3RyaW5nKGN0eC5pbnB1dCl9OyBkZWZhdWx0aW5nIHRvICR7U3RyaW5nKGRlZmF1bHRTdHJlYW1pbmdPcHRpb24pfWApO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRTdHJlYW1pbmdPcHRpb247XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucGFyc2Uob3B0aW9ucy5zdHJlYW1pbmcgfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U3RyZWFtaW5nXSk7XG4gICAgICAgIHRoaXMuZmV0Y2ggPSBvcHRpb25zLmZldGNoID8gKDAsIGVudl9qc18xLmdldEZldGNoKShvcHRpb25zLmZldGNoKSA6IHRoaXMuY2xpZW50W1wiZmV0Y2hcIl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgQVBJIGJhc2UgVVJMIGZvciB0aGUgSW5uZ2VzdCBBUEkuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgZ2V0dGVyIHRvIGVuY291cmFnZSBjaGVja2luZyB0aGUgZW52aXJvbm1lbnQgZm9yIHRoZSBBUEkgYmFzZSBVUkxcbiAgICAgKiBlYWNoIHRpbWUgaXQncyBhY2Nlc3NlZCwgYXMgaXQgbWF5IGNoYW5nZSBkdXJpbmcgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGdldCBhcGlCYXNlVXJsKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX29wdGlvbnMuYmFzZVVybCB8fFxuICAgICAgICAgICAgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QXBpQmFzZVVybF0gfHxcbiAgICAgICAgICAgIHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEJhc2VVcmxdIHx8XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5hcGlCYXNlVXJsIHx8XG4gICAgICAgICAgICBjb25zdHNfanNfMS5kZWZhdWx0SW5uZ2VzdEFwaUJhc2VVcmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGV2ZW50IEFQSSBiYXNlIFVSTCBmb3IgdGhlIElubmdlc3QgQVBJLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhIGdldHRlciB0byBlbmNvdXJhZ2UgY2hlY2tpbmcgdGhlIGVudmlyb25tZW50IGZvciB0aGUgZXZlbnQgQVBJXG4gICAgICogYmFzZSBVUkwgZWFjaCB0aW1lIGl0J3MgYWNjZXNzZWQsIGFzIGl0IG1heSBjaGFuZ2UgZHVyaW5nIGV4ZWN1dGlvbi5cbiAgICAgKi9cbiAgICBnZXQgZXZlbnRBcGlCYXNlVXJsKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX29wdGlvbnMuYmFzZVVybCB8fFxuICAgICAgICAgICAgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RXZlbnRBcGlCYXNlVXJsXSB8fFxuICAgICAgICAgICAgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QmFzZVVybF0gfHxcbiAgICAgICAgICAgIHRoaXMuY2xpZW50LmV2ZW50QmFzZVVybCB8fFxuICAgICAgICAgICAgY29uc3RzX2pzXzEuZGVmYXVsdElubmdlc3RFdmVudEJhc2VVcmwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgaG9zdCB1c2VkIHRvIGFjY2VzcyB0aGUgSW5uZ2VzdCBzZXJ2ZSBlbmRwb2ludCwgZS5nLjpcbiAgICAgKlxuICAgICAqICAgICBcImh0dHBzOi8vbXlhcHAuY29tXCJcbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSBsaWJyYXJ5IHdpbGwgdHJ5IHRvIGluZmVyIHRoaXMgdXNpbmcgcmVxdWVzdCBkZXRhaWxzIHN1Y2hcbiAgICAgKiBhcyB0aGUgXCJIb3N0XCIgaGVhZGVyIGFuZCByZXF1ZXN0IHBhdGgsIGJ1dCBzb21ldGltZXMgdGhpcyBpc24ndCBwb3NzaWJsZVxuICAgICAqIChlLmcuIHdoZW4gcnVubmluZyBpbiBhIG1vcmUgY29udHJvbGxlZCBlbnZpcm9ubWVudHMgc3VjaCBhcyBBV1MgTGFtYmRhIG9yXG4gICAgICogd2hlbiBkZWFsaW5nIHdpdGggcHJveGllcy9yZWRpcmVjdHMpLlxuICAgICAqXG4gICAgICogUHJvdmlkZSB0aGUgY3VzdG9tIGhvc3RuYW1lIGhlcmUgdG8gZW5zdXJlIHRoYXQgdGhlIHBhdGggaXMgcmVwb3J0ZWRcbiAgICAgKiBjb3JyZWN0bHkgd2hlbiByZWdpc3RlcmluZyBmdW5jdGlvbnMgd2l0aCBJbm5nZXN0LlxuICAgICAqXG4gICAgICogVG8gYWxzbyBwcm92aWRlIGEgY3VzdG9tIHBhdGgsIHVzZSBgc2VydmVQYXRoYC5cbiAgICAgKi9cbiAgICBnZXQgc2VydmVIb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VydmVIb3N0IHx8IHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFNlcnZlSG9zdF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBwYXRoIHRvIHRoZSBJbm5nZXN0IHNlcnZlIGVuZHBvaW50LiBlLmcuOlxuICAgICAqXG4gICAgICogICAgIFwiL3NvbWUvbG9uZy9wYXRoL3RvL2lubmdlc3QvZW5kcG9pbnRcIlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgdGhlIGxpYnJhcnkgd2lsbCB0cnkgdG8gaW5mZXIgdGhpcyB1c2luZyByZXF1ZXN0IGRldGFpbHMgc3VjaFxuICAgICAqIGFzIHRoZSBcIkhvc3RcIiBoZWFkZXIgYW5kIHJlcXVlc3QgcGF0aCwgYnV0IHNvbWV0aW1lcyB0aGlzIGlzbid0IHBvc3NpYmxlXG4gICAgICogKGUuZy4gd2hlbiBydW5uaW5nIGluIGEgbW9yZSBjb250cm9sbGVkIGVudmlyb25tZW50cyBzdWNoIGFzIEFXUyBMYW1iZGEgb3JcbiAgICAgKiB3aGVuIGRlYWxpbmcgd2l0aCBwcm94aWVzL3JlZGlyZWN0cykuXG4gICAgICpcbiAgICAgKiBQcm92aWRlIHRoZSBjdXN0b20gcGF0aCAoZXhjbHVkaW5nIHRoZSBob3N0bmFtZSkgaGVyZSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgKiBwYXRoIGlzIHJlcG9ydGVkIGNvcnJlY3RseSB3aGVuIHJlZ2lzdGVyaW5nIGZ1bmN0aW9ucyB3aXRoIElubmdlc3QuXG4gICAgICpcbiAgICAgKiBUbyBhbHNvIHByb3ZpZGUgYSBjdXN0b20gaG9zdG5hbWUsIHVzZSBgc2VydmVIb3N0YC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYSBnZXR0ZXIgdG8gZW5jb3VyYWdlIGNoZWNraW5nIHRoZSBlbnZpcm9ubWVudCBmb3IgdGhlIHNlcnZlIHBhdGhcbiAgICAgKiBlYWNoIHRpbWUgaXQncyBhY2Nlc3NlZCwgYXMgaXQgbWF5IGNoYW5nZSBkdXJpbmcgZXhlY3V0aW9uLlxuICAgICAqL1xuICAgIGdldCBzZXJ2ZVBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZVBhdGggfHwgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2VydmVQYXRoXTtcbiAgICB9XG4gICAgZ2V0IGhhc2hlZEV2ZW50S2V5KCkge1xuICAgICAgICBpZiAoIXRoaXMuY2xpZW50W1wiZXZlbnRLZXlcIl0gfHwgdGhpcy5jbGllbnRbXCJldmVudEtleVwiXSA9PT0gY29uc3RzX2pzXzEuZHVtbXlFdmVudEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDAsIHN0cmluZ3NfanNfMS5oYXNoRXZlbnRLZXkpKHRoaXMuY2xpZW50W1wiZXZlbnRLZXlcIl0pO1xuICAgIH1cbiAgICAvLyBoYXNoZWRTaWduaW5nS2V5IGNyZWF0ZXMgYSBzaGEyNTYgY2hlY2tzdW0gb2YgdGhlIHNpZ25pbmcga2V5IHdpdGggdGhlXG4gICAgLy8gc2FtZSBzaWduaW5nIGtleSBwcmVmaXguXG4gICAgZ2V0IGhhc2hlZFNpZ25pbmdLZXkoKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduaW5nS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgc3RyaW5nc19qc18xLmhhc2hTaWduaW5nS2V5KSh0aGlzLnNpZ25pbmdLZXkpO1xuICAgIH1cbiAgICBnZXQgaGFzaGVkU2lnbmluZ0tleUZhbGxiYWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lnbmluZ0tleUZhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgc3RyaW5nc19qc18xLmhhc2hTaWduaW5nS2V5KSh0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBgYm9vbGVhbmAgcmVwcmVzZW50aW5nIHdoZXRoZXIgdGhpcyBoYW5kbGVyIHdpbGwgc3RyZWFtIHJlc3BvbnNlc1xuICAgICAqIG9yIG5vdC4gVGFrZXMgaW50byBhY2NvdW50IHRoZSB1c2VyJ3MgcHJlZmVyZW5jZSBhbmQgdGhlIHBsYXRmb3JtJ3NcbiAgICAgKiBjYXBhYmlsaXRpZXMuXG4gICAgICovXG4gICAgYXN5bmMgc2hvdWxkU3RyZWFtKGFjdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmF3UHJvYmUgPSBhd2FpdCBhY3Rpb25zLnF1ZXJ5U3RyaW5nV2l0aERlZmF1bHRzKFwidGVzdGluZyBmb3IgcHJvYmVcIiwgY29uc3RzX2pzXzEucXVlcnlLZXlzLlByb2JlKTtcbiAgICAgICAgaWYgKHJhd1Byb2JlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBtdXN0IGJlIGFibGUgdG8gc3RyZWFtIHJlc3BvbnNlcyB0byBjb250aW51ZS5cbiAgICAgICAgaWYgKCFhY3Rpb25zLnRyYW5zZm9ybVN0cmVhbWluZ1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzIGZvcmNlZCBzdHJlYW1pbmcsIHdlIHNob3VsZCBhbHdheXMgc3RyZWFtLlxuICAgICAgICBpZiAodGhpcy5zdHJlYW1pbmcgPT09IFwiZm9yY2VcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzIGFsbG93ZWQgc3RyZWFtaW5nLCB3ZSBzaG91bGQgc3RyZWFtIGlmIHRoZSBwbGF0Zm9ybVxuICAgICAgICAvLyBzdXBwb3J0cyBpdC5cbiAgICAgICAgcmV0dXJuICh0aGlzLnN0cmVhbWluZyA9PT0gXCJhbGxvd1wiICYmXG4gICAgICAgICAgICAoMCwgZW52X2pzXzEucGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZykodGhpcy5mcmFtZXdvcmtOYW1lLCB0aGlzLmVudikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBgY3JlYXRlSGFuZGxlcmAgc2hvdWxkIGJlIHVzZWQgdG8gcmV0dXJuIGEgdHlwZS1lcXVpdmFsZW50IHZlcnNpb24gb2YgdGhlXG4gICAgICogYGhhbmRsZXJgIHNwZWNpZmllZCBkdXJpbmcgaW5zdGFudGlhdGlvbi5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogLy8gbXktY3VzdG9tLWhhbmRsZXIudHNcbiAgICAgKiBpbXBvcnQge1xuICAgICAqICAgSW5uZ2VzdENvbW1IYW5kbGVyLFxuICAgICAqICAgdHlwZSBTZXJ2ZUhhbmRsZXJPcHRpb25zLFxuICAgICAqIH0gZnJvbSBcIi4vY29tcG9uZW50cy9Jbm5nZXN0Q29tbUhhbmRsZXJcIjtcbiAgICAgKlxuICAgICAqIGV4cG9ydCBjb25zdCBzZXJ2ZSA9IChvcHRpb25zOiBTZXJ2ZUhhbmRsZXJPcHRpb25zKSA9PiB7XG4gICAgICogICBjb25zdCBoYW5kbGVyID0gbmV3IElubmdlc3RDb21tSGFuZGxlcih7XG4gICAgICogICAgIGZyYW1ld29ya05hbWU6IFwibXktY3VzdG9tLWhhbmRsZXJcIixcbiAgICAgKiAgICAgLi4ub3B0aW9ucyxcbiAgICAgKiAgICAgaGFuZGxlcjogKHJlcTogUmVxdWVzdCkgPT4ge1xuICAgICAqICAgICAgIHJldHVybiB7XG4gICAgICogICAgICAgICBib2R5OiAoKSA9PiByZXEuanNvbigpLFxuICAgICAqICAgICAgICAgaGVhZGVyczogKGtleSkgPT4gcmVxLmhlYWRlcnMuZ2V0KGtleSksXG4gICAgICogICAgICAgICBtZXRob2Q6ICgpID0+IHJlcS5tZXRob2QsXG4gICAgICogICAgICAgICB1cmw6ICgpID0+IG5ldyBVUkwocmVxLnVybCwgYGh0dHBzOi8vJHtyZXEuaGVhZGVycy5nZXQoXCJob3N0XCIpIHx8IFwiXCJ9YCksXG4gICAgICogICAgICAgICB0cmFuc2Zvcm1SZXNwb25zZTogKHsgYm9keSwgc3RhdHVzLCBoZWFkZXJzIH0pID0+IHtcbiAgICAgKiAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShib2R5LCB7IHN0YXR1cywgaGVhZGVycyB9KTtcbiAgICAgKiAgICAgICAgIH0sXG4gICAgICogICAgICAgfTtcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgIH0pO1xuICAgICAqXG4gICAgICogICByZXR1cm4gaGFuZGxlci5jcmVhdGVIYW5kbGVyKCk7XG4gICAgICogfTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBjcmVhdGVIYW5kbGVyKCkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gYXN5bmMgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCB0aW1lciA9IG5ldyBTZXJ2ZXJUaW1pbmdfanNfMS5TZXJ2ZXJUaW1pbmcoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXNlZCBmb3IgdGVzdGluZywgYWxsb3cgc2V0dGluZyBhY3Rpb24gb3ZlcnJpZGVzIGV4dGVybmFsbHkgd2hlblxuICAgICAgICAgICAgICogY2FsbGluZyB0aGUgaGFuZGxlci4gQWx3YXlzIHNlYXJjaCB0aGUgZmluYWwgYXJndW1lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGxhc3RBcmcgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBjb25zdCBhY3Rpb25PdmVycmlkZXMgPSB0eXBlb2YgbGFzdEFyZyA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIGxhc3RBcmcgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICBcImFjdGlvbk92ZXJyaWRlc1wiIGluIGxhc3RBcmcgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgbGFzdEFyZ1tcImFjdGlvbk92ZXJyaWRlc1wiXSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgIGxhc3RBcmdbXCJhY3Rpb25PdmVycmlkZXNcIl0gIT09IG51bGxcbiAgICAgICAgICAgICAgICA/IGxhc3RBcmdbXCJhY3Rpb25PdmVycmlkZXNcIl1cbiAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSBwdXJwb3NlZnVsbHkgYGF3YWl0YCB0aGUgaGFuZGxlciwgYXMgaXQgY291bGQgYmUgZWl0aGVyIHN5bmMgb3JcbiAgICAgICAgICAgICAqIGFzeW5jLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCByYXdBY3Rpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoYXdhaXQgdGltZXJcbiAgICAgICAgICAgICAgICAud3JhcChcImhhbmRsZXJcIiwgKCkgPT4gdGhpcy5oYW5kbGVyKC4uLmFyZ3MpKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoMCwgZXJyb3JzX2pzXzEucmV0aHJvd0Vycm9yKShcIlNlcnZlIGhhbmRsZXIgZmFpbGVkIHRvIHJ1blwiKSkpKSwgYWN0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFwIG92ZXIgZXZlcnkgYGFjdGlvbmAgaW4gYHJhd0FjdGlvbnNgIGFuZCBjcmVhdGUgYSBuZXcgYGFjdGlvbnNgXG4gICAgICAgICAgICAgKiBvYmplY3Qgd2hlcmUgZWFjaCBmdW5jdGlvbiBpcyBzYWZlbHkgcHJvbWlzaWZpZWQgd2l0aCBlYWNoIGFjY2Vzc1xuICAgICAgICAgICAgICogcmVxdWlyaW5nIGEgcmVhc29uLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoaXMgaGVscHMgdXMgcHJvdmlkZSBoaWdoIHF1YWxpdHkgZXJyb3JzIGFib3V0IHdoYXQncyBnb2luZyB3cm9uZyBmb3JcbiAgICAgICAgICAgICAqIGVhY2ggYWNjZXNzIHdpdGhvdXQgaGF2aW5nIHRvIHdyYXAgZXZlcnkgYWNjZXNzIGluIGEgdHJ5L2NhdGNoLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBwcm9taXNpZmllZEFjdGlvbnMgPSBPYmplY3QuZW50cmllcyhyYXdBY3Rpb25zKS5yZWR1Y2UoKGFjYywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW2tleV06IChyZWFzb24sIC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyck1lc3NhZ2UgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYEZhaWxlZCBjYWxsaW5nIFxcYCR7a2V5fVxcYCBmcm9tIHNlcnZlIGhhbmRsZXJgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKEJvb2xlYW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCIgd2hlbiBcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmbiA9ICgpID0+IHZhbHVlKC4uLmFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICgwLCBwcm9taXNlc19qc18xLnJ1bkFzUHJvbWlzZSkoZm4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgwLCBlcnJvcnNfanNfMS5yZXRocm93RXJyb3IpKGVyck1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IH0pO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBNYXBwZWQgcHJvbWlzaWZpZWQgaGFuZGxlcnMgZnJvbSB1c2VybGFuZCBgc2VydmUoKWAgZnVuY3Rpb24gbWl4ZWQgaW5cbiAgICAgICAgICAgICAqIHdpdGggc29tZSBoZWxwZXJzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBhY3Rpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByb21pc2lmaWVkQWN0aW9ucyksIHsgcXVlcnlTdHJpbmdXaXRoRGVmYXVsdHM6IGFzeW5jIChyZWFzb24sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVybCA9IGF3YWl0IGFjdGlvbnMudXJsKHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IChhd2FpdCAoKF9hID0gYWN0aW9ucy5xdWVyeVN0cmluZykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYWN0aW9ucywgcmVhc29uLCBrZXksIHVybCkpKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5nZXQoa2V5KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICAgICAgICAgIH0gfSksIGFjdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgICAgICBjb25zdCBbZW52LCBleHBlY3RlZFNlcnZlcktpbmRdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIChfYSA9IGFjdGlvbnMuZW52KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChhY3Rpb25zLCBcInN0YXJ0aW5nIHRvIGhhbmRsZSByZXF1ZXN0XCIpLFxuICAgICAgICAgICAgICAgIGFjdGlvbnMuaGVhZGVycyhcImNoZWNraW5nIGV4cGVjdGVkIHNlcnZlciBraW5kXCIsIGNvbnN0c19qc18xLmhlYWRlcktleXMuSW5uZ2VzdFNlcnZlcktpbmQpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAvLyBBbHdheXMgbWFrZSBzdXJlIHRvIG1lcmdlIHdoYXRldmVyIGVudiB3ZSd2ZSBiZWVuIGdpdmVuIHdpdGhcbiAgICAgICAgICAgIC8vIGBwcm9jZXNzLmVudmA7IHNvbWUgcGxhdGZvcm1zIG1heSBub3QgcHJvdmlkZSBhbGwgdGhlIG5lY2Vzc2FyeVxuICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgdmFyaWFibGVzIG9yIG1heSB1c2UgdHdvIHNvdXJjZXMuXG4gICAgICAgICAgICB0aGlzLmVudiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKDAsIGVudl9qc18xLmFsbFByb2Nlc3NFbnYpKCkpLCBlbnYpO1xuICAgICAgICAgICAgY29uc3QgZ2V0SW5uZ2VzdEhlYWRlcnMgPSAoKSA9PiAoMCwgZW52X2pzXzEuaW5uZ2VzdEhlYWRlcnMpKHtcbiAgICAgICAgICAgICAgICBlbnY6IHRoaXMuZW52LFxuICAgICAgICAgICAgICAgIGZyYW1ld29yazogdGhpcy5mcmFtZXdvcmtOYW1lLFxuICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRTZXJ2ZXJLaW5kOiBleHBlY3RlZFNlcnZlcktpbmQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIGV4dHJhczoge1xuICAgICAgICAgICAgICAgICAgICBcIlNlcnZlci1UaW1pbmdcIjogdGltZXIuZ2V0SGVhZGVyKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYXNzdW1lZE1vZGUgPSAoMCwgZW52X2pzXzEuZ2V0TW9kZSkoeyBlbnY6IHRoaXMuZW52LCBjbGllbnQ6IHRoaXMuY2xpZW50IH0pO1xuICAgICAgICAgICAgaWYgKGFzc3VtZWRNb2RlLmlzRXhwbGljaXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlID0gYXNzdW1lZE1vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXJ2ZUlzUHJvZCA9IGF3YWl0ICgoX2IgPSBhY3Rpb25zLmlzUHJvZHVjdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoYWN0aW9ucywgXCJzdGFydGluZyB0byBoYW5kbGUgcmVxdWVzdFwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZXJ2ZUlzUHJvZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG5ldyBlbnZfanNfMS5Nb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IHNlcnZlSXNQcm9kID8gXCJjbG91ZFwiIDogXCJkZXZcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXhwbGljaXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSBhc3N1bWVkTW9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwc2VydEtleXNGcm9tRW52KCk7XG4gICAgICAgICAgICBjb25zdCBtZXRob2RQID0gYWN0aW9ucy5tZXRob2QoXCJzdGFydGluZyB0byBoYW5kbGUgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlclByb21pc2VzID0gW1xuICAgICAgICAgICAgICAgIGNvbnN0c19qc18xLmhlYWRlcktleXMuVHJhY2VQYXJlbnQsXG4gICAgICAgICAgICAgICAgY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5UcmFjZVN0YXRlLFxuICAgICAgICAgICAgXS5tYXAoYXN5bmMgKGhlYWRlcikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgYWN0aW9ucy5oZWFkZXJzKGBmZXRjaGluZyAke2hlYWRlcn0gZm9yIGZvcndhcmRpbmdgLCBoZWFkZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGhlYWRlciwgdmFsdWUgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29udGVudExlbmd0aCA9IGF3YWl0IGFjdGlvbnNcbiAgICAgICAgICAgICAgICAuaGVhZGVycyhcImNoZWNraW5nIHNpZ25hdHVyZSBmb3IgcmVxdWVzdFwiLCBjb25zdHNfanNfMS5oZWFkZXJLZXlzLkNvbnRlbnRMZW5ndGgpXG4gICAgICAgICAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VJbnQodmFsdWUsIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgY29uc3QgW3NpZ25hdHVyZSwgbWV0aG9kLCBib2R5XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICBhY3Rpb25zXG4gICAgICAgICAgICAgICAgICAgIC5oZWFkZXJzKFwiY2hlY2tpbmcgc2lnbmF0dXJlIGZvciByZXF1ZXN0XCIsIGNvbnN0c19qc18xLmhlYWRlcktleXMuU2lnbmF0dXJlKVxuICAgICAgICAgICAgICAgICAgICAudGhlbigoaGVhZGVyU2lnbmF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZWFkZXJTaWduYXR1cmUgIT09IG51bGwgJiYgaGVhZGVyU2lnbmF0dXJlICE9PSB2b2lkIDAgPyBoZWFkZXJTaWduYXR1cmUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgbWV0aG9kUCxcbiAgICAgICAgICAgICAgICBtZXRob2RQLnRoZW4oKG1ldGhvZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcIlBPU1RcIiB8fCBtZXRob2QgPT09IFwiUFVUXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldHVybiBlbXB0eSBzdHJpbmcgYmVjYXVzZSByZXEuanNvbigpIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9ucy5ib2R5KGBjaGVja2luZyBib2R5IGZvciByZXF1ZXN0IHNpZ25pbmcgYXMgbWV0aG9kIGlzICR7bWV0aG9kfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmVWYWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZVNpZ25hdHVyZShzaWduYXR1cmUsIGJvZHkpO1xuICAgICAgICAgICAgY29uc3QgaGVhZGVyc1RvRm9yd2FyZFAgPSBQcm9taXNlLmFsbChoZWFkZXJQcm9taXNlcykudGhlbigoZmV0Y2hlZEhlYWRlcnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hlZEhlYWRlcnMucmVkdWNlKChhY2MsIHsgaGVhZGVyLCB2YWx1ZSB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjW2hlYWRlcl0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uUmVzID0gdGltZXIud3JhcChcImFjdGlvblwiLCAoKSA9PiB0aGlzLmhhbmRsZUFjdGlvbih7XG4gICAgICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICAgICAgICB0aW1lcixcbiAgICAgICAgICAgICAgICBnZXRJbm5nZXN0SGVhZGVycyxcbiAgICAgICAgICAgICAgICByZXFBcmdzOiBhcmdzLFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZVZhbGlkYXRpb24sXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IGhlYWRlcnNUb0ZvcndhcmRQLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBQcmVwYXJlcyBhbiBhY3Rpb24gcmVzcG9uc2UgYnkgbWVyZ2luZyByZXR1cm5lZCBkYXRhIHRvIHByb3ZpZGVcbiAgICAgICAgICAgICAqIHRyYWlsaW5nIGluZm9ybWF0aW9uIHN1Y2ggYXMgYFNlcnZlci1UaW1pbmdgIGhlYWRlcnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSXQgc2hvdWxkIGFsd2F5cyBwcmlvcml0aXplIHRoZSBoZWFkZXJzIHJldHVybmVkIGJ5IHRoZSBhY3Rpb24sIGFzIHRoZXlcbiAgICAgICAgICAgICAqIG1heSBjb250YWluIGltcG9ydGFudCBpbmZvcm1hdGlvbiBzdWNoIGFzIGBDb250ZW50LVR5cGVgLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlQWN0aW9uUmVzID0gYXN5bmMgKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZ2V0SW5uZ2VzdEhlYWRlcnMoKSksIChhd2FpdCBoZWFkZXJzVG9Gb3J3YXJkUCkpLCByZXMuaGVhZGVycyksIChyZXMudmVyc2lvbiA9PT0gbnVsbFxuICAgICAgICAgICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgW2NvbnN0c19qc18xLmhlYWRlcktleXMuUmVxdWVzdFZlcnNpb25dOiAoKF9hID0gcmVzLnZlcnNpb24pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IElubmdlc3RFeGVjdXRpb25fanNfMS5QUkVGRVJSRURfRVhFQ1VUSU9OX1ZFUlNJT04pLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBsZXQgc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZSA9IGF3YWl0IHNpZ25hdHVyZVZhbGlkYXRpb24udGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5zdWNjZXNzIHx8ICFyZXN1bHQua2V5VXNlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSZXNwb25zZVNpZ25hdHVyZShyZXN1bHQua2V5VXNlZCwgcmVzLmJvZHkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSBmYWlsIHRvIHNpZ24sIHJldHVuIGEgNTAwIHdpdGggdGhlIGVycm9yLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXMpLCB7IGhlYWRlcnMsIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSgoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKGVycikpLCBzdGF0dXM6IDUwMCB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW2NvbnN0c19qc18xLmhlYWRlcktleXMuU2lnbmF0dXJlXSA9IHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzKSwgeyBoZWFkZXJzIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChhd2FpdCB0aGlzLnNob3VsZFN0cmVhbShhY3Rpb25zKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGhvZCA9IGF3YWl0IGFjdGlvbnMubWV0aG9kKFwic3RhcnRpbmcgc3RyZWFtaW5nIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RyZWFtLCBmaW5hbGl6ZSB9ID0gYXdhaXQgKDAsIHN0cmVhbV9qc18xLmNyZWF0ZVN0cmVhbSkoKTtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIEVycm9ycyBhcmUgaGFuZGxlZCBieSBgaGFuZGxlQWN0aW9uYCBoZXJlIHRvIGVuc3VyZSB0aGF0IGFuXG4gICAgICAgICAgICAgICAgICAgICAqIGFwcHJvcHJpYXRlIHJlc3BvbnNlIGlzIGFsd2F5cyBnaXZlbi5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIHZvaWQgYWN0aW9uUmVzLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplKHByZXBhcmVBY3Rpb25SZXMocmVzKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGltZXIud3JhcChcInJlc1wiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gYWN0aW9ucy50cmFuc2Zvcm1TdHJlYW1pbmdSZXNwb25zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwoYWN0aW9ucywgXCJzdGFydGluZyBzdHJlYW1pbmcgcmVzcG9uc2VcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogMjAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGdldElubmdlc3RIZWFkZXJzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRpbWVyLndyYXAoXCJyZXNcIiwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb25SZXMudGhlbihwcmVwYXJlQWN0aW9uUmVzKS50aGVuKChhY3Rpb25SZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb25zLnRyYW5zZm9ybVJlc3BvbnNlKFwic2VuZGluZyBiYWNrIHJlc3BvbnNlXCIsIGFjdGlvblJlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbWUgcGxhdGZvcm1zIGNoZWNrIChhdCBydW50aW1lKSB0aGUgbGVuZ3RoIG9mIHRoZSBmdW5jdGlvbiBiZWluZyB1c2VkXG4gICAgICAgICAqIHRvIGhhbmRsZSBhbiBlbmRwb2ludC4gSWYgdGhpcyBpcyBhIHZhcmlhZGljIGZ1bmN0aW9uLCBpdCB3aWxsIGZhaWwgdGhhdFxuICAgICAgICAgKiBjaGVjay5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlcmVmb3JlLCB3ZSBleHBlY3QgdGhlIGFyZ3VtZW50cyBhY2NlcHRlZCB0byBiZSB0aGUgc2FtZSBsZW5ndGggYXMgdGhlXG4gICAgICAgICAqIGBoYW5kbGVyYCBmdW5jdGlvbiBwYXNzZWQgaW50ZXJuYWxseS5cbiAgICAgICAgICpcbiAgICAgICAgICogV2UgYWxzbyBzZXQgYSBuYW1lIHRvIGF2b2lkIGEgY29tbW9uIHVzZWxlc3MgbmFtZSBpbiB0cmFjaW5nIHN1Y2ggYXNcbiAgICAgICAgICogYFwiYW5vbnltb3VzXCJgIG9yIGBcImJvdW5kIGZ1bmN0aW9uXCJgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS1qYXZhc2NyaXB0L2lzc3Vlcy8zMjg0XG4gICAgICAgICAqL1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhoYW5kbGVyLCB7XG4gICAgICAgICAgICBuYW1lOiB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiSW5uZ2VzdEhhbmRsZXJcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZW5ndGg6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5oYW5kbGVyLmxlbmd0aCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlcjtcbiAgICB9XG4gICAgZ2V0IG1vZGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tb2RlO1xuICAgIH1cbiAgICBzZXQgbW9kZShtKSB7XG4gICAgICAgIHRoaXMuX21vZGUgPSBtO1xuICAgICAgICBpZiAobSkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnRbXCJtb2RlXCJdID0gbTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIHNldCBvZiBmdW5jdGlvbnMgdG8gY2hlY2sgaWYgYW4gYWN0aW9uIGlzIGF2YWlsYWJsZSBmcm9tIHRoZVxuICAgICAqIGluc3RhbmNlJ3MgaGFuZGxlciwgZW5hY3QgYW55IGFjdGlvbiB0aGF0IGlzIGZvdW5kLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGZldGNoIHZhcnlpbmcgcGF5bG9hZHMgb2YgZGF0YSwgYnV0IHVsdGltYXRlbHkgaXMgdGhlIHBsYWNlXG4gICAgICogd2hlcmUgX2RlY2lzaW9uc18gYXJlIG1hZGUgcmVnYXJkaW5nIGZ1bmN0aW9uYWxpdHkuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgd2UgZmluZCB0aGF0IHdlIHNob3VsZCBiZSB2aWV3aW5nIHRoZSBVSSwgdGhpcyBmdW5jdGlvblxuICAgICAqIHdpbGwgZGVjaWRlIHdoZXRoZXIgdGhlIFVJIHNob3VsZCBiZSB2aXNpYmxlIGJhc2VkIG9uIHRoZSBwYXlsb2FkIGl0IGhhc1xuICAgICAqIGZvdW5kIChlLmcuIGVudiB2YXJzLCBvcHRpb25zLCBldGMpLlxuICAgICAqL1xuICAgIGFzeW5jIGhhbmRsZUFjdGlvbih7IGFjdGlvbnMsIHRpbWVyLCBnZXRJbm5nZXN0SGVhZGVycywgcmVxQXJncywgc2lnbmF0dXJlVmFsaWRhdGlvbiwgYm9keSwgbWV0aG9kLCBoZWFkZXJzLCB9KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gVGhpcyBpcyB3aGVuIHRoZSByZXF1ZXN0IGJvZHkgaXMgY29tcGxldGVseSBtaXNzaW5nOyBpdCBkb2VzIG5vdFxuICAgICAgICAvLyBpbmNsdWRlIGFuIGVtcHR5IGJvZHkuIFRoaXMgY29tbW9ubHkgaGFwcGVucyB3aGVuIHRoZSBIVFRQIGZyYW1ld29ya1xuICAgICAgICAvLyBkb2Vzbid0IGhhdmUgYm9keSBwYXJzaW5nIG1pZGRsZXdhcmUuXG4gICAgICAgIGNvbnN0IGlzTWlzc2luZ0JvZHkgPSBib2R5ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgdXJsID0gYXdhaXQgYWN0aW9ucy51cmwoXCJzdGFydGluZyB0byBoYW5kbGUgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiUE9TVFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTWlzc2luZ0JvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2coXCJlcnJvclwiLCBcIk1pc3NpbmcgYm9keSB3aGVuIGV4ZWN1dGluZywgcG9zc2libHkgZHVlIHRvIG1pc3NpbmcgcmVxdWVzdCBib2R5IG1pZGRsZXdhcmVcIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShuZXcgRXJyb3IoXCJNaXNzaW5nIHJlcXVlc3QgYm9keSB3aGVuIGV4ZWN1dGluZywgcG9zc2libHkgZHVlIHRvIG1pc3NpbmcgcmVxdWVzdCBib2R5IG1pZGRsZXdhcmVcIikpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IGF3YWl0IHNpZ25hdHVyZVZhbGlkYXRpb247XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSgoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKHZhbGlkYXRpb25SZXN1bHQuZXJyKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd1Byb2JlID0gYXdhaXQgYWN0aW9ucy5xdWVyeVN0cmluZ1dpdGhEZWZhdWx0cyhcInRlc3RpbmcgZm9yIHByb2JlXCIsIGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5Qcm9iZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJhd1Byb2JlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2JlID0gKDAsIGVudW1fanNfMS5lbnVtRnJvbVZhbHVlKShjb25zdHNfanNfMS5wcm9iZSwgcmF3UHJvYmUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXByb2JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBoZXJlLCB3ZSd2ZSByZWNlaXZlZCBhIHByb2JlIHRoYXQgd2UgZG9uJ3QgcmVjb2duaXplLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFpbC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSgoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKG5ldyBFcnJvcihgVW5rbm93biBwcm9iZSBcIiR7cmF3UHJvYmV9XCJgKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUHJvdmlkZSBhY3Rpb25zIGZvciBldmVyeSBwcm9iZSBhdmFpbGFibGUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2JlQWN0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFtjb25zdHNfanNfMS5wcm9iZS5UcnVzdF06ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9iZUFjdGlvbnNbcHJvYmVdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGZuSWQgPSBhd2FpdCBhY3Rpb25zLnF1ZXJ5U3RyaW5nV2l0aERlZmF1bHRzKFwicHJvY2Vzc2luZyBydW4gcmVxdWVzdFwiLCBjb25zdHNfanNfMS5xdWVyeUtleXMuRm5JZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmbklkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gUHJldHR5RXJyb3JcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZnVuY3Rpb24gSUQgZm91bmQgaW4gcmVxdWVzdFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcElkID0gKGF3YWl0IGFjdGlvbnMucXVlcnlTdHJpbmdXaXRoRGVmYXVsdHMoXCJwcm9jZXNzaW5nIHJ1biByZXF1ZXN0XCIsIGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5TdGVwSWQpKSB8fCBudWxsO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmVyc2lvbiwgcmVzdWx0IH0gPSB0aGlzLnJ1blN0ZXAoe1xuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbklkOiBmbklkLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBib2R5LFxuICAgICAgICAgICAgICAgICAgICBzdGVwSWQsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVyLFxuICAgICAgICAgICAgICAgICAgICByZXFBcmdzLFxuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBhd2FpdCBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBPdXRwdXQgPSBhd2FpdCByZXN1bHQ7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRnVuY3Rpb25zIGNhbiByZXR1cm4gYHVuZGVmaW5lZGAsIGJ1dCB3ZSdsbCBhbHdheXMgY29udmVydCB0aGlzIHRvXG4gICAgICAgICAgICAgICAgICogYG51bGxgLCBhcyB0aGlzIGlzIGFwcHJvcHJpYXRlbHkgc2VyaWFsaXphYmxlIGJ5IEpTT04uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3Qgb3BEYXRhVW5kZWZpbmVkVG9OdWxsID0gKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG9wLmRhdGEgPSAoMCwgZnVuY3Rpb25zX2pzXzEudW5kZWZpbmVkVG9OdWxsKShvcC5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0SGFuZGxlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIFwiZnVuY3Rpb24tcmVqZWN0ZWRcIjogKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHJlc3VsdC5yZXRyaWFibGUgPyA1MDAgOiA0MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLCBbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Ob1JldHJ5XTogcmVzdWx0LnJldHJpYWJsZSA/IFwiZmFsc2VcIiA6IFwidHJ1ZVwiIH0sICh0eXBlb2YgcmVzdWx0LnJldHJpYWJsZSA9PT0gXCJzdHJpbmdcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgW2NvbnN0c19qc18xLmhlYWRlcktleXMuUmV0cnlBZnRlcl06IHJlc3VsdC5yZXRyaWFibGUgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKCgwLCBmdW5jdGlvbnNfanNfMS51bmRlZmluZWRUb051bGwpKHJlc3VsdC5lcnJvcikpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uLXJlc29sdmVkXCI6IChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSgoMCwgZnVuY3Rpb25zX2pzXzEudW5kZWZpbmVkVG9OdWxsKShyZXN1bHQuZGF0YSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcInN0ZXAtbm90LWZvdW5kXCI6IChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbnN0c19qc18xLmhlYWRlcktleXMuTm9SZXRyeV06IFwiZmFsc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBgQ291bGQgbm90IGZpbmQgc3RlcCBcIiR7cmVzdWx0LnN0ZXAuZGlzcGxheU5hbWUgfHwgcmVzdWx0LnN0ZXAuaWR9XCIgdG8gcnVuOyB0aW1lZCBvdXRgLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcInN0ZXAtcmFuXCI6IChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXAgPSBvcERhdGFVbmRlZmluZWRUb051bGwocmVzdWx0LnN0ZXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwNixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBPYmplY3QuYXNzaWduKHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSwgKHR5cGVvZiByZXN1bHQucmV0cmlhYmxlICE9PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gT2JqZWN0LmFzc2lnbih7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLk5vUmV0cnldOiByZXN1bHQucmV0cmlhYmxlID8gXCJmYWxzZVwiIDogXCJ0cnVlXCIgfSwgKHR5cGVvZiByZXN1bHQucmV0cmlhYmxlID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgW2NvbnN0c19qc18xLmhlYWRlcktleXMuUmV0cnlBZnRlcl06IHJlc3VsdC5yZXRyaWFibGUgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSkpIDoge30pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkoW3N0ZXBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJzdGVwcy1mb3VuZFwiOiAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGVwcyA9IHJlc3VsdC5zdGVwcy5tYXAob3BEYXRhVW5kZWZpbmVkVG9OdWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KShzdGVwcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gcmVzdWx0SGFuZGxlcnNbc3RlcE91dHB1dC50eXBlXTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgaGFuZGxlcihzdGVwT3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvZyhcImVycm9yXCIsIFwiRXJyb3IgaGFuZGxpbmcgZXhlY3V0aW9uIHJlc3VsdFwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBmZWVscyBoYWNreSwgc28gd2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgaXQgbm90IGhhY2t5LlxuICAgICAgICAgICAgY29uc3QgZW52ID0gKF9hID0gZ2V0SW5uZ2VzdEhlYWRlcnMoKVtjb25zdHNfanNfMS5oZWFkZXJLZXlzLkVudmlyb25tZW50XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IDIwMCxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKGF3YWl0IHRoaXMuaW50cm9zcGVjdGlvbkJvZHkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZVZhbGlkYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJQVVRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtkZXBsb3lJZCwgaW5CYW5kU3luY1JlcXVlc3RlZF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5xdWVyeVN0cmluZ1dpdGhEZWZhdWx0cyhcInByb2Nlc3NpbmcgZGVwbG95bWVudCByZXF1ZXN0XCIsIGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5EZXBsb3lJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChkZXBsb3lJZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcGxveUlkID09PSBcInVuZGVmaW5lZFwiID8gdW5kZWZpbmVkIDogZGVwbG95SWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKDAsIGVudl9qc18xLnBhcnNlQXNCb29sZWFuKSh0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RBbGxvd0luQmFuZFN5bmNdKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChhbGxvd0luQmFuZFN5bmMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbGxvd0luQmFuZFN5bmMgIT09IHVuZGVmaW5lZCAmJiAhYWxsb3dJbkJhbmRTeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnN0c19qc18xLnN5bmNLaW5kLk91dE9mQmFuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb25zLmhlYWRlcnMoXCJwcm9jZXNzaW5nIGRlcGxveW1lbnQgcmVxdWVzdFwiLCBjb25zdHNfanNfMS5oZWFkZXJLZXlzLklubmdlc3RTeW5jS2luZCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAudGhlbigoa2luZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGtpbmQgPT09IGNvbnN0c19qc18xLnN5bmNLaW5kLkluQmFuZDtcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgaWYgKGluQmFuZFN5bmNSZXF1ZXN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTWlzc2luZ0JvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgXCJNaXNzaW5nIGJvZHkgd2hlbiBzeW5jaW5nLCBwb3NzaWJseSBkdWUgdG8gbWlzc2luZyByZXF1ZXN0IGJvZHkgbWlkZGxld2FyZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSgoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKG5ldyBFcnJvcihcIk1pc3NpbmcgcmVxdWVzdCBib2R5IHdoZW4gc3luY2luZywgcG9zc2libHkgZHVlIHRvIG1pc3NpbmcgcmVxdWVzdCBib2R5IG1pZGRsZXdhcmVcIikpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRpb24gY2FuIGJlIHN1Y2Nlc3NmdWwgaWYgd2UncmUgaW4gZGV2IG1vZGUgYW5kIGRpZCBub3RcbiAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgdmFsaWRhdGUgYSBrZXkuIEluIHRoaXMgY2FzZSwgYWxzbyBjaGVjayB0aGF0IHdlIGRpZCBpbmRlZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIGEgcGFydGljdWxhciBrZXkgdG8gdmFsaWRhdGUuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ0NoZWNrID0gYXdhaXQgc2lnbmF0dXJlVmFsaWRhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaWdDaGVjay5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogNDAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwic2lnX3ZlcmlmaWNhdGlvbl9mYWlsZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSB0eXBlc19qc18xLmluQmFuZFN5bmNSZXF1ZXN0Qm9keVNjaGVtYS5zYWZlUGFyc2UoYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiA0MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3JlcXVlc3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogcmVzLmVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgY2FuIHRydXN0IHRoZSBVUkwgaGVyZSBiZWNhdXNlIGl0J3MgY29taW5nIGZyb21cbiAgICAgICAgICAgICAgICAgICAgLy8gc2lnbmF0dXJlLXZlcmlmaWVkIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHRoaXMucmVxVXJsKG5ldyBVUkwocmVzLmRhdGEudXJsKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgc2hvdWxkIGJlIGFuIGluLWJhbmQgc3luY1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwQm9keSA9IGF3YWl0IHRoaXMuaW5CYW5kUmVnaXN0ZXJCb2R5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXBsb3lJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudixcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hdHVyZVZhbGlkYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiAoMCwgc3RyaW5nc19qc18xLnN0cmluZ2lmeSkocmVzcEJvZHkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLklubmdlc3RTeW5jS2luZF06IGNvbnN0c19qc18xLnN5bmNLaW5kLkluQmFuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGhlcmUsIHRoaXMgaXMgYSBsZWdhY3kgb3V0LW9mLWJhbmQgc3luY1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc3RhdHVzLCBtZXNzYWdlLCBtb2RpZmllZCB9ID0gYXdhaXQgdGhpcy5yZWdpc3Rlcih0aGlzLnJlcVVybCh1cmwpLCBkZXBsb3lJZCwgZ2V0SW5uZ2VzdEhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgYm9keTogKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKHsgbWVzc2FnZSwgbW9kaWZpZWQgfSksXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgW2NvbnN0c19qc18xLmhlYWRlcktleXMuSW5uZ2VzdFN5bmNLaW5kXTogY29uc3RzX2pzXzEuc3luY0tpbmQuT3V0T2ZCYW5kLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KShPYmplY3QuYXNzaWduKHsgdHlwZTogXCJpbnRlcm5hbFwiIH0sICgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikoZXJyKSkpLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IDQwNSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIk5vIGFjdGlvbiBmb3VuZDsgcmVxdWVzdCB3YXMgbGlrZWx5IG5vdCBQT1NULCBQVVQsIG9yIEdFVFwiLFxuICAgICAgICAgICAgICAgIG1vZGU6IHRoaXMuX21vZGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgdmVyc2lvbjogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBydW5TdGVwKHsgZnVuY3Rpb25JZCwgc3RlcElkLCBkYXRhLCB0aW1lciwgcmVxQXJncywgaGVhZGVycywgfSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBmbiA9IHRoaXMuZm5zW2Z1bmN0aW9uSWRdO1xuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIGZ1bmN0aW9uIHdpdGggSUQgXCIke2Z1bmN0aW9uSWR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbW1lZGlhdGVGbkRhdGEgPSAoMCwgZnVuY3Rpb25zX2pzXzEucGFyc2VGbkRhdGEpKGRhdGEpO1xuICAgICAgICBsZXQgeyB2ZXJzaW9uIH0gPSBpbW1lZGlhdGVGbkRhdGE7XG4gICAgICAgIC8vIEhhbmRsZSBvcHRpbmcgaW4gdG8gb3B0aW1pemVkIHBhcmFsbGVsaXNtIGluIHYzLlxuICAgICAgICBpZiAodmVyc2lvbiA9PT0gSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjEgJiZcbiAgICAgICAgICAgICgoX2IgPSAoX2EgPSBmbi5mbilbXCJzaG91bGRPcHRpbWl6ZVBhcmFsbGVsaXNtXCJdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKSB7XG4gICAgICAgICAgICB2ZXJzaW9uID0gSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gKDAsIHByb21pc2VzX2pzXzEucnVuQXNQcm9taXNlKShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbnlGbkRhdGEgPSBhd2FpdCAoMCwgZnVuY3Rpb25zX2pzXzEuZmV0Y2hBbGxGbkRhdGEpKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBpbW1lZGlhdGVGbkRhdGEsXG4gICAgICAgICAgICAgICAgYXBpOiB0aGlzLmNsaWVudFtcImlubmdlc3RBcGlcIl0sXG4gICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFhbnlGbkRhdGEub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYW55Rm5EYXRhLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGlvblN0YXJ0ZXJzID0gKChzKSA9PiBzKSh7XG4gICAgICAgICAgICAgICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYwXTogKHsgZXZlbnQsIGV2ZW50cywgc3RlcHMsIGN0eCwgdmVyc2lvbiB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGVwU3RhdGUgPSBPYmplY3QuZW50cmllcyhzdGVwcyAhPT0gbnVsbCAmJiBzdGVwcyAhPT0gdm9pZCAwID8gc3RlcHMgOiB7fSkucmVkdWNlKChhY2MsIFtpZCwgZGF0YV0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpZF06IHsgaWQsIGRhdGEgfSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmVyc2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxPcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50OiB0aGlzLmNsaWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5JZDogKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5ydW5faWQpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50czogZXZlbnRzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5JZDogKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5ydW5faWQpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGVtcHQ6IChfYSA9IGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5hdHRlbXB0KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RlZFJ1blN0ZXA6IHN0ZXBJZCA9PT0gXCJzdGVwXCIgPyB1bmRlZmluZWQgOiBzdGVwSWQgfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzRmFpbHVyZUhhbmRsZXI6IGZuLm9uRmFpbHVyZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwQ29tcGxldGlvbk9yZGVyOiAoX2MgPSAoX2IgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguc3RhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFjaykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxQXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMV06ICh7IGV2ZW50LCBldmVudHMsIHN0ZXBzLCBjdHgsIHZlcnNpb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcFN0YXRlID0gT2JqZWN0LmVudHJpZXMoc3RlcHMgIT09IG51bGwgJiYgc3RlcHMgIT09IHZvaWQgMCA/IHN0ZXBzIDoge30pLnJlZHVjZSgoYWNjLCBbaWQsIHJlc3VsdF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW2lkXTogcmVzdWx0LnR5cGUgPT09IFwiZGF0YVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpZCwgZGF0YTogcmVzdWx0LmRhdGEgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlc3VsdC50eXBlID09PSBcImlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQsIGlucHV0OiByZXN1bHQuaW5wdXQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGlkLCBlcnJvcjogcmVzdWx0LmVycm9yIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQ6IChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucnVuX2lkKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IGV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQ6IChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucnVuX2lkKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiAoX2EgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguYXR0ZW1wdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRSdW5TdGVwOiBzdGVwSWQgPT09IFwic3RlcFwiID8gdW5kZWZpbmVkIDogc3RlcElkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZhaWx1cmVIYW5kbGVyOiBmbi5vbkZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUltbWVkaWF0ZUV4ZWN1dGlvbjogY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmRpc2FibGVfaW1tZWRpYXRlX2V4ZWN1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwQ29tcGxldGlvbk9yZGVyOiAoX2MgPSAoX2IgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguc3RhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFjaykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxQXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMl06ICh7IGV2ZW50LCBldmVudHMsIHN0ZXBzLCBjdHgsIHZlcnNpb24gfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcFN0YXRlID0gT2JqZWN0LmVudHJpZXMoc3RlcHMgIT09IG51bGwgJiYgc3RlcHMgIT09IHZvaWQgMCA/IHN0ZXBzIDoge30pLnJlZHVjZSgoYWNjLCBbaWQsIHJlc3VsdF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGFjYyksIHsgW2lkXTogcmVzdWx0LnR5cGUgPT09IFwiZGF0YVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBpZCwgZGF0YTogcmVzdWx0LmRhdGEgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlc3VsdC50eXBlID09PSBcImlucHV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgaWQsIGlucHV0OiByZXN1bHQuaW5wdXQgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGlkLCBlcnJvcjogcmVzdWx0LmVycm9yIH0gfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcnNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsT3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudDogdGhpcy5jbGllbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQ6IChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucnVuX2lkKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudHM6IGV2ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnVuSWQ6IChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHgucnVuX2lkKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRlbXB0OiAoX2EgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguYXR0ZW1wdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXBTdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRSdW5TdGVwOiBzdGVwSWQgPT09IFwic3RlcFwiID8gdW5kZWZpbmVkIDogc3RlcElkIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0ZhaWx1cmVIYW5kbGVyOiBmbi5vbkZhaWx1cmUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWJsZUltbWVkaWF0ZUV4ZWN1dGlvbjogY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmRpc2FibGVfaW1tZWRpYXRlX2V4ZWN1dGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwQ29tcGxldGlvbk9yZGVyOiAoX2MgPSAoX2IgPSBjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguc3RhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGFjaykgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxQXJncyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRpb25PcHRpb25zID0gYXdhaXQgZXhlY3V0aW9uU3RhcnRlcnNbdmVyc2lvbl0oYW55Rm5EYXRhLnZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBmbi5mbltcImNyZWF0ZUV4ZWN1dGlvblwiXShleGVjdXRpb25PcHRpb25zKS5zdGFydCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHsgdmVyc2lvbiwgcmVzdWx0IH07XG4gICAgfVxuICAgIGNvbmZpZ3ModXJsKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3MgPSBPYmplY3QudmFsdWVzKHRoaXMucmF3Rm5zKS5yZWR1Y2UoKGFjYywgZm4pID0+IFtcbiAgICAgICAgICAgIC4uLmFjYyxcbiAgICAgICAgICAgIC4uLmZuW1wiZ2V0Q29uZmlnXCJdKHsgYmFzZVVybDogdXJsLCBhcHBQcmVmaXg6IHRoaXMuaWQgfSksXG4gICAgICAgIF0sIFtdKTtcbiAgICAgICAgZm9yIChjb25zdCBjb25maWcgb2YgY29uZmlncykge1xuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSB0eXBlc19qc18xLmZ1bmN0aW9uQ29uZmlnU2NoZW1hLnNhZmVQYXJzZShjb25maWcpO1xuICAgICAgICAgICAgaWYgKCFjaGVjay5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gY2hlY2suZXJyb3IuZXJyb3JzLm1hcCgoZXJyKSA9PiBlcnIubWVzc2FnZSkuam9pbihcIjsgXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nKFwid2FyblwiLCBgQ29uZmlnIGludmFsaWQgZm9yIGZ1bmN0aW9uIFwiJHtjb25maWcuaWR9XCIgOiAke2Vycm9yc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIElubmdlc3Qgc2VydmUgZW5kcG9pbnQgVVJMIGdpdmVuIGEgcG90ZW50aWFsIGBwYXRoYCBhbmQgYGhvc3RgLlxuICAgICAqXG4gICAgICogV2lsbCBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgYHNlcnZlSG9zdGAgYW5kIGBzZXJ2ZVBhdGhgIGlmIHRoZXkgaGF2ZSBiZWVuXG4gICAgICogc2V0IHdoZW4gcmVnaXN0ZXJpbmcuXG4gICAgICovXG4gICAgcmVxVXJsKHVybCkge1xuICAgICAgICBsZXQgcmV0ID0gbmV3IFVSTCh1cmwpO1xuICAgICAgICBjb25zdCBzZXJ2ZUhvc3QgPSB0aGlzLnNlcnZlSG9zdCB8fCB0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTZXJ2ZUhvc3RdO1xuICAgICAgICBjb25zdCBzZXJ2ZVBhdGggPSB0aGlzLnNlcnZlUGF0aCB8fCB0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTZXJ2ZVBhdGhdO1xuICAgICAgICBpZiAoc2VydmVQYXRoKSB7XG4gICAgICAgICAgICByZXQucGF0aG5hbWUgPSBzZXJ2ZVBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlcnZlSG9zdCkge1xuICAgICAgICAgICAgcmV0ID0gbmV3IFVSTChyZXQucGF0aG5hbWUgKyByZXQuc2VhcmNoLCBzZXJ2ZUhvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIHJlZ2lzdGVyQm9keSh7IHVybCwgZGVwbG95SWQsIH0pIHtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIHVybDogdXJsLmhyZWYsXG4gICAgICAgICAgICBkZXBsb3lUeXBlOiBcInBpbmdcIixcbiAgICAgICAgICAgIGZyYW1ld29yazogdGhpcy5mcmFtZXdvcmtOYW1lLFxuICAgICAgICAgICAgYXBwTmFtZTogdGhpcy5pZCxcbiAgICAgICAgICAgIGZ1bmN0aW9uczogdGhpcy5jb25maWdzKHVybCksXG4gICAgICAgICAgICBzZGs6IGBqczp2JHt2ZXJzaW9uX2pzXzEudmVyc2lvbn1gLFxuICAgICAgICAgICAgdjogXCIwLjFcIixcbiAgICAgICAgICAgIGRlcGxveUlkOiBkZXBsb3lJZCB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgICAgICAgICB0cnVzdF9wcm9iZTogXCJ2MVwiLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Q6IFwidjFcIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhcHBWZXJzaW9uOiB0aGlzLmNsaWVudC5hcHBWZXJzaW9uLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYm9keTtcbiAgICB9XG4gICAgYXN5bmMgaW5CYW5kUmVnaXN0ZXJCb2R5KHsgYWN0aW9ucywgZGVwbG95SWQsIGVudiwgc2lnbmF0dXJlVmFsaWRhdGlvbiwgdXJsLCB9KSB7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyQm9keSA9IHRoaXMucmVnaXN0ZXJCb2R5KHsgZGVwbG95SWQsIHVybCB9KTtcbiAgICAgICAgY29uc3QgaW50cm9zcGVjdGlvbkJvZHkgPSBhd2FpdCB0aGlzLmludHJvc3BlY3Rpb25Cb2R5KHtcbiAgICAgICAgICAgIGFjdGlvbnMsXG4gICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICBzaWduYXR1cmVWYWxpZGF0aW9uLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgICAgIGFwcF9pZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGFwcFZlcnNpb246IHRoaXMuY2xpZW50LmFwcFZlcnNpb24sXG4gICAgICAgICAgICBjYXBhYmlsaXRpZXM6IHJlZ2lzdGVyQm9keS5jYXBhYmlsaXRpZXMsXG4gICAgICAgICAgICBlbnYsXG4gICAgICAgICAgICBmcmFtZXdvcms6IHJlZ2lzdGVyQm9keS5mcmFtZXdvcmssXG4gICAgICAgICAgICBmdW5jdGlvbnM6IHJlZ2lzdGVyQm9keS5mdW5jdGlvbnMsXG4gICAgICAgICAgICBpbnNwZWN0aW9uOiBpbnRyb3NwZWN0aW9uQm9keSxcbiAgICAgICAgICAgIHBsYXRmb3JtOiAoMCwgZW52X2pzXzEuZ2V0UGxhdGZvcm1OYW1lKShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBlbnZfanNfMS5hbGxQcm9jZXNzRW52KSgpKSwgdGhpcy5lbnYpKSxcbiAgICAgICAgICAgIHNka19hdXRob3I6IFwiaW5uZ2VzdFwiLFxuICAgICAgICAgICAgc2RrX2xhbmd1YWdlOiBcIlwiLFxuICAgICAgICAgICAgc2RrX3ZlcnNpb246IFwiXCIsXG4gICAgICAgICAgICBzZGs6IHJlZ2lzdGVyQm9keS5zZGssXG4gICAgICAgICAgICB1cmw6IHJlZ2lzdGVyQm9keS51cmwsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbnRyb3NwZWN0aW9uQm9keS5hdXRoZW50aWNhdGlvbl9zdWNjZWVkZWQpIHtcbiAgICAgICAgICAgIGJvZHkuc2RrX2xhbmd1YWdlID0gaW50cm9zcGVjdGlvbkJvZHkuc2RrX2xhbmd1YWdlO1xuICAgICAgICAgICAgYm9keS5zZGtfdmVyc2lvbiA9IGludHJvc3BlY3Rpb25Cb2R5LnNka192ZXJzaW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH1cbiAgICBhc3luYyBpbnRyb3NwZWN0aW9uQm9keSh7IGFjdGlvbnMsIGVudiwgc2lnbmF0dXJlVmFsaWRhdGlvbiwgdXJsLCB9KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyQm9keSA9IHRoaXMucmVnaXN0ZXJCb2R5KHtcbiAgICAgICAgICAgIHVybDogdGhpcy5yZXFVcmwodXJsKSxcbiAgICAgICAgICAgIGRlcGxveUlkOiBudWxsLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLl9tb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBtb2RlIHNldDsgY2Fubm90IGludHJvc3BlY3Qgd2l0aG91dCBtb2RlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbnRyb3NwZWN0aW9uID0ge1xuICAgICAgICAgICAgYXV0aGVudGljYXRpb25fc3VjY2VlZGVkOiBudWxsLFxuICAgICAgICAgICAgZXh0cmE6IHtcbiAgICAgICAgICAgICAgICBpc19tb2RlX2V4cGxpY2l0OiB0aGlzLl9tb2RlLmlzRXhwbGljaXQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFzX2V2ZW50X2tleTogdGhpcy5jbGllbnRbXCJldmVudEtleVNldFwiXSgpLFxuICAgICAgICAgICAgaGFzX3NpZ25pbmdfa2V5OiBCb29sZWFuKHRoaXMuc2lnbmluZ0tleSksXG4gICAgICAgICAgICBmdW5jdGlvbl9jb3VudDogcmVnaXN0ZXJCb2R5LmZ1bmN0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICBtb2RlOiB0aGlzLl9tb2RlLnR5cGUsXG4gICAgICAgICAgICBzY2hlbWFfdmVyc2lvbjogXCIyMDI0LTA1LTI0XCIsXG4gICAgICAgIH07XG4gICAgICAgIC8vIE9ubHkgYWxsb3cgYXV0aGVudGljYXRlZCBpbnRyb3NwZWN0aW9uIGluIENsb3VkIG1vZGUsIHNpbmNlIERldiBtb2RlIHNraXBzXG4gICAgICAgIC8vIHNpZ25hdHVyZSB2YWxpZGF0aW9uXG4gICAgICAgIGlmICh0aGlzLl9tb2RlLnR5cGUgPT09IFwiY2xvdWRcIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gYXdhaXQgc2lnbmF0dXJlVmFsaWRhdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRpb25SZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgdmFsaWRhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGludHJvc3BlY3Rpb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludHJvc3BlY3Rpb24pLCB7IGF1dGhlbnRpY2F0aW9uX3N1Y2NlZWRlZDogdHJ1ZSwgYXBpX29yaWdpbjogdGhpcy5hcGlCYXNlVXJsLCBhcHBfaWQ6IHRoaXMuaWQsIGNhcGFiaWxpdGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ1c3RfcHJvYmU6IFwidjFcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Q6IFwidjFcIixcbiAgICAgICAgICAgICAgICAgICAgfSwgZW52LCBldmVudF9hcGlfb3JpZ2luOiB0aGlzLmV2ZW50QXBpQmFzZVVybCwgZXZlbnRfa2V5X2hhc2g6IChfYSA9IHRoaXMuaGFzaGVkRXZlbnRLZXkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG51bGwsIGV4dHJhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludHJvc3BlY3Rpb24uZXh0cmEpLCB7IGlzX3N0cmVhbWluZzogYXdhaXQgdGhpcy5zaG91bGRTdHJlYW0oYWN0aW9ucykgfSksIGZyYW1ld29yazogdGhpcy5mcmFtZXdvcmtOYW1lLCBzZGtfbGFuZ3VhZ2U6IFwianNcIiwgc2RrX3ZlcnNpb246IHZlcnNpb25fanNfMS52ZXJzaW9uLCBzZXJ2ZV9vcmlnaW46IChfYiA9IHRoaXMuc2VydmVIb3N0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBudWxsLCBzZXJ2ZV9wYXRoOiAoX2MgPSB0aGlzLnNlcnZlUGF0aCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogbnVsbCwgc2lnbmluZ19rZXlfZmFsbGJhY2tfaGFzaDogKF9kID0gdGhpcy5oYXNoZWRTaWduaW5nS2V5RmFsbGJhY2spICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG51bGwsIHNpZ25pbmdfa2V5X2hhc2g6IChfZSA9IHRoaXMuaGFzaGVkU2lnbmluZ0tleSkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbnVsbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfZikge1xuICAgICAgICAgICAgICAgIC8vIFN3YWxsb3cgc2lnbmF0dXJlIHZhbGlkYXRpb24gZXJyb3Igc2luY2Ugd2UnbGwganVzdCByZXR1cm4gdGhlXG4gICAgICAgICAgICAgICAgLy8gdW5hdXRoZW50aWNhdGVkIGludHJvc3BlY3Rpb25cbiAgICAgICAgICAgICAgICBpbnRyb3NwZWN0aW9uID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRyb3NwZWN0aW9uKSwgeyBhdXRoZW50aWNhdGlvbl9zdWNjZWVkZWQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnRyb3NwZWN0aW9uO1xuICAgIH1cbiAgICBhc3luYyByZWdpc3Rlcih1cmwsIGRlcGxveUlkLCBnZXRIZWFkZXJzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgYm9keSA9IHRoaXMucmVnaXN0ZXJCb2R5KHsgdXJsLCBkZXBsb3lJZCB9KTtcbiAgICAgICAgbGV0IHJlcztcbiAgICAgICAgLy8gV2hlbmV2ZXIgd2UgcmVnaXN0ZXIsIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGV2IHNlcnZlciBpcyB1cC4gIFRoaXNcbiAgICAgICAgLy8gaXMgYSBub29wIGFuZCByZXR1cm5zIGZhbHNlIGluIHByb2R1Y3Rpb24uIENsb25lIHRoZSBVUkwgb2JqZWN0IHRvIGF2b2lkXG4gICAgICAgIC8vIG11dGF0aW5nIHRoZSBwcm9wZXJ0eSBiZXR3ZWVuIHJlcXVlc3RzLlxuICAgICAgICBsZXQgcmVnaXN0ZXJVUkwgPSBuZXcgVVJMKHRoaXMuaW5uZ2VzdFJlZ2lzdGVyVXJsLmhyZWYpO1xuICAgICAgICBjb25zdCBpbmZlcnJlZERldk1vZGUgPSB0aGlzLl9tb2RlICYmIHRoaXMuX21vZGUuaXNJbmZlcnJlZCAmJiB0aGlzLl9tb2RlLmlzRGV2O1xuICAgICAgICBpZiAoaW5mZXJyZWREZXZNb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBob3N0ID0gKDAsIGVudl9qc18xLmRldlNlcnZlckhvc3QpKHRoaXMuZW52KTtcbiAgICAgICAgICAgIGNvbnN0IGhhc0RldlNlcnZlciA9IGF3YWl0ICgwLCBkZXZzZXJ2ZXJfanNfMS5kZXZTZXJ2ZXJBdmFpbGFibGUpKGhvc3QsIHRoaXMuZmV0Y2gpO1xuICAgICAgICAgICAgaWYgKGhhc0RldlNlcnZlcikge1xuICAgICAgICAgICAgICAgIHJlZ2lzdGVyVVJMID0gKDAsIGRldnNlcnZlcl9qc18xLmRldlNlcnZlclVybCkoaG9zdCwgXCIvZm4vcmVnaXN0ZXJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKF9hID0gdGhpcy5fbW9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4cGxpY2l0RGV2VXJsKSB7XG4gICAgICAgICAgICByZWdpc3RlclVSTCA9ICgwLCBkZXZzZXJ2ZXJfanNfMS5kZXZTZXJ2ZXJVcmwpKHRoaXMuX21vZGUuZXhwbGljaXREZXZVcmwuaHJlZiwgXCIvZm4vcmVnaXN0ZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlcGxveUlkKSB7XG4gICAgICAgICAgICByZWdpc3RlclVSTC5zZWFyY2hQYXJhbXMuc2V0KGNvbnN0c19qc18xLnF1ZXJ5S2V5cy5EZXBsb3lJZCwgZGVwbG95SWQpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXMgPSBhd2FpdCAoMCwgbmV0X2pzXzEuZmV0Y2hXaXRoQXV0aEZhbGxiYWNrKSh7XG4gICAgICAgICAgICAgICAgYXV0aFRva2VuOiB0aGlzLmhhc2hlZFNpZ25pbmdLZXksXG4gICAgICAgICAgICAgICAgYXV0aFRva2VuRmFsbGJhY2s6IHRoaXMuaGFzaGVkU2lnbmluZ0tleUZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGZldGNoOiB0aGlzLmZldGNoLFxuICAgICAgICAgICAgICAgIHVybDogcmVnaXN0ZXJVUkwuaHJlZixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6ICgwLCBzdHJpbmdzX2pzXzEuc3RyaW5naWZ5KShib2R5KSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBnZXRIZWFkZXJzKCkpLCB7IFtjb25zdHNfanNfMS5oZWFkZXJLZXlzLklubmdlc3RTeW5jS2luZF06IGNvbnN0c19qc18xLnN5bmNLaW5kLk91dE9mQmFuZCB9KSxcbiAgICAgICAgICAgICAgICAgICAgcmVkaXJlY3Q6IFwiZm9sbG93XCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYEZhaWxlZCB0byByZWdpc3RlciR7ZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBgOyAke2Vyci5tZXNzYWdlfWAgOiBcIlwifWAsXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByYXcgPSBhd2FpdCByZXMudGV4dCgpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgIGxldCBkYXRhID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShyYXcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwid2FyblwiLCBcIkNvdWxkbid0IHVucGFjayByZWdpc3RlciByZXNwb25zZTpcIiwgZXJyKTtcbiAgICAgICAgICAgIGxldCBtZXNzYWdlID0gXCJGYWlsZWQgdG8gcmVnaXN0ZXJcIjtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgKz0gYDsgJHtlcnIubWVzc2FnZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZSArPSBgOyBzdGF0dXMgY29kZTogJHtyZXMuc3RhdHVzfWA7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogNTAwLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgbW9kaWZpZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdHVzO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIGxldCBza2lwcGVkO1xuICAgICAgICBsZXQgbW9kaWZpZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAoeyBzdGF0dXMsIGVycm9yLCBza2lwcGVkLCBtb2RpZmllZCB9ID0gcmVnaXN0ZXJSZXNTY2hlbWEucGFyc2UoZGF0YSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHRoaXMubG9nKFwid2FyblwiLCBcIkludmFsaWQgcmVnaXN0ZXIgcmVzcG9uc2Ugc2NoZW1hOlwiLCBlcnIpO1xuICAgICAgICAgICAgbGV0IG1lc3NhZ2UgPSBcIkZhaWxlZCB0byByZWdpc3RlclwiO1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSArPSBgOyAke2Vyci5tZXNzYWdlfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtZXNzYWdlICs9IGA7IHN0YXR1cyBjb2RlOiAke3Jlcy5zdGF0dXN9YDtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICBtb2RpZmllZDogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBkZXYgc2VydmVyIHBvbGxzIHRoaXMgZW5kcG9pbnQgdG8gcmVnaXN0ZXIgZnVuY3Rpb25zIGV2ZXJ5IGZld1xuICAgICAgICAvLyBzZWNvbmRzLCBidXQgd2Ugb25seSB3YW50IHRvIGxvZyB0aGF0IHdlJ3ZlIHJlZ2lzdGVyZWQgZnVuY3Rpb25zIGlmXG4gICAgICAgIC8vIHRoZSBmdW5jdGlvbiBkZWZpbml0aW9ucyBjaGFuZ2UuICBUaGVyZWZvcmUsIHdlIGNvbXBhcmUgdGhlIGJvZHkgc2VudFxuICAgICAgICAvLyBkdXJpbmcgcmVnaXN0cmF0aW9uIHdpdGggdGhlIGJvZHkgb2YgdGhlIGN1cnJlbnQgZnVuY3Rpb25zIGFuZCByZWZ1c2VcbiAgICAgICAgLy8gdG8gcmVnaXN0ZXIgaWYgdGhlIGZ1bmN0aW9ucyBhcmUgdGhlIHNhbWUuXG4gICAgICAgIGlmICghc2tpcHBlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2coXCJkZWJ1Z1wiLCBcInJlZ2lzdGVyZWQgaW5uZ2VzdCBmdW5jdGlvbnM6XCIsIHJlcy5zdGF0dXMsIHJlcy5zdGF0dXNUZXh0LCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXMsIG1lc3NhZ2U6IGVycm9yLCBtb2RpZmllZCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBlbnZpcm9ubWVudCwgdXBzZXJ0IGFueSBtaXNzaW5nIGtleXMuIFRoaXMgaXMgdXNlZnVsIGluXG4gICAgICogc2l0dWF0aW9ucyB3aGVyZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIHBhc3NlZCBkaXJlY3RseSB0byBoYW5kbGVycyBvclxuICAgICAqIGFyZSBvdGhlcndpc2UgZGlmZmljdWx0IHRvIGFjY2VzcyBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAgICovXG4gICAgdXBzZXJ0S2V5c0Zyb21FbnYoKSB7XG4gICAgICAgIGlmICh0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3RTaWduaW5nS2V5XSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNpZ25pbmdLZXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNpZ25pbmdLZXkgPSBTdHJpbmcodGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2lnbmluZ0tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGllbnRbXCJpbm5nZXN0QXBpXCJdLnNldFNpZ25pbmdLZXkodGhpcy5zaWduaW5nS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0U2lnbmluZ0tleUZhbGxiYWNrXSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNpZ25pbmdLZXlGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lnbmluZ0tleUZhbGxiYWNrID0gU3RyaW5nKHRoaXMuZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFNpZ25pbmdLZXlGYWxsYmFja10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jbGllbnRbXCJpbm5nZXN0QXBpXCJdLnNldFNpZ25pbmdLZXlGYWxsYmFjayh0aGlzLnNpZ25pbmdLZXlGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudFtcImV2ZW50S2V5U2V0XCJdKCkgJiYgdGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RXZlbnRLZXldKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5zZXRFdmVudEtleShTdHJpbmcodGhpcy5lbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RXZlbnRLZXldKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdjIgLT4gdjMgbWlncmF0aW9uIHdhcm5pbmdzXG4gICAgICAgIGlmICh0aGlzLmVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3REZXZTZXJ2ZXJVcmxdKSB7XG4gICAgICAgICAgICB0aGlzLmxvZyhcIndhcm5cIiwgYFVzZSBvZiAke2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdERldlNlcnZlclVybH0gaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiB2MzsgcGxlYXNlIHVzZSAke2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEJhc2VVcmx9IGluc3RlYWQuIFNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL3Nkay9taWdyYXRpb25gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0ZSB0aGUgc2lnbmF0dXJlIG9mIGEgcmVxdWVzdCBhbmQgcmV0dXJuIHRoZSBzaWduaW5nIGtleSB1c2VkIHRvXG4gICAgICogdmFsaWRhdGUgaXQuXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXF1aXJlLWF3YWl0XG4gICAgYXN5bmMgdmFsaWRhdGVTaWduYXR1cmUoc2lnLCBib2R5KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBTa2lwIHNpZ25hdHVyZSB2YWxpZGF0aW9uIGlmIHJlcXVlc3RlZCAodXNlZCBieSBjb25uZWN0KVxuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcFNpZ25hdHVyZVZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBrZXlVc2VkOiBcIlwiIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOZXZlciB2YWxpZGF0ZSBzaWduYXR1cmVzIG91dHNpZGUgb2YgcHJvZC4gTWFrZSBzdXJlIHRvIGNoZWNrIHRoZSBtb2RlXG4gICAgICAgICAgICAvLyBleGlzdHMgaGVyZSBpbnN0ZWFkIG9mIHVzaW5nIG51bGxpc2ggY29hbGVzY2luZyB0byBjb25maXJtIHRoYXQgdGhlIGNoZWNrXG4gICAgICAgICAgICAvLyBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5fbW9kZSAmJiAhdGhpcy5fbW9kZS5pc0Nsb3VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwga2V5VXNlZDogXCJcIiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UncmUgaGVyZSwgd2UncmUgaW4gcHJvZHVjdGlvbjsgbGFjayBvZiBhIHNpZ25pbmcga2V5IGlzIGFuIGVycm9yLlxuICAgICAgICAgICAgaWYgKCF0aGlzLnNpZ25pbmdLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzaWduaW5nIGtleSBmb3VuZCBpbiBjbGllbnQgb3B0aW9ucyBvciAke2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdFNpZ25pbmdLZXl9IGVudiB2YXIuIEZpbmQgeW91ciBrZXlzIGF0IGh0dHBzOi8vYXBwLmlubmdlc3QuY29tL3NlY3JldHNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIGhlcmUsIHdlJ3JlIGluIHByb2R1Y3Rpb247IGxhY2sgb2YgYSByZXEgc2lnbmF0dXJlIGlzIGFuIGVycm9yLlxuICAgICAgICAgICAgaWYgKCFzaWcpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyAke2NvbnN0c19qc18xLmhlYWRlcktleXMuU2lnbmF0dXJlfSBwcm92aWRlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVmFsaWRhdGUgdGhlIHNpZ25hdHVyZVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGtleVVzZWQ6IG5ldyBSZXF1ZXN0U2lnbmF0dXJlKHNpZykudmVyaWZ5U2lnbmF0dXJlKHtcbiAgICAgICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dFeHBpcmVkU2lnbmF0dXJlczogdGhpcy5hbGxvd0V4cGlyZWRTaWduYXR1cmVzLFxuICAgICAgICAgICAgICAgICAgICBzaWduaW5nS2V5OiB0aGlzLnNpZ25pbmdLZXksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25pbmdLZXlGYWxsYmFjazogdGhpcy5zaWduaW5nS2V5RmFsbGJhY2ssXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnI6IGVyciB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldFJlc3BvbnNlU2lnbmF0dXJlKGtleSwgYm9keSkge1xuICAgICAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICBjb25zdCBtYWMgPSAoMCwgbmV0X2pzXzEuc2lnbkRhdGFXaXRoS2V5KShib2R5LCBrZXksIG5vdy50b1N0cmluZygpKTtcbiAgICAgICAgcmV0dXJuIGB0PSR7bm93fSZzPSR7bWFjfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZyB0byBzdGRvdXQvc3RkZXJyIGlmIHRoZSBsb2cgbGV2ZWwgaXMgc2V0IHRvIGluY2x1ZGUgdGhlIGdpdmVuIGxldmVsLlxuICAgICAqIFRoZSBkZWZhdWx0IGxvZyBsZXZlbCBpcyBgXCJpbmZvXCJgLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBhbiBhYnN0cmFjdGlvbiBvdmVyIGBjb25zb2xlLmxvZ2AgYW5kIHdpbGwgdHJ5IHRvIHVzZSB0aGUgY29ycmVjdFxuICAgICAqIG1ldGhvZCBmb3IgdGhlIGdpdmVuIGxvZyBsZXZlbC4gIEZvciBleGFtcGxlLCBgbG9nKFwiZXJyb3JcIiwgXCJmb29cIilgIHdpbGxcbiAgICAgKiBjYWxsIGBjb25zb2xlLmVycm9yKFwiZm9vXCIpYC5cbiAgICAgKi9cbiAgICBsb2cobGV2ZWwsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgbG9nTGV2ZWxzID0gW1xuICAgICAgICAgICAgXCJkZWJ1Z1wiLFxuICAgICAgICAgICAgXCJpbmZvXCIsXG4gICAgICAgICAgICBcIndhcm5cIixcbiAgICAgICAgICAgIFwiZXJyb3JcIixcbiAgICAgICAgICAgIFwiZmF0YWxcIixcbiAgICAgICAgICAgIFwic2lsZW50XCIsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGxvZ0xldmVsU2V0dGluZyA9IGxvZ0xldmVscy5pbmRleE9mKHRoaXMubG9nTGV2ZWwpO1xuICAgICAgICBjb25zdCBjdXJyZW50TGV2ZWwgPSBsb2dMZXZlbHMuaW5kZXhPZihsZXZlbCk7XG4gICAgICAgIGlmIChjdXJyZW50TGV2ZWwgPj0gbG9nTGV2ZWxTZXR0aW5nKSB7XG4gICAgICAgICAgICBsZXQgbG9nZ2VyID0gY29uc29sZS5sb2c7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbnNvbGUsIGxldmVsKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlciA9IGNvbnNvbGVbbGV2ZWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyKGAke2NvbnN0c19qc18xLmxvZ1ByZWZpeH0gJHtsZXZlbH0gLWAsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Jbm5nZXN0Q29tbUhhbmRsZXIgPSBJbm5nZXN0Q29tbUhhbmRsZXI7XG5jbGFzcyBSZXF1ZXN0U2lnbmF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcihzaWcpIHtcbiAgICAgICAgX1JlcXVlc3RTaWduYXR1cmVfaW5zdGFuY2VzLmFkZCh0aGlzKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcyhzaWcpO1xuICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHBhcmFtcy5nZXQoXCJ0XCIpIHx8IFwiXCI7XG4gICAgICAgIHRoaXMuc2lnbmF0dXJlID0gcGFyYW1zLmdldChcInNcIikgfHwgXCJcIjtcbiAgICAgICAgaWYgKCF0aGlzLnRpbWVzdGFtcCB8fCAhdGhpcy5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gUHJldHR5RXJyb3JcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCAke2NvbnN0c19qc18xLmhlYWRlcktleXMuU2lnbmF0dXJlfSBwcm92aWRlZGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0V4cGlyZWQoYWxsb3dFeHBpcmVkU2lnbmF0dXJlcykge1xuICAgICAgICBpZiAoYWxsb3dFeHBpcmVkU2lnbmF0dXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlbHRhID0gRGF0ZS5ub3coKSAtIG5ldyBEYXRlKHBhcnNlSW50KHRoaXMudGltZXN0YW1wKSAqIDEwMDApLnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuIGRlbHRhID4gMTAwMCAqIDYwICogNTtcbiAgICB9XG4gICAgdmVyaWZ5U2lnbmF0dXJlKHsgYm9keSwgc2lnbmluZ0tleSwgc2lnbmluZ0tleUZhbGxiYWNrLCBhbGxvd0V4cGlyZWRTaWduYXR1cmVzLCB9KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9SZXF1ZXN0U2lnbmF0dXJlX2luc3RhbmNlcywgXCJtXCIsIF9SZXF1ZXN0U2lnbmF0dXJlX3ZlcmlmeVNpZ25hdHVyZSkuY2FsbCh0aGlzLCB7IGJvZHksIHNpZ25pbmdLZXksIGFsbG93RXhwaXJlZFNpZ25hdHVyZXMgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmluZ0tleTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBpZiAoIXNpZ25pbmdLZXlGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1JlcXVlc3RTaWduYXR1cmVfaW5zdGFuY2VzLCBcIm1cIiwgX1JlcXVlc3RTaWduYXR1cmVfdmVyaWZ5U2lnbmF0dXJlKS5jYWxsKHRoaXMsIHtcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIHNpZ25pbmdLZXk6IHNpZ25pbmdLZXlGYWxsYmFjayxcbiAgICAgICAgICAgICAgICBhbGxvd0V4cGlyZWRTaWduYXR1cmVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmluZ0tleUZhbGxiYWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuX1JlcXVlc3RTaWduYXR1cmVfaW5zdGFuY2VzID0gbmV3IFdlYWtTZXQoKSwgX1JlcXVlc3RTaWduYXR1cmVfdmVyaWZ5U2lnbmF0dXJlID0gZnVuY3Rpb24gX1JlcXVlc3RTaWduYXR1cmVfdmVyaWZ5U2lnbmF0dXJlKHsgYm9keSwgc2lnbmluZ0tleSwgYWxsb3dFeHBpcmVkU2lnbmF0dXJlcywgfSkge1xuICAgIGlmICh0aGlzLmhhc0V4cGlyZWQoYWxsb3dFeHBpcmVkU2lnbmF0dXJlcykpIHtcbiAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduYXR1cmUgaGFzIGV4cGlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IG1hYyA9ICgwLCBuZXRfanNfMS5zaWduRGF0YVdpdGhLZXkpKGJvZHksIHNpZ25pbmdLZXksIHRoaXMudGltZXN0YW1wKTtcbiAgICBpZiAobWFjICE9PSB0aGlzLnNpZ25hdHVyZSkge1xuICAgICAgICAvLyBUT0RPIFByZXR0eUVycm9yXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2lnbmF0dXJlXCIpO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5nZXN0Q29tbUhhbmRsZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestCommHandler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestFunction.js":
/*!************************************************************!*\
  !*** ./node_modules/inngest/components/InngestFunction.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestFunction = void 0;\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst v0_js_1 = __webpack_require__(/*! ./execution/v0.js */ \"(rsc)/./node_modules/inngest/components/execution/v0.js\");\nconst v1_js_1 = __webpack_require__(/*! ./execution/v1.js */ \"(rsc)/./node_modules/inngest/components/execution/v1.js\");\nconst v2_js_1 = __webpack_require__(/*! ./execution/v2.js */ \"(rsc)/./node_modules/inngest/components/execution/v2.js\");\n/**\n * A stateless Inngest function, wrapping up function configuration and any\n * in-memory steps to run when triggered.\n *\n * This function can be \"registered\" to create a handler that Inngest can\n * trigger remotely.\n *\n * @public\n */\nclass InngestFunction {\n    /**\n     * A stateless Inngest function, wrapping up function configuration and any\n     * in-memory steps to run when triggered.\n     *\n     * This function can be \"registered\" to create a handler that Inngest can\n     * trigger remotely.\n     */\n    constructor(client, \n    /**\n     * Options\n     */\n    opts, fn) {\n        this.client = client;\n        this.opts = opts;\n        this.fn = fn;\n        this.onFailureFn = this.opts.onFailure;\n        this.middleware = this.client[\"initializeMiddleware\"](this.opts.middleware, { registerInput: { fn: this }, prefixStack: this.client[\"middleware\"] });\n    }\n    /**\n     * The generated or given ID for this function.\n     */\n    id(prefix) {\n        return [prefix, this.opts.id].filter(Boolean).join(\"-\");\n    }\n    /**\n     * The generated or given ID for this function, prefixed with the app ID. This\n     * is used for routing invokes and identifying the function across apps.\n     */\n    get absoluteId() {\n        return this.id(this.client.id);\n    }\n    /**\n     * The name of this function as it will appear in the Inngest Cloud UI.\n     */\n    get name() {\n        return this.opts.name || this.id();\n    }\n    /**\n     * The description of this function.\n     */\n    get description() {\n        return this.opts.description;\n    }\n    /**\n     * Retrieve the Inngest config for this function.\n     */\n    getConfig({ baseUrl, appPrefix, isConnect, }) {\n        var _a, _b;\n        const fnId = this.id(appPrefix);\n        const stepUrl = new URL(baseUrl.href);\n        stepUrl.searchParams.set(consts_js_1.queryKeys.FnId, fnId);\n        stepUrl.searchParams.set(consts_js_1.queryKeys.StepId, InngestFunction.stepId);\n        const { retries: attempts, cancelOn, idempotency, batchEvents, rateLimit, throttle, concurrency, debounce, timeouts, priority, singleton, } = this.opts;\n        /**\n         * Convert retries into the format required when defining function\n         * configuration.\n         */\n        const retries = typeof attempts === \"undefined\" ? undefined : { attempts };\n        const fn = {\n            id: fnId,\n            name: this.name,\n            triggers: ((_a = this.opts.triggers) !== null && _a !== void 0 ? _a : []).map((trigger) => {\n                if (\"event\" in trigger) {\n                    return {\n                        event: trigger.event,\n                        expression: trigger.if,\n                    };\n                }\n                return {\n                    cron: trigger.cron,\n                };\n            }),\n            steps: {\n                [InngestFunction.stepId]: {\n                    id: InngestFunction.stepId,\n                    name: InngestFunction.stepId,\n                    runtime: {\n                        type: isConnect ? \"ws\" : \"http\",\n                        url: stepUrl.href,\n                    },\n                    retries,\n                },\n            },\n            idempotency,\n            batchEvents,\n            rateLimit,\n            throttle,\n            concurrency,\n            debounce,\n            priority,\n            timeouts,\n            singleton,\n        };\n        if (cancelOn) {\n            fn.cancel = cancelOn.map(({ event, timeout, if: ifStr, match }) => {\n                const ret = {\n                    event,\n                };\n                if (timeout) {\n                    ret.timeout = (0, strings_js_1.timeStr)(timeout);\n                }\n                if (match) {\n                    ret.if = `event.${match} == async.${match}`;\n                }\n                else if (ifStr) {\n                    ret.if = ifStr;\n                }\n                return ret;\n            }, []);\n        }\n        const config = [fn];\n        if (this.onFailureFn) {\n            const id = `${fn.id}${InngestFunction.failureSuffix}`;\n            const name = `${(_b = fn.name) !== null && _b !== void 0 ? _b : fn.id} (failure)`;\n            const failureStepUrl = new URL(stepUrl.href);\n            failureStepUrl.searchParams.set(consts_js_1.queryKeys.FnId, id);\n            config.push({\n                id,\n                name,\n                triggers: [\n                    {\n                        event: consts_js_1.internalEvents.FunctionFailed,\n                        expression: `event.data.function_id == '${fnId}'`,\n                    },\n                ],\n                steps: {\n                    [InngestFunction.stepId]: {\n                        id: InngestFunction.stepId,\n                        name: InngestFunction.stepId,\n                        runtime: {\n                            type: \"http\",\n                            url: failureStepUrl.href,\n                        },\n                        retries: { attempts: 1 },\n                    },\n                },\n            });\n        }\n        return config;\n    }\n    createExecution(opts) {\n        const options = Object.assign({ fn: this }, opts.partialOptions);\n        const versionHandlers = {\n            [InngestExecution_js_1.ExecutionVersion.V2]: () => (0, v2_js_1.createV2InngestExecution)(options),\n            [InngestExecution_js_1.ExecutionVersion.V1]: () => (0, v1_js_1.createV1InngestExecution)(options),\n            [InngestExecution_js_1.ExecutionVersion.V0]: () => (0, v0_js_1.createV0InngestExecution)(options),\n        };\n        return versionHandlers[opts.version]();\n    }\n    shouldOptimizeParallelism() {\n        var _a, _b;\n        // TODO We should check the commhandler's client instead of this one?\n        return ((_b = (_a = this.opts.optimizeParallelism) !== null && _a !== void 0 ? _a : this.client[\"options\"].optimizeParallelism) !== null && _b !== void 0 ? _b : false);\n    }\n}\nexports.InngestFunction = InngestFunction;\nInngestFunction.stepId = \"step\";\nInngestFunction.failureSuffix = \"-failure\";\n//# sourceMappingURL=InngestFunction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCw4QkFBOEIsbUJBQU8sQ0FBQyw4R0FBaUM7QUFDdkUsZ0JBQWdCLG1CQUFPLENBQUMsa0ZBQW1CO0FBQzNDLGdCQUFnQixtQkFBTyxDQUFDLGtGQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxrRkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRixpQkFBaUIsVUFBVSwwQ0FBMEM7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQ0FBZ0M7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvSUFBb0k7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0NBQWtDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLE9BQU8sV0FBVyxNQUFNO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE1BQU0sRUFBRSw4QkFBOEI7QUFDaEUsNEJBQTRCLHVEQUF1RDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLEtBQUs7QUFDdkUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsbUNBQW1DLGFBQWE7QUFDaEQscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsVUFBVTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSW5uZ2VzdEZ1bmN0aW9uID0gdm9pZCAwO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9jb25zdHMuanNcIik7XG5jb25zdCBzdHJpbmdzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zdHJpbmdzLmpzXCIpO1xuY29uc3QgSW5uZ2VzdEV4ZWN1dGlvbl9qc18xID0gcmVxdWlyZShcIi4vZXhlY3V0aW9uL0lubmdlc3RFeGVjdXRpb24uanNcIik7XG5jb25zdCB2MF9qc18xID0gcmVxdWlyZShcIi4vZXhlY3V0aW9uL3YwLmpzXCIpO1xuY29uc3QgdjFfanNfMSA9IHJlcXVpcmUoXCIuL2V4ZWN1dGlvbi92MS5qc1wiKTtcbmNvbnN0IHYyX2pzXzEgPSByZXF1aXJlKFwiLi9leGVjdXRpb24vdjIuanNcIik7XG4vKipcbiAqIEEgc3RhdGVsZXNzIElubmdlc3QgZnVuY3Rpb24sIHdyYXBwaW5nIHVwIGZ1bmN0aW9uIGNvbmZpZ3VyYXRpb24gYW5kIGFueVxuICogaW4tbWVtb3J5IHN0ZXBzIHRvIHJ1biB3aGVuIHRyaWdnZXJlZC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBcInJlZ2lzdGVyZWRcIiB0byBjcmVhdGUgYSBoYW5kbGVyIHRoYXQgSW5uZ2VzdCBjYW5cbiAqIHRyaWdnZXIgcmVtb3RlbHkuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBJbm5nZXN0RnVuY3Rpb24ge1xuICAgIC8qKlxuICAgICAqIEEgc3RhdGVsZXNzIElubmdlc3QgZnVuY3Rpb24sIHdyYXBwaW5nIHVwIGZ1bmN0aW9uIGNvbmZpZ3VyYXRpb24gYW5kIGFueVxuICAgICAqIGluLW1lbW9yeSBzdGVwcyB0byBydW4gd2hlbiB0cmlnZ2VyZWQuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBcInJlZ2lzdGVyZWRcIiB0byBjcmVhdGUgYSBoYW5kbGVyIHRoYXQgSW5uZ2VzdCBjYW5cbiAgICAgKiB0cmlnZ2VyIHJlbW90ZWx5LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCwgXG4gICAgLyoqXG4gICAgICogT3B0aW9uc1xuICAgICAqL1xuICAgIG9wdHMsIGZuKSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLmZuID0gZm47XG4gICAgICAgIHRoaXMub25GYWlsdXJlRm4gPSB0aGlzLm9wdHMub25GYWlsdXJlO1xuICAgICAgICB0aGlzLm1pZGRsZXdhcmUgPSB0aGlzLmNsaWVudFtcImluaXRpYWxpemVNaWRkbGV3YXJlXCJdKHRoaXMub3B0cy5taWRkbGV3YXJlLCB7IHJlZ2lzdGVySW5wdXQ6IHsgZm46IHRoaXMgfSwgcHJlZml4U3RhY2s6IHRoaXMuY2xpZW50W1wibWlkZGxld2FyZVwiXSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGdlbmVyYXRlZCBvciBnaXZlbiBJRCBmb3IgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBpZChwcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIFtwcmVmaXgsIHRoaXMub3B0cy5pZF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCItXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZ2VuZXJhdGVkIG9yIGdpdmVuIElEIGZvciB0aGlzIGZ1bmN0aW9uLCBwcmVmaXhlZCB3aXRoIHRoZSBhcHAgSUQuIFRoaXNcbiAgICAgKiBpcyB1c2VkIGZvciByb3V0aW5nIGludm9rZXMgYW5kIGlkZW50aWZ5aW5nIHRoZSBmdW5jdGlvbiBhY3Jvc3MgYXBwcy5cbiAgICAgKi9cbiAgICBnZXQgYWJzb2x1dGVJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQodGhpcy5jbGllbnQuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGZ1bmN0aW9uIGFzIGl0IHdpbGwgYXBwZWFyIGluIHRoZSBJbm5nZXN0IENsb3VkIFVJLlxuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRzLm5hbWUgfHwgdGhpcy5pZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgZGVzY3JpcHRpb24gb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdHMuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlIHRoZSBJbm5nZXN0IGNvbmZpZyBmb3IgdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBnZXRDb25maWcoeyBiYXNlVXJsLCBhcHBQcmVmaXgsIGlzQ29ubmVjdCwgfSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBmbklkID0gdGhpcy5pZChhcHBQcmVmaXgpO1xuICAgICAgICBjb25zdCBzdGVwVXJsID0gbmV3IFVSTChiYXNlVXJsLmhyZWYpO1xuICAgICAgICBzdGVwVXJsLnNlYXJjaFBhcmFtcy5zZXQoY29uc3RzX2pzXzEucXVlcnlLZXlzLkZuSWQsIGZuSWQpO1xuICAgICAgICBzdGVwVXJsLnNlYXJjaFBhcmFtcy5zZXQoY29uc3RzX2pzXzEucXVlcnlLZXlzLlN0ZXBJZCwgSW5uZ2VzdEZ1bmN0aW9uLnN0ZXBJZCk7XG4gICAgICAgIGNvbnN0IHsgcmV0cmllczogYXR0ZW1wdHMsIGNhbmNlbE9uLCBpZGVtcG90ZW5jeSwgYmF0Y2hFdmVudHMsIHJhdGVMaW1pdCwgdGhyb3R0bGUsIGNvbmN1cnJlbmN5LCBkZWJvdW5jZSwgdGltZW91dHMsIHByaW9yaXR5LCBzaW5nbGV0b24sIH0gPSB0aGlzLm9wdHM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb252ZXJ0IHJldHJpZXMgaW50byB0aGUgZm9ybWF0IHJlcXVpcmVkIHdoZW4gZGVmaW5pbmcgZnVuY3Rpb25cbiAgICAgICAgICogY29uZmlndXJhdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJldHJpZXMgPSB0eXBlb2YgYXR0ZW1wdHMgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQgOiB7IGF0dGVtcHRzIH07XG4gICAgICAgIGNvbnN0IGZuID0ge1xuICAgICAgICAgICAgaWQ6IGZuSWQsXG4gICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICB0cmlnZ2VyczogKChfYSA9IHRoaXMub3B0cy50cmlnZ2VycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10pLm1hcCgodHJpZ2dlcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcImV2ZW50XCIgaW4gdHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IHRyaWdnZXIuZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiB0cmlnZ2VyLmlmLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjcm9uOiB0cmlnZ2VyLmNyb24sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgc3RlcHM6IHtcbiAgICAgICAgICAgICAgICBbSW5uZ2VzdEZ1bmN0aW9uLnN0ZXBJZF06IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IElubmdlc3RGdW5jdGlvbi5zdGVwSWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IElubmdlc3RGdW5jdGlvbi5zdGVwSWQsXG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGlzQ29ubmVjdCA/IFwid3NcIiA6IFwiaHR0cFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBzdGVwVXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJldHJpZXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpZGVtcG90ZW5jeSxcbiAgICAgICAgICAgIGJhdGNoRXZlbnRzLFxuICAgICAgICAgICAgcmF0ZUxpbWl0LFxuICAgICAgICAgICAgdGhyb3R0bGUsXG4gICAgICAgICAgICBjb25jdXJyZW5jeSxcbiAgICAgICAgICAgIGRlYm91bmNlLFxuICAgICAgICAgICAgcHJpb3JpdHksXG4gICAgICAgICAgICB0aW1lb3V0cyxcbiAgICAgICAgICAgIHNpbmdsZXRvbixcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNhbmNlbE9uKSB7XG4gICAgICAgICAgICBmbi5jYW5jZWwgPSBjYW5jZWxPbi5tYXAoKHsgZXZlbnQsIHRpbWVvdXQsIGlmOiBpZlN0ciwgbWF0Y2ggfSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldCA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICByZXQudGltZW91dCA9ICgwLCBzdHJpbmdzX2pzXzEudGltZVN0cikodGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXQuaWYgPSBgZXZlbnQuJHttYXRjaH0gPT0gYXN5bmMuJHttYXRjaH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpZlN0cikge1xuICAgICAgICAgICAgICAgICAgICByZXQuaWYgPSBpZlN0cjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWcgPSBbZm5dO1xuICAgICAgICBpZiAodGhpcy5vbkZhaWx1cmVGbikge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBgJHtmbi5pZH0ke0lubmdlc3RGdW5jdGlvbi5mYWlsdXJlU3VmZml4fWA7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gYCR7KF9iID0gZm4ubmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZm4uaWR9IChmYWlsdXJlKWA7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlU3RlcFVybCA9IG5ldyBVUkwoc3RlcFVybC5ocmVmKTtcbiAgICAgICAgICAgIGZhaWx1cmVTdGVwVXJsLnNlYXJjaFBhcmFtcy5zZXQoY29uc3RzX2pzXzEucXVlcnlLZXlzLkZuSWQsIGlkKTtcbiAgICAgICAgICAgIGNvbmZpZy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHRyaWdnZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBjb25zdHNfanNfMS5pbnRlcm5hbEV2ZW50cy5GdW5jdGlvbkZhaWxlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGBldmVudC5kYXRhLmZ1bmN0aW9uX2lkID09ICcke2ZuSWR9J2AsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBzdGVwczoge1xuICAgICAgICAgICAgICAgICAgICBbSW5uZ2VzdEZ1bmN0aW9uLnN0ZXBJZF06IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBJbm5nZXN0RnVuY3Rpb24uc3RlcElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogSW5uZ2VzdEZ1bmN0aW9uLnN0ZXBJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bnRpbWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImh0dHBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGZhaWx1cmVTdGVwVXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmllczogeyBhdHRlbXB0czogMSB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBjcmVhdGVFeGVjdXRpb24ob3B0cykge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IGZuOiB0aGlzIH0sIG9wdHMucGFydGlhbE9wdGlvbnMpO1xuICAgICAgICBjb25zdCB2ZXJzaW9uSGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjJdOiAoKSA9PiAoMCwgdjJfanNfMS5jcmVhdGVWMklubmdlc3RFeGVjdXRpb24pKG9wdGlvbnMpLFxuICAgICAgICAgICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYxXTogKCkgPT4gKDAsIHYxX2pzXzEuY3JlYXRlVjFJbm5nZXN0RXhlY3V0aW9uKShvcHRpb25zKSxcbiAgICAgICAgICAgIFtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMF06ICgpID0+ICgwLCB2MF9qc18xLmNyZWF0ZVYwSW5uZ2VzdEV4ZWN1dGlvbikob3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2ZXJzaW9uSGFuZGxlcnNbb3B0cy52ZXJzaW9uXSgpO1xuICAgIH1cbiAgICBzaG91bGRPcHRpbWl6ZVBhcmFsbGVsaXNtKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBUT0RPIFdlIHNob3VsZCBjaGVjayB0aGUgY29tbWhhbmRsZXIncyBjbGllbnQgaW5zdGVhZCBvZiB0aGlzIG9uZT9cbiAgICAgICAgcmV0dXJuICgoX2IgPSAoX2EgPSB0aGlzLm9wdHMub3B0aW1pemVQYXJhbGxlbGlzbSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5jbGllbnRbXCJvcHRpb25zXCJdLm9wdGltaXplUGFyYWxsZWxpc20pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGZhbHNlKTtcbiAgICB9XG59XG5leHBvcnRzLklubmdlc3RGdW5jdGlvbiA9IElubmdlc3RGdW5jdGlvbjtcbklubmdlc3RGdW5jdGlvbi5zdGVwSWQgPSBcInN0ZXBcIjtcbklubmdlc3RGdW5jdGlvbi5mYWlsdXJlU3VmZml4ID0gXCItZmFpbHVyZVwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZ2VzdEZ1bmN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestFunction.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestFunctionReference.js":
/*!*********************************************************************!*\
  !*** ./node_modules/inngest/components/InngestFunctionReference.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.referenceFunction = exports.InngestFunctionReference = void 0;\n/**\n * A reference to an `InngestFunction` that can be used to represent both local\n * and remote functions without pulling in the full function definition (i.e.\n * dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * To create a reference function, use the {@link referenceFunction} helper.\n *\n * @public\n */\nclass InngestFunctionReference {\n    constructor(opts) {\n        this.opts = opts;\n    }\n}\nexports.InngestFunctionReference = InngestFunctionReference;\n/**\n * Create a reference to an `InngestFunction` that can be used to represent both\n * local and remote functions without pulling in the full function definition\n * (i.e. dependencies).\n *\n * These references can be invoked in the same manner as a regular\n * `InngestFunction`.\n *\n * @public\n */\nconst referenceFunction = ({ functionId, appId, }) => {\n    return new InngestFunctionReference({\n        functionId,\n        appId,\n    });\n};\nexports.referenceFunction = referenceFunction;\n//# sourceMappingURL=InngestFunctionReference.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvblJlZmVyZW5jZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRyxnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0Qyx5QkFBeUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQkFBb0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyIvVXNlcnMvaGFyc2hzaHJpdmFzdGF2L0Rlc2t0b3AvQ29kaW5nIFByb2plY3RzL0pvYi1Bc3Npc3RhbnQtQWdlbnQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9Jbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZmVyZW5jZUZ1bmN0aW9uID0gZXhwb3J0cy5Jbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UgPSB2b2lkIDA7XG4vKipcbiAqIEEgcmVmZXJlbmNlIHRvIGFuIGBJbm5nZXN0RnVuY3Rpb25gIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVwcmVzZW50IGJvdGggbG9jYWxcbiAqIGFuZCByZW1vdGUgZnVuY3Rpb25zIHdpdGhvdXQgcHVsbGluZyBpbiB0aGUgZnVsbCBmdW5jdGlvbiBkZWZpbml0aW9uIChpLmUuXG4gKiBkZXBlbmRlbmNpZXMpLlxuICpcbiAqIFRoZXNlIHJlZmVyZW5jZXMgY2FuIGJlIGludm9rZWQgaW4gdGhlIHNhbWUgbWFubmVyIGFzIGEgcmVndWxhclxuICogYElubmdlc3RGdW5jdGlvbmAuXG4gKlxuICogVG8gY3JlYXRlIGEgcmVmZXJlbmNlIGZ1bmN0aW9uLCB1c2UgdGhlIHtAbGluayByZWZlcmVuY2VGdW5jdGlvbn0gaGVscGVyLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRzKSB7XG4gICAgICAgIHRoaXMub3B0cyA9IG9wdHM7XG4gICAgfVxufVxuZXhwb3J0cy5Jbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UgPSBJbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2U7XG4vKipcbiAqIENyZWF0ZSBhIHJlZmVyZW5jZSB0byBhbiBgSW5uZ2VzdEZ1bmN0aW9uYCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCBib3RoXG4gKiBsb2NhbCBhbmQgcmVtb3RlIGZ1bmN0aW9ucyB3aXRob3V0IHB1bGxpbmcgaW4gdGhlIGZ1bGwgZnVuY3Rpb24gZGVmaW5pdGlvblxuICogKGkuZS4gZGVwZW5kZW5jaWVzKS5cbiAqXG4gKiBUaGVzZSByZWZlcmVuY2VzIGNhbiBiZSBpbnZva2VkIGluIHRoZSBzYW1lIG1hbm5lciBhcyBhIHJlZ3VsYXJcbiAqIGBJbm5nZXN0RnVuY3Rpb25gLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgcmVmZXJlbmNlRnVuY3Rpb24gPSAoeyBmdW5jdGlvbklkLCBhcHBJZCwgfSkgPT4ge1xuICAgIHJldHVybiBuZXcgSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlKHtcbiAgICAgICAgZnVuY3Rpb25JZCxcbiAgICAgICAgYXBwSWQsXG4gICAgfSk7XG59O1xuZXhwb3J0cy5yZWZlcmVuY2VGdW5jdGlvbiA9IHJlZmVyZW5jZUZ1bmN0aW9uO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestMiddleware.js":
/*!**************************************************************!*\
  !*** ./node_modules/inngest/components/InngestMiddleware.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getHookStack = exports.InngestMiddleware = void 0;\nconst functions_js_1 = __webpack_require__(/*! ../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\n/**\n * A middleware that can be registered with Inngest to hook into various\n * lifecycles of the SDK and affect input and output of Inngest functionality.\n *\n * See {@link https://innge.st/middleware}\n *\n * @example\n *\n * ```ts\n * export const inngest = new Inngest({\n *   middleware: [\n *     new InngestMiddleware({\n *       name: \"My Middleware\",\n *       init: () => {\n *         // ...\n *       }\n *     })\n *   ]\n * });\n * ```\n *\n * @public\n */\nclass InngestMiddleware {\n    constructor({ name, init }) {\n        this.name = name;\n        this.init = init;\n    }\n}\nexports.InngestMiddleware = InngestMiddleware;\n/**\n * Given some middleware and an entrypoint, runs the initializer for the given\n * `key` and returns functions that will pass arguments through a stack of each\n * given hook in a middleware's lifecycle.\n *\n * Lets the middleware initialize before starting.\n */\nconst getHookStack = async (\n/**\n * The stack of middleware that will be used to run hooks.\n */\nmiddleware, \n/**\n * The hook type to initialize.\n */\nkey, \n/**\n * Arguments for the initial hook.\n */\narg, transforms) => {\n    // Wait for middleware to initialize\n    const mwStack = await middleware;\n    // Step through each middleware and get the hook for the given key\n    const keyFns = mwStack.reduce((acc, mw) => {\n        const fn = mw[key];\n        if (fn) {\n            return [...acc, fn];\n        }\n        return acc;\n    }, []);\n    // Run each hook found in sequence and collect the results\n    const hooksRegistered = await keyFns.reduce(async (acc, fn) => {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        return [...(await acc), await fn(arg)];\n    }, Promise.resolve([]));\n    // Prepare the return object - mutating this instead of using reduce as it\n    // results in cleaner code.\n    const ret = {};\n    // Step through each hook result and create a waterfall joining each key\n    for (const hook of hooksRegistered) {\n        const hookKeys = Object.keys(hook);\n        for (const key of hookKeys) {\n            let fns = [hook[key]];\n            const existingWaterfall = ret[key];\n            if (existingWaterfall) {\n                fns = [existingWaterfall, hook[key]];\n            }\n            const transform = transforms[key];\n            ret[key] = (0, functions_js_1.waterfall)(fns, transform);\n        }\n    }\n    // Cache each function in the stack to ensure each can only be called once\n    for (const k of Object.keys(ret)) {\n        const key = k;\n        ret[key] = (0, functions_js_1.cacheFn)(ret[key]);\n    }\n    return ret;\n};\nexports.getHookStack = getHookStack;\n//# sourceMappingURL=InngestMiddleware.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RNaWRkbGV3YXJlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLHlCQUF5QjtBQUNoRCx1QkFBdUIsbUJBQU8sQ0FBQyxrRkFBeUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCIiwic291cmNlcyI6WyIvVXNlcnMvaGFyc2hzaHJpdmFzdGF2L0Rlc2t0b3AvQ29kaW5nIFByb2plY3RzL0pvYi1Bc3Npc3RhbnQtQWdlbnQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9Jbm5nZXN0TWlkZGxld2FyZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0SG9va1N0YWNrID0gZXhwb3J0cy5Jbm5nZXN0TWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IGZ1bmN0aW9uc19qc18xID0gcmVxdWlyZShcIi4uL2hlbHBlcnMvZnVuY3Rpb25zLmpzXCIpO1xuLyoqXG4gKiBBIG1pZGRsZXdhcmUgdGhhdCBjYW4gYmUgcmVnaXN0ZXJlZCB3aXRoIElubmdlc3QgdG8gaG9vayBpbnRvIHZhcmlvdXNcbiAqIGxpZmVjeWNsZXMgb2YgdGhlIFNESyBhbmQgYWZmZWN0IGlucHV0IGFuZCBvdXRwdXQgb2YgSW5uZ2VzdCBmdW5jdGlvbmFsaXR5LlxuICpcbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9pbm5nZS5zdC9taWRkbGV3YXJlfVxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHNcbiAqIGV4cG9ydCBjb25zdCBpbm5nZXN0ID0gbmV3IElubmdlc3Qoe1xuICogICBtaWRkbGV3YXJlOiBbXG4gKiAgICAgbmV3IElubmdlc3RNaWRkbGV3YXJlKHtcbiAqICAgICAgIG5hbWU6IFwiTXkgTWlkZGxld2FyZVwiLFxuICogICAgICAgaW5pdDogKCkgPT4ge1xuICogICAgICAgICAvLyAuLi5cbiAqICAgICAgIH1cbiAqICAgICB9KVxuICogICBdXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgSW5uZ2VzdE1pZGRsZXdhcmUge1xuICAgIGNvbnN0cnVjdG9yKHsgbmFtZSwgaW5pdCB9KSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuaW5pdCA9IGluaXQ7XG4gICAgfVxufVxuZXhwb3J0cy5Jbm5nZXN0TWlkZGxld2FyZSA9IElubmdlc3RNaWRkbGV3YXJlO1xuLyoqXG4gKiBHaXZlbiBzb21lIG1pZGRsZXdhcmUgYW5kIGFuIGVudHJ5cG9pbnQsIHJ1bnMgdGhlIGluaXRpYWxpemVyIGZvciB0aGUgZ2l2ZW5cbiAqIGBrZXlgIGFuZCByZXR1cm5zIGZ1bmN0aW9ucyB0aGF0IHdpbGwgcGFzcyBhcmd1bWVudHMgdGhyb3VnaCBhIHN0YWNrIG9mIGVhY2hcbiAqIGdpdmVuIGhvb2sgaW4gYSBtaWRkbGV3YXJlJ3MgbGlmZWN5Y2xlLlxuICpcbiAqIExldHMgdGhlIG1pZGRsZXdhcmUgaW5pdGlhbGl6ZSBiZWZvcmUgc3RhcnRpbmcuXG4gKi9cbmNvbnN0IGdldEhvb2tTdGFjayA9IGFzeW5jIChcbi8qKlxuICogVGhlIHN0YWNrIG9mIG1pZGRsZXdhcmUgdGhhdCB3aWxsIGJlIHVzZWQgdG8gcnVuIGhvb2tzLlxuICovXG5taWRkbGV3YXJlLCBcbi8qKlxuICogVGhlIGhvb2sgdHlwZSB0byBpbml0aWFsaXplLlxuICovXG5rZXksIFxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBpbml0aWFsIGhvb2suXG4gKi9cbmFyZywgdHJhbnNmb3JtcykgPT4ge1xuICAgIC8vIFdhaXQgZm9yIG1pZGRsZXdhcmUgdG8gaW5pdGlhbGl6ZVxuICAgIGNvbnN0IG13U3RhY2sgPSBhd2FpdCBtaWRkbGV3YXJlO1xuICAgIC8vIFN0ZXAgdGhyb3VnaCBlYWNoIG1pZGRsZXdhcmUgYW5kIGdldCB0aGUgaG9vayBmb3IgdGhlIGdpdmVuIGtleVxuICAgIGNvbnN0IGtleUZucyA9IG13U3RhY2sucmVkdWNlKChhY2MsIG13KSA9PiB7XG4gICAgICAgIGNvbnN0IGZuID0gbXdba2V5XTtcbiAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmFjYywgZm5dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfSwgW10pO1xuICAgIC8vIFJ1biBlYWNoIGhvb2sgZm91bmQgaW4gc2VxdWVuY2UgYW5kIGNvbGxlY3QgdGhlIHJlc3VsdHNcbiAgICBjb25zdCBob29rc1JlZ2lzdGVyZWQgPSBhd2FpdCBrZXlGbnMucmVkdWNlKGFzeW5jIChhY2MsIGZuKSA9PiB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICByZXR1cm4gWy4uLihhd2FpdCBhY2MpLCBhd2FpdCBmbihhcmcpXTtcbiAgICB9LCBQcm9taXNlLnJlc29sdmUoW10pKTtcbiAgICAvLyBQcmVwYXJlIHRoZSByZXR1cm4gb2JqZWN0IC0gbXV0YXRpbmcgdGhpcyBpbnN0ZWFkIG9mIHVzaW5nIHJlZHVjZSBhcyBpdFxuICAgIC8vIHJlc3VsdHMgaW4gY2xlYW5lciBjb2RlLlxuICAgIGNvbnN0IHJldCA9IHt9O1xuICAgIC8vIFN0ZXAgdGhyb3VnaCBlYWNoIGhvb2sgcmVzdWx0IGFuZCBjcmVhdGUgYSB3YXRlcmZhbGwgam9pbmluZyBlYWNoIGtleVxuICAgIGZvciAoY29uc3QgaG9vayBvZiBob29rc1JlZ2lzdGVyZWQpIHtcbiAgICAgICAgY29uc3QgaG9va0tleXMgPSBPYmplY3Qua2V5cyhob29rKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgaG9va0tleXMpIHtcbiAgICAgICAgICAgIGxldCBmbnMgPSBbaG9va1trZXldXTtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nV2F0ZXJmYWxsID0gcmV0W2tleV07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdXYXRlcmZhbGwpIHtcbiAgICAgICAgICAgICAgICBmbnMgPSBbZXhpc3RpbmdXYXRlcmZhbGwsIGhvb2tba2V5XV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm1zW2tleV07XG4gICAgICAgICAgICByZXRba2V5XSA9ICgwLCBmdW5jdGlvbnNfanNfMS53YXRlcmZhbGwpKGZucywgdHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDYWNoZSBlYWNoIGZ1bmN0aW9uIGluIHRoZSBzdGFjayB0byBlbnN1cmUgZWFjaCBjYW4gb25seSBiZSBjYWxsZWQgb25jZVxuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhyZXQpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGs7XG4gICAgICAgIHJldFtrZXldID0gKDAsIGZ1bmN0aW9uc19qc18xLmNhY2hlRm4pKHJldFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5leHBvcnRzLmdldEhvb2tTdGFjayA9IGdldEhvb2tTdGFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmdlc3RNaWRkbGV3YXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestMiddleware.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/InngestStepTools.js":
/*!*************************************************************!*\
  !*** ./node_modules/inngest/components/InngestStepTools.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.invokePayloadSchema = exports.gatewaySymbol = exports.createStepTools = exports.STEP_INDEXING_SUFFIX = exports.getStepOptions = void 0;\nconst ai_1 = __webpack_require__(/*! @inngest/ai */ \"(rsc)/./node_modules/@inngest/ai/dist/index.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst strings_js_1 = __webpack_require__(/*! ../helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nconst Temporal = __importStar(__webpack_require__(/*! ../helpers/temporal.js */ \"(rsc)/./node_modules/inngest/helpers/temporal.js\"));\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst Fetch_js_1 = __webpack_require__(/*! ./Fetch.js */ \"(rsc)/./node_modules/inngest/components/Fetch.js\");\nconst InngestFunction_js_1 = __webpack_require__(/*! ./InngestFunction.js */ \"(rsc)/./node_modules/inngest/components/InngestFunction.js\");\nconst InngestFunctionReference_js_1 = __webpack_require__(/*! ./InngestFunctionReference.js */ \"(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\");\nconst getStepOptions = (options) => {\n    if (typeof options === \"string\") {\n        return { id: options };\n    }\n    return options;\n};\nexports.getStepOptions = getStepOptions;\n/**\n * Suffix used to namespace steps that are automatically indexed.\n */\nexports.STEP_INDEXING_SUFFIX = \":\";\n/**\n * Create a new set of step function tools ready to be used in a step function.\n * This function should be run and a fresh set of tools provided every time a\n * function is run.\n *\n * An op stack (function state) is passed in as well as some mutable properties\n * that the tools can use to submit a new op.\n */\nconst createStepTools = (client, execution, stepHandler) => {\n    /**\n     * A local helper used to create tools that can be used to submit an op.\n     *\n     * When using this function, a generic type should be provided which is the\n     * function signature exposed to the user.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const createTool = (\n    /**\n     * A function that returns an ID for this op. This is used to ensure that\n     * the op stack is correctly filled, submitted, and retrieved with the same\n     * ID.\n     *\n     * It is passed the arguments passed by the user.\n     *\n     * Most simple tools will likely only need to define this.\n     */\n    matchOp, opts) => {\n        return (async (...args) => {\n            const parsedArgs = args;\n            return stepHandler({ args: parsedArgs, matchOp, opts });\n        });\n    };\n    /**\n     * Create a new step run tool that can be used to run a step function using\n     * `step.run()` as a shim.\n     */\n    const createStepRun = (\n    /**\n     * The sub-type of this step tool, exposed via `opts.type` when the op is\n     * reported.\n     */\n    type) => {\n        return createTool(({ id, name }, _fn, ...input) => {\n            const opts = Object.assign(Object.assign({}, (input.length ? { input } : {})), (type ? { type } : {}));\n            return Object.assign({ id, op: types_js_1.StepOpCode.StepPlanned, name: id, displayName: name !== null && name !== void 0 ? name : id }, (Object.keys(opts).length ? { opts } : {}));\n        }, {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            fn: (_, fn, ...input) => fn(...input),\n        });\n    };\n    /**\n     * Define the set of tools the user has access to for their step functions.\n     *\n     * Each key is the function name and is expected to run `createTool` and pass\n     * a generic type for that function as it will appear in the user's code.\n     */\n    const tools = {\n        /**\n         * Send one or many events to Inngest. Should always be used in place of\n         * `inngest.send()` to ensure that the event send is successfully retried\n         * and not sent multiple times due to memoisation.\n         *\n         * @example\n         * ```ts\n         * await step.sendEvent(\"emit-user-creation\", {\n         *   name: \"app/user.created\",\n         *   data: { id: 123 },\n         * });\n         *\n         * await step.sendEvent(\"emit-user-updates\", [\n         *   {\n         *     name: \"app/user.created\",\n         *     data: { id: 123 },\n         *   },\n         *   {\n         *     name: \"app/user.feed.created\",\n         *     data: { id: 123 },\n         *   },\n         * ]);\n         * ```\n         *\n         * Returns a promise that will resolve once the event has been sent.\n         */\n        sendEvent: createTool(({ id, name }) => {\n            return {\n                id,\n                op: types_js_1.StepOpCode.StepPlanned,\n                name: \"sendEvent\",\n                displayName: name !== null && name !== void 0 ? name : id,\n            };\n        }, {\n            fn: (idOrOptions, payload) => {\n                return client[\"_send\"]({\n                    payload,\n                    headers: execution[\"options\"][\"headers\"],\n                });\n            },\n        }),\n        /**\n         * EXPERIMENTAL: This API is not yet stable and may change in the future\n         * without a major version bump.\n         *\n         * Wait for a particular signal to be received before continuing. When the\n         * signal is received, its data will be returned.\n         */\n        waitForSignal: createTool(({ id, name }, opts) => {\n            // TODO Should support Temporal.DurationLike, Temporal.InstantLike,\n            // Temporal.ZonedDateTimeLike\n            return {\n                id,\n                op: types_js_1.StepOpCode.WaitForSignal,\n                name: opts.signal,\n                displayName: name !== null && name !== void 0 ? name : id,\n                opts: {\n                    signal: opts.signal,\n                    timeout: (0, strings_js_1.timeStr)(opts.timeout),\n                    conflict: opts.onConflict,\n                },\n            };\n        }),\n        /**\n         * Send a Signal to Inngest.\n         */\n        sendSignal: createTool(({ id, name }, opts) => {\n            return {\n                id,\n                op: types_js_1.StepOpCode.StepPlanned,\n                name: \"sendSignal\",\n                displayName: name !== null && name !== void 0 ? name : id,\n                opts: {\n                    type: \"step.sendSignal\",\n                    signal: opts.signal,\n                },\n            };\n        }, {\n            fn: (_idOrOptions, opts) => {\n                return client[\"_sendSignal\"]({\n                    signal: opts.signal,\n                    data: opts.data,\n                    headers: execution[\"options\"][\"headers\"],\n                });\n            },\n        }),\n        /**\n         * Wait for a particular event to be received before continuing. When the\n         * event is received, it will be returned.\n         *\n         * You can also provide options to control the particular event that is\n         * received, for example to ensure that a user ID matches between two\n         * events, or to only wait a maximum amount of time before giving up and\n         * returning `null` instead of any event data.\n         */\n        waitForEvent: createTool(({ id, name }, \n        /**\n         * Options to control the event we're waiting for.\n         */\n        opts) => {\n            const matchOpts = {\n                timeout: (0, strings_js_1.timeStr)(typeof opts === \"string\" ? opts : opts.timeout),\n            };\n            if (typeof opts !== \"string\") {\n                if (opts === null || opts === void 0 ? void 0 : opts.match) {\n                    matchOpts.if = `event.${opts.match} == async.${opts.match}`;\n                }\n                else if (opts === null || opts === void 0 ? void 0 : opts.if) {\n                    matchOpts.if = opts.if;\n                }\n            }\n            return {\n                id,\n                op: types_js_1.StepOpCode.WaitForEvent,\n                name: opts.event,\n                opts: matchOpts,\n                displayName: name !== null && name !== void 0 ? name : id,\n            };\n        }),\n        /**\n         * Use this tool to run business logic. Each call to `run` will be retried\n         * individually, meaning you can compose complex workflows that safely\n         * retry dependent asynchronous actions.\n         *\n         * The function you pass to `run` will be called only when this \"step\" is to\n         * be executed and can be synchronous or asynchronous.\n         *\n         * In either case, the return value of the function will be the return value\n         * of the `run` tool, meaning you can return and reason about return data\n         * for next steps.\n         */\n        run: createStepRun(),\n        /**\n         * AI tooling for running AI models and other AI-related tasks.\n         */\n        ai: {\n            /**\n             * Use this tool to have Inngest make your AI calls. Useful for agentic workflows.\n             *\n             * Input is also tracked for this tool, meaning you can pass input to the\n             * function and it will be displayed and editable in the UI.\n             */\n            infer: createTool(({ id, name }, options) => {\n                var _a, _b;\n                const modelCopy = Object.assign({}, options.model);\n                // Allow the model to mutate options and body for this call\n                (_b = (_a = options.model).onCall) === null || _b === void 0 ? void 0 : _b.call(_a, modelCopy, options.body);\n                return {\n                    id,\n                    op: types_js_1.StepOpCode.AiGateway,\n                    displayName: name !== null && name !== void 0 ? name : id,\n                    opts: {\n                        type: \"step.ai.infer\",\n                        url: modelCopy.url,\n                        headers: modelCopy.headers,\n                        auth_key: modelCopy.authKey,\n                        format: modelCopy.format,\n                        body: options.body,\n                    },\n                };\n            }),\n            /**\n             * Use this tool to wrap AI models and other AI-related tasks. Each call\n             * to `wrap` will be retried individually, meaning you can compose complex\n             * workflows that safely retry dependent asynchronous actions.\n             *\n             * Input is also tracked for this tool, meaning you can pass input to the\n             * function and it will be displayed and editable in the UI.\n             */\n            wrap: createStepRun(\"step.ai.wrap\"),\n            /**\n             * Models for AI inference and other AI-related tasks.\n             */\n            models: Object.assign({}, ai_1.models),\n        },\n        /**\n         * Wait a specified amount of time before continuing.\n         *\n         * The time to wait can be specified using a `number` of milliseconds or an\n         * `ms`-compatible time string like `\"1 hour\"`, `\"30 mins\"`, or `\"2.5d\"`.\n         *\n         * {@link https://npm.im/ms}\n         *\n         * To wait until a particular date, use `sleepUntil` instead.\n         */\n        sleep: createTool(({ id, name }, time) => {\n            /**\n             * The presence of this operation in the returned stack indicates that the\n             * sleep is over and we should continue execution.\n             */\n            const msTimeStr = (0, strings_js_1.timeStr)(Temporal.isTemporalDuration(time)\n                ? time.total({ unit: \"milliseconds\" })\n                : time);\n            return {\n                id,\n                op: types_js_1.StepOpCode.Sleep,\n                name: msTimeStr,\n                displayName: name !== null && name !== void 0 ? name : id,\n            };\n        }),\n        /**\n         * Wait until a particular date before continuing by passing a `Date`.\n         *\n         * To wait for a particular amount of time from now, always use `sleep`\n         * instead.\n         */\n        sleepUntil: createTool(({ id, name }, time) => {\n            try {\n                const iso = Temporal.getISOString(time);\n                /**\n                 * The presence of this operation in the returned stack indicates that the\n                 * sleep is over and we should continue execution.\n                 */\n                return {\n                    id,\n                    op: types_js_1.StepOpCode.Sleep,\n                    name: iso,\n                    displayName: name !== null && name !== void 0 ? name : id,\n                };\n            }\n            catch (err) {\n                /**\n                 * If we're here, it's because the date is invalid. We'll throw a custom\n                 * error here to standardise this response.\n                 */\n                // TODO PrettyError\n                console.warn(\"Invalid `Date`, date string, `Temporal.Instant`, or `Temporal.ZonedDateTime` passed to sleepUntil;\", err);\n                // TODO PrettyError\n                throw new Error(`Invalid \\`Date\\`, date string, \\`Temporal.Instant\\`, or \\`Temporal.ZonedDateTime\\` passed to sleepUntil: ${\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                time}`);\n            }\n        }),\n        /**\n         * Invoke a passed Inngest `function` with the given `data`. Returns the\n         * result of the returned value of the function or `null` if the function\n         * does not return a value.\n         *\n         * A string ID can also be passed to reference functions outside of the\n         * current app.\n         */\n        invoke: createTool(({ id, name }, invokeOpts) => {\n            // Create a discriminated union to operate on based on the input types\n            // available for this tool.\n            const optsSchema = exports.invokePayloadSchema.extend({\n                timeout: zod_1.z.union([zod_1.z.number(), zod_1.z.string(), zod_1.z.date()]).optional(),\n            });\n            const parsedFnOpts = optsSchema\n                .extend({\n                _type: zod_1.z.literal(\"fullId\").optional().default(\"fullId\"),\n                function: zod_1.z.string().min(1),\n            })\n                .or(optsSchema.extend({\n                _type: zod_1.z.literal(\"fnInstance\").optional().default(\"fnInstance\"),\n                function: zod_1.z.instanceof(InngestFunction_js_1.InngestFunction),\n            }))\n                .or(optsSchema.extend({\n                _type: zod_1.z.literal(\"refInstance\").optional().default(\"refInstance\"),\n                function: zod_1.z.instanceof(InngestFunctionReference_js_1.InngestFunctionReference),\n            }))\n                .safeParse(invokeOpts);\n            if (!parsedFnOpts.success) {\n                throw new Error(`Invalid invocation options passed to invoke; must include either a function or functionId.`);\n            }\n            const { _type, function: fn, data, user, v, timeout } = parsedFnOpts.data;\n            const payload = { data, user, v };\n            const opts = {\n                payload,\n                function_id: \"\",\n                timeout: typeof timeout === \"undefined\" ? undefined : (0, strings_js_1.timeStr)(timeout),\n            };\n            switch (_type) {\n                case \"fnInstance\":\n                    opts.function_id = fn.id(fn[\"client\"].id);\n                    break;\n                case \"fullId\":\n                    console.warn(`${consts_js_1.logPrefix} Invoking function with \\`function: string\\` is deprecated and will be removed in v4.0.0; use an imported function or \\`referenceFunction()\\` instead. See https://innge.st/ts-referencing-functions`);\n                    opts.function_id = fn;\n                    break;\n                case \"refInstance\":\n                    opts.function_id = [fn.opts.appId || client.id, fn.opts.functionId]\n                        .filter(Boolean)\n                        .join(\"-\");\n                    break;\n            }\n            return {\n                id,\n                op: types_js_1.StepOpCode.InvokeFunction,\n                displayName: name !== null && name !== void 0 ? name : id,\n                opts,\n            };\n        }),\n        /**\n         * `step.fetch` is a Fetch-API-compatible function that can be used to make\n         * any HTTP code durable if it's called within an Inngest function.\n         *\n         * It will gracefully fall back to the global `fetch` if called outside of\n         * this context, and a custom fallback can be set using the `config` method.\n         */\n        fetch: Fetch_js_1.fetch,\n    };\n    // Add an uptyped gateway\n    tools[exports.gatewaySymbol] = createTool(({ id, name }, input, init) => {\n        var _a;\n        const url = input instanceof Request ? input.url : input.toString();\n        const headers = {};\n        if (input instanceof Request) {\n            input.headers.forEach((value, key) => (headers[key] = value));\n        }\n        else if (init === null || init === void 0 ? void 0 : init.headers) {\n            const h = new Headers(init.headers);\n            h.forEach((value, key) => (headers[key] = value));\n        }\n        return {\n            id,\n            op: types_js_1.StepOpCode.Gateway,\n            displayName: name !== null && name !== void 0 ? name : id,\n            opts: {\n                url,\n                method: (_a = init === null || init === void 0 ? void 0 : init.method) !== null && _a !== void 0 ? _a : \"GET\",\n                headers,\n                body: init === null || init === void 0 ? void 0 : init.body,\n            },\n        };\n    });\n    return tools;\n};\nexports.createStepTools = createStepTools;\nexports.gatewaySymbol = Symbol.for(\"inngest.step.gateway\");\n/**\n * The event payload portion of the options for `step.invoke()`. This does not\n * include non-payload options like `timeout` or the function to invoke.\n */\nexports.invokePayloadSchema = zod_1.z.object({\n    data: zod_1.z.record(zod_1.z.any()).optional(),\n    user: zod_1.z.record(zod_1.z.any()).optional(),\n    v: zod_1.z.string().optional(),\n});\n//# sourceMappingURL=InngestStepTools.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RTdGVwVG9vbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMkJBQTJCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsNEJBQTRCLEdBQUcsc0JBQXNCO0FBQ3JJLGFBQWEsbUJBQU8sQ0FBQyxtRUFBYTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0Isb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLDhFQUF1QjtBQUNwRCw4QkFBOEIsbUJBQU8sQ0FBQyxnRkFBd0I7QUFDOUQsbUJBQW1CLG1CQUFPLENBQUMsMERBQWE7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsb0VBQVk7QUFDdkMsNkJBQTZCLG1CQUFPLENBQUMsd0ZBQXNCO0FBQzNELHNDQUFzQyxtQkFBTyxDQUFDLDBHQUErQjtBQUM3RTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQ0FBaUM7QUFDbEUsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2Qyx1REFBdUQsb0JBQW9CLFFBQVEsSUFBSSxjQUFjLE9BQU8sSUFBSTtBQUNoSCxtQ0FBbUMsZ0hBQWdILGdDQUFnQyxPQUFPLElBQUk7QUFDOUwsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixTQUFTO0FBQzlCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixTQUFTO0FBQ2hDLGNBQWM7QUFDZDtBQUNBO0FBQ0EsdUJBQXVCLFNBQVM7QUFDaEMsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxVQUFVO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLFVBQVU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVksV0FBVyxXQUFXO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFVBQVU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzQkFBc0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFVBQVU7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnSUFBZ0k7QUFDaEk7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxvQkFBb0IsOENBQThDO0FBQ2xFLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUIseUZBQXlGO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL0lubmdlc3RTdGVwVG9vbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW52b2tlUGF5bG9hZFNjaGVtYSA9IGV4cG9ydHMuZ2F0ZXdheVN5bWJvbCA9IGV4cG9ydHMuY3JlYXRlU3RlcFRvb2xzID0gZXhwb3J0cy5TVEVQX0lOREVYSU5HX1NVRkZJWCA9IGV4cG9ydHMuZ2V0U3RlcE9wdGlvbnMgPSB2b2lkIDA7XG5jb25zdCBhaV8xID0gcmVxdWlyZShcIkBpbm5nZXN0L2FpXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9jb25zdHMuanNcIik7XG5jb25zdCBzdHJpbmdzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9zdHJpbmdzLmpzXCIpO1xuY29uc3QgVGVtcG9yYWwgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL2hlbHBlcnMvdGVtcG9yYWwuanNcIikpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbmNvbnN0IEZldGNoX2pzXzEgPSByZXF1aXJlKFwiLi9GZXRjaC5qc1wiKTtcbmNvbnN0IElubmdlc3RGdW5jdGlvbl9qc18xID0gcmVxdWlyZShcIi4vSW5uZ2VzdEZ1bmN0aW9uLmpzXCIpO1xuY29uc3QgSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlX2pzXzEgPSByZXF1aXJlKFwiLi9Jbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2UuanNcIik7XG5jb25zdCBnZXRTdGVwT3B0aW9ucyA9IChvcHRpb25zKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7IGlkOiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufTtcbmV4cG9ydHMuZ2V0U3RlcE9wdGlvbnMgPSBnZXRTdGVwT3B0aW9ucztcbi8qKlxuICogU3VmZml4IHVzZWQgdG8gbmFtZXNwYWNlIHN0ZXBzIHRoYXQgYXJlIGF1dG9tYXRpY2FsbHkgaW5kZXhlZC5cbiAqL1xuZXhwb3J0cy5TVEVQX0lOREVYSU5HX1NVRkZJWCA9IFwiOlwiO1xuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc2V0IG9mIHN0ZXAgZnVuY3Rpb24gdG9vbHMgcmVhZHkgdG8gYmUgdXNlZCBpbiBhIHN0ZXAgZnVuY3Rpb24uXG4gKiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBydW4gYW5kIGEgZnJlc2ggc2V0IG9mIHRvb2xzIHByb3ZpZGVkIGV2ZXJ5IHRpbWUgYVxuICogZnVuY3Rpb24gaXMgcnVuLlxuICpcbiAqIEFuIG9wIHN0YWNrIChmdW5jdGlvbiBzdGF0ZSkgaXMgcGFzc2VkIGluIGFzIHdlbGwgYXMgc29tZSBtdXRhYmxlIHByb3BlcnRpZXNcbiAqIHRoYXQgdGhlIHRvb2xzIGNhbiB1c2UgdG8gc3VibWl0IGEgbmV3IG9wLlxuICovXG5jb25zdCBjcmVhdGVTdGVwVG9vbHMgPSAoY2xpZW50LCBleGVjdXRpb24sIHN0ZXBIYW5kbGVyKSA9PiB7XG4gICAgLyoqXG4gICAgICogQSBsb2NhbCBoZWxwZXIgdXNlZCB0byBjcmVhdGUgdG9vbHMgdGhhdCBjYW4gYmUgdXNlZCB0byBzdWJtaXQgYW4gb3AuXG4gICAgICpcbiAgICAgKiBXaGVuIHVzaW5nIHRoaXMgZnVuY3Rpb24sIGEgZ2VuZXJpYyB0eXBlIHNob3VsZCBiZSBwcm92aWRlZCB3aGljaCBpcyB0aGVcbiAgICAgKiBmdW5jdGlvbiBzaWduYXR1cmUgZXhwb3NlZCB0byB0aGUgdXNlci5cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IGNyZWF0ZVRvb2wgPSAoXG4gICAgLyoqXG4gICAgICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gSUQgZm9yIHRoaXMgb3AuIFRoaXMgaXMgdXNlZCB0byBlbnN1cmUgdGhhdFxuICAgICAqIHRoZSBvcCBzdGFjayBpcyBjb3JyZWN0bHkgZmlsbGVkLCBzdWJtaXR0ZWQsIGFuZCByZXRyaWV2ZWQgd2l0aCB0aGUgc2FtZVxuICAgICAqIElELlxuICAgICAqXG4gICAgICogSXQgaXMgcGFzc2VkIHRoZSBhcmd1bWVudHMgcGFzc2VkIGJ5IHRoZSB1c2VyLlxuICAgICAqXG4gICAgICogTW9zdCBzaW1wbGUgdG9vbHMgd2lsbCBsaWtlbHkgb25seSBuZWVkIHRvIGRlZmluZSB0aGlzLlxuICAgICAqL1xuICAgIG1hdGNoT3AsIG9wdHMpID0+IHtcbiAgICAgICAgcmV0dXJuIChhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGFyZ3M7XG4gICAgICAgICAgICByZXR1cm4gc3RlcEhhbmRsZXIoeyBhcmdzOiBwYXJzZWRBcmdzLCBtYXRjaE9wLCBvcHRzIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBzdGVwIHJ1biB0b29sIHRoYXQgY2FuIGJlIHVzZWQgdG8gcnVuIGEgc3RlcCBmdW5jdGlvbiB1c2luZ1xuICAgICAqIGBzdGVwLnJ1bigpYCBhcyBhIHNoaW0uXG4gICAgICovXG4gICAgY29uc3QgY3JlYXRlU3RlcFJ1biA9IChcbiAgICAvKipcbiAgICAgKiBUaGUgc3ViLXR5cGUgb2YgdGhpcyBzdGVwIHRvb2wsIGV4cG9zZWQgdmlhIGBvcHRzLnR5cGVgIHdoZW4gdGhlIG9wIGlzXG4gICAgICogcmVwb3J0ZWQuXG4gICAgICovXG4gICAgdHlwZSkgPT4ge1xuICAgICAgICByZXR1cm4gY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCBfZm4sIC4uLmlucHV0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoaW5wdXQubGVuZ3RoID8geyBpbnB1dCB9IDoge30pKSwgKHR5cGUgPyB7IHR5cGUgfSA6IHt9KSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGlkLCBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBQbGFubmVkLCBuYW1lOiBpZCwgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkIH0sIChPYmplY3Qua2V5cyhvcHRzKS5sZW5ndGggPyB7IG9wdHMgfSA6IHt9KSk7XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50XG4gICAgICAgICAgICBmbjogKF8sIGZuLCAuLi5pbnB1dCkgPT4gZm4oLi4uaW5wdXQpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlZmluZSB0aGUgc2V0IG9mIHRvb2xzIHRoZSB1c2VyIGhhcyBhY2Nlc3MgdG8gZm9yIHRoZWlyIHN0ZXAgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogRWFjaCBrZXkgaXMgdGhlIGZ1bmN0aW9uIG5hbWUgYW5kIGlzIGV4cGVjdGVkIHRvIHJ1biBgY3JlYXRlVG9vbGAgYW5kIHBhc3NcbiAgICAgKiBhIGdlbmVyaWMgdHlwZSBmb3IgdGhhdCBmdW5jdGlvbiBhcyBpdCB3aWxsIGFwcGVhciBpbiB0aGUgdXNlcidzIGNvZGUuXG4gICAgICovXG4gICAgY29uc3QgdG9vbHMgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kIG9uZSBvciBtYW55IGV2ZW50cyB0byBJbm5nZXN0LiBTaG91bGQgYWx3YXlzIGJlIHVzZWQgaW4gcGxhY2Ugb2ZcbiAgICAgICAgICogYGlubmdlc3Quc2VuZCgpYCB0byBlbnN1cmUgdGhhdCB0aGUgZXZlbnQgc2VuZCBpcyBzdWNjZXNzZnVsbHkgcmV0cmllZFxuICAgICAgICAgKiBhbmQgbm90IHNlbnQgbXVsdGlwbGUgdGltZXMgZHVlIHRvIG1lbW9pc2F0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBgYGB0c1xuICAgICAgICAgKiBhd2FpdCBzdGVwLnNlbmRFdmVudChcImVtaXQtdXNlci1jcmVhdGlvblwiLCB7XG4gICAgICAgICAqICAgbmFtZTogXCJhcHAvdXNlci5jcmVhdGVkXCIsXG4gICAgICAgICAqICAgZGF0YTogeyBpZDogMTIzIH0sXG4gICAgICAgICAqIH0pO1xuICAgICAgICAgKlxuICAgICAgICAgKiBhd2FpdCBzdGVwLnNlbmRFdmVudChcImVtaXQtdXNlci11cGRhdGVzXCIsIFtcbiAgICAgICAgICogICB7XG4gICAgICAgICAqICAgICBuYW1lOiBcImFwcC91c2VyLmNyZWF0ZWRcIixcbiAgICAgICAgICogICAgIGRhdGE6IHsgaWQ6IDEyMyB9LFxuICAgICAgICAgKiAgIH0sXG4gICAgICAgICAqICAge1xuICAgICAgICAgKiAgICAgbmFtZTogXCJhcHAvdXNlci5mZWVkLmNyZWF0ZWRcIixcbiAgICAgICAgICogICAgIGRhdGE6IHsgaWQ6IDEyMyB9LFxuICAgICAgICAgKiAgIH0sXG4gICAgICAgICAqIF0pO1xuICAgICAgICAgKiBgYGBcbiAgICAgICAgICpcbiAgICAgICAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgb25jZSB0aGUgZXZlbnQgaGFzIGJlZW4gc2VudC5cbiAgICAgICAgICovXG4gICAgICAgIHNlbmRFdmVudDogY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcFBsYW5uZWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzZW5kRXZlbnRcIixcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogaWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICBmbjogKGlkT3JPcHRpb25zLCBwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsaWVudFtcIl9zZW5kXCJdKHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogZXhlY3V0aW9uW1wib3B0aW9uc1wiXVtcImhlYWRlcnNcIl0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVYUEVSSU1FTlRBTDogVGhpcyBBUEkgaXMgbm90IHlldCBzdGFibGUgYW5kIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgKiB3aXRob3V0IGEgbWFqb3IgdmVyc2lvbiBidW1wLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXYWl0IGZvciBhIHBhcnRpY3VsYXIgc2lnbmFsIHRvIGJlIHJlY2VpdmVkIGJlZm9yZSBjb250aW51aW5nLiBXaGVuIHRoZVxuICAgICAgICAgKiBzaWduYWwgaXMgcmVjZWl2ZWQsIGl0cyBkYXRhIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICAgICAqL1xuICAgICAgICB3YWl0Rm9yU2lnbmFsOiBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIG9wdHMpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE8gU2hvdWxkIHN1cHBvcnQgVGVtcG9yYWwuRHVyYXRpb25MaWtlLCBUZW1wb3JhbC5JbnN0YW50TGlrZSxcbiAgICAgICAgICAgIC8vIFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVMaWtlXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuV2FpdEZvclNpZ25hbCxcbiAgICAgICAgICAgICAgICBuYW1lOiBvcHRzLnNpZ25hbCxcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogaWQsXG4gICAgICAgICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IG9wdHMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiAoMCwgc3RyaW5nc19qc18xLnRpbWVTdHIpKG9wdHMudGltZW91dCksXG4gICAgICAgICAgICAgICAgICAgIGNvbmZsaWN0OiBvcHRzLm9uQ29uZmxpY3QsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogU2VuZCBhIFNpZ25hbCB0byBJbm5nZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgc2VuZFNpZ25hbDogY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCBvcHRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcFBsYW5uZWQsXG4gICAgICAgICAgICAgICAgbmFtZTogXCJzZW5kU2lnbmFsXCIsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkLFxuICAgICAgICAgICAgICAgIG9wdHM6IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLnNlbmRTaWduYWxcIixcbiAgICAgICAgICAgICAgICAgICAgc2lnbmFsOiBvcHRzLnNpZ25hbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgZm46IChfaWRPck9wdGlvbnMsIG9wdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xpZW50W1wiX3NlbmRTaWduYWxcIl0oe1xuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IG9wdHMuc2lnbmFsLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBvcHRzLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IGV4ZWN1dGlvbltcIm9wdGlvbnNcIl1bXCJoZWFkZXJzXCJdLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYWl0IGZvciBhIHBhcnRpY3VsYXIgZXZlbnQgdG8gYmUgcmVjZWl2ZWQgYmVmb3JlIGNvbnRpbnVpbmcuIFdoZW4gdGhlXG4gICAgICAgICAqIGV2ZW50IGlzIHJlY2VpdmVkLCBpdCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBZb3UgY2FuIGFsc28gcHJvdmlkZSBvcHRpb25zIHRvIGNvbnRyb2wgdGhlIHBhcnRpY3VsYXIgZXZlbnQgdGhhdCBpc1xuICAgICAgICAgKiByZWNlaXZlZCwgZm9yIGV4YW1wbGUgdG8gZW5zdXJlIHRoYXQgYSB1c2VyIElEIG1hdGNoZXMgYmV0d2VlbiB0d29cbiAgICAgICAgICogZXZlbnRzLCBvciB0byBvbmx5IHdhaXQgYSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIGJlZm9yZSBnaXZpbmcgdXAgYW5kXG4gICAgICAgICAqIHJldHVybmluZyBgbnVsbGAgaW5zdGVhZCBvZiBhbnkgZXZlbnQgZGF0YS5cbiAgICAgICAgICovXG4gICAgICAgIHdhaXRGb3JFdmVudDogY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9wdGlvbnMgdG8gY29udHJvbCB0aGUgZXZlbnQgd2UncmUgd2FpdGluZyBmb3IuXG4gICAgICAgICAqL1xuICAgICAgICBvcHRzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaE9wdHMgPSB7XG4gICAgICAgICAgICAgICAgdGltZW91dDogKDAsIHN0cmluZ3NfanNfMS50aW1lU3RyKSh0eXBlb2Ygb3B0cyA9PT0gXCJzdHJpbmdcIiA/IG9wdHMgOiBvcHRzLnRpbWVvdXQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMubWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hPcHRzLmlmID0gYGV2ZW50LiR7b3B0cy5tYXRjaH0gPT0gYXN5bmMuJHtvcHRzLm1hdGNofWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5pZikge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaE9wdHMuaWYgPSBvcHRzLmlmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5XYWl0Rm9yRXZlbnQsXG4gICAgICAgICAgICAgICAgbmFtZTogb3B0cy5ldmVudCxcbiAgICAgICAgICAgICAgICBvcHRzOiBtYXRjaE9wdHMsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVc2UgdGhpcyB0b29sIHRvIHJ1biBidXNpbmVzcyBsb2dpYy4gRWFjaCBjYWxsIHRvIGBydW5gIHdpbGwgYmUgcmV0cmllZFxuICAgICAgICAgKiBpbmRpdmlkdWFsbHksIG1lYW5pbmcgeW91IGNhbiBjb21wb3NlIGNvbXBsZXggd29ya2Zsb3dzIHRoYXQgc2FmZWx5XG4gICAgICAgICAqIHJldHJ5IGRlcGVuZGVudCBhc3luY2hyb25vdXMgYWN0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIGZ1bmN0aW9uIHlvdSBwYXNzIHRvIGBydW5gIHdpbGwgYmUgY2FsbGVkIG9ubHkgd2hlbiB0aGlzIFwic3RlcFwiIGlzIHRvXG4gICAgICAgICAqIGJlIGV4ZWN1dGVkIGFuZCBjYW4gYmUgc3luY2hyb25vdXMgb3IgYXN5bmNocm9ub3VzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiBlaXRoZXIgY2FzZSwgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gd2lsbCBiZSB0aGUgcmV0dXJuIHZhbHVlXG4gICAgICAgICAqIG9mIHRoZSBgcnVuYCB0b29sLCBtZWFuaW5nIHlvdSBjYW4gcmV0dXJuIGFuZCByZWFzb24gYWJvdXQgcmV0dXJuIGRhdGFcbiAgICAgICAgICogZm9yIG5leHQgc3RlcHMuXG4gICAgICAgICAqL1xuICAgICAgICBydW46IGNyZWF0ZVN0ZXBSdW4oKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFJIHRvb2xpbmcgZm9yIHJ1bm5pbmcgQUkgbW9kZWxzIGFuZCBvdGhlciBBSS1yZWxhdGVkIHRhc2tzLlxuICAgICAgICAgKi9cbiAgICAgICAgYWk6IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXNlIHRoaXMgdG9vbCB0byBoYXZlIElubmdlc3QgbWFrZSB5b3VyIEFJIGNhbGxzLiBVc2VmdWwgZm9yIGFnZW50aWMgd29ya2Zsb3dzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIElucHV0IGlzIGFsc28gdHJhY2tlZCBmb3IgdGhpcyB0b29sLCBtZWFuaW5nIHlvdSBjYW4gcGFzcyBpbnB1dCB0byB0aGVcbiAgICAgICAgICAgICAqIGZ1bmN0aW9uIGFuZCBpdCB3aWxsIGJlIGRpc3BsYXllZCBhbmQgZWRpdGFibGUgaW4gdGhlIFVJLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpbmZlcjogY3JlYXRlVG9vbCgoeyBpZCwgbmFtZSB9LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlbENvcHkgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLm1vZGVsKTtcbiAgICAgICAgICAgICAgICAvLyBBbGxvdyB0aGUgbW9kZWwgdG8gbXV0YXRlIG9wdGlvbnMgYW5kIGJvZHkgZm9yIHRoaXMgY2FsbFxuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IG9wdGlvbnMubW9kZWwpLm9uQ2FsbCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIG1vZGVsQ29weSwgb3B0aW9ucy5ib2R5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5BaUdhdGV3YXksXG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgb3B0czoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLmFpLmluZmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IG1vZGVsQ29weS51cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiBtb2RlbENvcHkuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGF1dGhfa2V5OiBtb2RlbENvcHkuYXV0aEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogbW9kZWxDb3B5LmZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IG9wdGlvbnMuYm9keSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZSB0aGlzIHRvb2wgdG8gd3JhcCBBSSBtb2RlbHMgYW5kIG90aGVyIEFJLXJlbGF0ZWQgdGFza3MuIEVhY2ggY2FsbFxuICAgICAgICAgICAgICogdG8gYHdyYXBgIHdpbGwgYmUgcmV0cmllZCBpbmRpdmlkdWFsbHksIG1lYW5pbmcgeW91IGNhbiBjb21wb3NlIGNvbXBsZXhcbiAgICAgICAgICAgICAqIHdvcmtmbG93cyB0aGF0IHNhZmVseSByZXRyeSBkZXBlbmRlbnQgYXN5bmNocm9ub3VzIGFjdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSW5wdXQgaXMgYWxzbyB0cmFja2VkIGZvciB0aGlzIHRvb2wsIG1lYW5pbmcgeW91IGNhbiBwYXNzIGlucHV0IHRvIHRoZVxuICAgICAgICAgICAgICogZnVuY3Rpb24gYW5kIGl0IHdpbGwgYmUgZGlzcGxheWVkIGFuZCBlZGl0YWJsZSBpbiB0aGUgVUkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHdyYXA6IGNyZWF0ZVN0ZXBSdW4oXCJzdGVwLmFpLndyYXBcIiksXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1vZGVscyBmb3IgQUkgaW5mZXJlbmNlIGFuZCBvdGhlciBBSS1yZWxhdGVkIHRhc2tzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBtb2RlbHM6IE9iamVjdC5hc3NpZ24oe30sIGFpXzEubW9kZWxzKSxcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdhaXQgYSBzcGVjaWZpZWQgYW1vdW50IG9mIHRpbWUgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB0aW1lIHRvIHdhaXQgY2FuIGJlIHNwZWNpZmllZCB1c2luZyBhIGBudW1iZXJgIG9mIG1pbGxpc2Vjb25kcyBvciBhblxuICAgICAgICAgKiBgbXNgLWNvbXBhdGlibGUgdGltZSBzdHJpbmcgbGlrZSBgXCIxIGhvdXJcImAsIGBcIjMwIG1pbnNcImAsIG9yIGBcIjIuNWRcImAuXG4gICAgICAgICAqXG4gICAgICAgICAqIHtAbGluayBodHRwczovL25wbS5pbS9tc31cbiAgICAgICAgICpcbiAgICAgICAgICogVG8gd2FpdCB1bnRpbCBhIHBhcnRpY3VsYXIgZGF0ZSwgdXNlIGBzbGVlcFVudGlsYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgc2xlZXA6IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgdGltZSkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgcHJlc2VuY2Ugb2YgdGhpcyBvcGVyYXRpb24gaW4gdGhlIHJldHVybmVkIHN0YWNrIGluZGljYXRlcyB0aGF0IHRoZVxuICAgICAgICAgICAgICogc2xlZXAgaXMgb3ZlciBhbmQgd2Ugc2hvdWxkIGNvbnRpbnVlIGV4ZWN1dGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgbXNUaW1lU3RyID0gKDAsIHN0cmluZ3NfanNfMS50aW1lU3RyKShUZW1wb3JhbC5pc1RlbXBvcmFsRHVyYXRpb24odGltZSlcbiAgICAgICAgICAgICAgICA/IHRpbWUudG90YWwoeyB1bml0OiBcIm1pbGxpc2Vjb25kc1wiIH0pXG4gICAgICAgICAgICAgICAgOiB0aW1lKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TbGVlcCxcbiAgICAgICAgICAgICAgICBuYW1lOiBtc1RpbWVTdHIsXG4gICAgICAgICAgICAgICAgZGlzcGxheU5hbWU6IG5hbWUgIT09IG51bGwgJiYgbmFtZSAhPT0gdm9pZCAwID8gbmFtZSA6IGlkLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYWl0IHVudGlsIGEgcGFydGljdWxhciBkYXRlIGJlZm9yZSBjb250aW51aW5nIGJ5IHBhc3NpbmcgYSBgRGF0ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRvIHdhaXQgZm9yIGEgcGFydGljdWxhciBhbW91bnQgb2YgdGltZSBmcm9tIG5vdywgYWx3YXlzIHVzZSBgc2xlZXBgXG4gICAgICAgICAqIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICBzbGVlcFVudGlsOiBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIHRpbWUpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNvID0gVGVtcG9yYWwuZ2V0SVNPU3RyaW5nKHRpbWUpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRoZSBwcmVzZW5jZSBvZiB0aGlzIG9wZXJhdGlvbiBpbiB0aGUgcmV0dXJuZWQgc3RhY2sgaW5kaWNhdGVzIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgICogc2xlZXAgaXMgb3ZlciBhbmQgd2Ugc2hvdWxkIGNvbnRpbnVlIGV4ZWN1dGlvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TbGVlcCxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogaXNvLFxuICAgICAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogaWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSdyZSBoZXJlLCBpdCdzIGJlY2F1c2UgdGhlIGRhdGUgaXMgaW52YWxpZC4gV2UnbGwgdGhyb3cgYSBjdXN0b21cbiAgICAgICAgICAgICAgICAgKiBlcnJvciBoZXJlIHRvIHN0YW5kYXJkaXNlIHRoaXMgcmVzcG9uc2UuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkludmFsaWQgYERhdGVgLCBkYXRlIHN0cmluZywgYFRlbXBvcmFsLkluc3RhbnRgLCBvciBgVGVtcG9yYWwuWm9uZWREYXRlVGltZWAgcGFzc2VkIHRvIHNsZWVwVW50aWw7XCIsIGVycik7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBQcmV0dHlFcnJvclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBcXGBEYXRlXFxgLCBkYXRlIHN0cmluZywgXFxgVGVtcG9yYWwuSW5zdGFudFxcYCwgb3IgXFxgVGVtcG9yYWwuWm9uZWREYXRlVGltZVxcYCBwYXNzZWQgdG8gc2xlZXBVbnRpbDogJHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgICAgIHRpbWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW52b2tlIGEgcGFzc2VkIElubmdlc3QgYGZ1bmN0aW9uYCB3aXRoIHRoZSBnaXZlbiBgZGF0YWAuIFJldHVybnMgdGhlXG4gICAgICAgICAqIHJlc3VsdCBvZiB0aGUgcmV0dXJuZWQgdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIG9yIGBudWxsYCBpZiB0aGUgZnVuY3Rpb25cbiAgICAgICAgICogZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgc3RyaW5nIElEIGNhbiBhbHNvIGJlIHBhc3NlZCB0byByZWZlcmVuY2UgZnVuY3Rpb25zIG91dHNpZGUgb2YgdGhlXG4gICAgICAgICAqIGN1cnJlbnQgYXBwLlxuICAgICAgICAgKi9cbiAgICAgICAgaW52b2tlOiBjcmVhdGVUb29sKCh7IGlkLCBuYW1lIH0sIGludm9rZU9wdHMpID0+IHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGRpc2NyaW1pbmF0ZWQgdW5pb24gdG8gb3BlcmF0ZSBvbiBiYXNlZCBvbiB0aGUgaW5wdXQgdHlwZXNcbiAgICAgICAgICAgIC8vIGF2YWlsYWJsZSBmb3IgdGhpcyB0b29sLlxuICAgICAgICAgICAgY29uc3Qgb3B0c1NjaGVtYSA9IGV4cG9ydHMuaW52b2tlUGF5bG9hZFNjaGVtYS5leHRlbmQoe1xuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHpvZF8xLnoudW5pb24oW3pvZF8xLnoubnVtYmVyKCksIHpvZF8xLnouc3RyaW5nKCksIHpvZF8xLnouZGF0ZSgpXSkub3B0aW9uYWwoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkRm5PcHRzID0gb3B0c1NjaGVtYVxuICAgICAgICAgICAgICAgIC5leHRlbmQoe1xuICAgICAgICAgICAgICAgIF90eXBlOiB6b2RfMS56LmxpdGVyYWwoXCJmdWxsSWRcIikub3B0aW9uYWwoKS5kZWZhdWx0KFwiZnVsbElkXCIpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB6b2RfMS56LnN0cmluZygpLm1pbigxKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9yKG9wdHNTY2hlbWEuZXh0ZW5kKHtcbiAgICAgICAgICAgICAgICBfdHlwZTogem9kXzEuei5saXRlcmFsKFwiZm5JbnN0YW5jZVwiKS5vcHRpb25hbCgpLmRlZmF1bHQoXCJmbkluc3RhbmNlXCIpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB6b2RfMS56Lmluc3RhbmNlb2YoSW5uZ2VzdEZ1bmN0aW9uX2pzXzEuSW5uZ2VzdEZ1bmN0aW9uKSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5vcihvcHRzU2NoZW1hLmV4dGVuZCh7XG4gICAgICAgICAgICAgICAgX3R5cGU6IHpvZF8xLnoubGl0ZXJhbChcInJlZkluc3RhbmNlXCIpLm9wdGlvbmFsKCkuZGVmYXVsdChcInJlZkluc3RhbmNlXCIpLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiB6b2RfMS56Lmluc3RhbmNlb2YoSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlX2pzXzEuSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlKSxcbiAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgICAgIC5zYWZlUGFyc2UoaW52b2tlT3B0cyk7XG4gICAgICAgICAgICBpZiAoIXBhcnNlZEZuT3B0cy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGludm9jYXRpb24gb3B0aW9ucyBwYXNzZWQgdG8gaW52b2tlOyBtdXN0IGluY2x1ZGUgZWl0aGVyIGEgZnVuY3Rpb24gb3IgZnVuY3Rpb25JZC5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgX3R5cGUsIGZ1bmN0aW9uOiBmbiwgZGF0YSwgdXNlciwgdiwgdGltZW91dCB9ID0gcGFyc2VkRm5PcHRzLmRhdGE7XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0geyBkYXRhLCB1c2VyLCB2IH07XG4gICAgICAgICAgICBjb25zdCBvcHRzID0ge1xuICAgICAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICAgICAgZnVuY3Rpb25faWQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdGltZW91dDogdHlwZW9mIHRpbWVvdXQgPT09IFwidW5kZWZpbmVkXCIgPyB1bmRlZmluZWQgOiAoMCwgc3RyaW5nc19qc18xLnRpbWVTdHIpKHRpbWVvdXQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN3aXRjaCAoX3R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZm5JbnN0YW5jZVwiOlxuICAgICAgICAgICAgICAgICAgICBvcHRzLmZ1bmN0aW9uX2lkID0gZm4uaWQoZm5bXCJjbGllbnRcIl0uaWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZnVsbElkXCI6XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgJHtjb25zdHNfanNfMS5sb2dQcmVmaXh9IEludm9raW5nIGZ1bmN0aW9uIHdpdGggXFxgZnVuY3Rpb246IHN0cmluZ1xcYCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gdjQuMC4wOyB1c2UgYW4gaW1wb3J0ZWQgZnVuY3Rpb24gb3IgXFxgcmVmZXJlbmNlRnVuY3Rpb24oKVxcYCBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly9pbm5nZS5zdC90cy1yZWZlcmVuY2luZy1mdW5jdGlvbnNgKTtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5mdW5jdGlvbl9pZCA9IGZuO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVmSW5zdGFuY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5mdW5jdGlvbl9pZCA9IFtmbi5vcHRzLmFwcElkIHx8IGNsaWVudC5pZCwgZm4ub3B0cy5mdW5jdGlvbklkXVxuICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oXCItXCIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5JbnZva2VGdW5jdGlvbixcbiAgICAgICAgICAgICAgICBkaXNwbGF5TmFtZTogbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogaWQsXG4gICAgICAgICAgICAgICAgb3B0cyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgICAgICAvKipcbiAgICAgICAgICogYHN0ZXAuZmV0Y2hgIGlzIGEgRmV0Y2gtQVBJLWNvbXBhdGlibGUgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBtYWtlXG4gICAgICAgICAqIGFueSBIVFRQIGNvZGUgZHVyYWJsZSBpZiBpdCdzIGNhbGxlZCB3aXRoaW4gYW4gSW5uZ2VzdCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSXQgd2lsbCBncmFjZWZ1bGx5IGZhbGwgYmFjayB0byB0aGUgZ2xvYmFsIGBmZXRjaGAgaWYgY2FsbGVkIG91dHNpZGUgb2ZcbiAgICAgICAgICogdGhpcyBjb250ZXh0LCBhbmQgYSBjdXN0b20gZmFsbGJhY2sgY2FuIGJlIHNldCB1c2luZyB0aGUgYGNvbmZpZ2AgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgZmV0Y2g6IEZldGNoX2pzXzEuZmV0Y2gsXG4gICAgfTtcbiAgICAvLyBBZGQgYW4gdXB0eXBlZCBnYXRld2F5XG4gICAgdG9vbHNbZXhwb3J0cy5nYXRld2F5U3ltYm9sXSA9IGNyZWF0ZVRvb2woKHsgaWQsIG5hbWUgfSwgaW5wdXQsIGluaXQpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB1cmwgPSBpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QgPyBpbnB1dC51cmwgOiBpbnB1dC50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFJlcXVlc3QpIHtcbiAgICAgICAgICAgIGlucHV0LmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gKGhlYWRlcnNba2V5XSA9IHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0LmhlYWRlcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGggPSBuZXcgSGVhZGVycyhpbml0LmhlYWRlcnMpO1xuICAgICAgICAgICAgaC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiAoaGVhZGVyc1trZXldID0gdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBvcDogdHlwZXNfanNfMS5TdGVwT3BDb2RlLkdhdGV3YXksXG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogaWQsXG4gICAgICAgICAgICBvcHRzOiB7XG4gICAgICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogKF9hID0gaW5pdCA9PT0gbnVsbCB8fCBpbml0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0Lm1ldGhvZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgICAgIGJvZHk6IGluaXQgPT09IG51bGwgfHwgaW5pdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5pdC5ib2R5LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gdG9vbHM7XG59O1xuZXhwb3J0cy5jcmVhdGVTdGVwVG9vbHMgPSBjcmVhdGVTdGVwVG9vbHM7XG5leHBvcnRzLmdhdGV3YXlTeW1ib2wgPSBTeW1ib2wuZm9yKFwiaW5uZ2VzdC5zdGVwLmdhdGV3YXlcIik7XG4vKipcbiAqIFRoZSBldmVudCBwYXlsb2FkIHBvcnRpb24gb2YgdGhlIG9wdGlvbnMgZm9yIGBzdGVwLmludm9rZSgpYC4gVGhpcyBkb2VzIG5vdFxuICogaW5jbHVkZSBub24tcGF5bG9hZCBvcHRpb25zIGxpa2UgYHRpbWVvdXRgIG9yIHRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gKi9cbmV4cG9ydHMuaW52b2tlUGF5bG9hZFNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBkYXRhOiB6b2RfMS56LnJlY29yZCh6b2RfMS56LmFueSgpKS5vcHRpb25hbCgpLFxuICAgIHVzZXI6IHpvZF8xLnoucmVjb3JkKHpvZF8xLnouYW55KCkpLm9wdGlvbmFsKCksXG4gICAgdjogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Jbm5nZXN0U3RlcFRvb2xzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/InngestStepTools.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/NonRetriableError.js":
/*!**************************************************************!*\
  !*** ./node_modules/inngest/components/NonRetriableError.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.NonRetriableError = void 0;\n/**\n * An error that, when thrown, indicates to Inngest that the function should\n * cease all execution and not retry.\n *\n * A `message` must be provided, and an optional `cause` can be provided to\n * provide more context to the error.\n *\n * @public\n */\nclass NonRetriableError extends Error {\n    constructor(message, options) {\n        super(message);\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.cause = options === null || options === void 0 ? void 0 : options.cause;\n        this.name = \"NonRetriableError\";\n    }\n}\nexports.NonRetriableError = NonRetriableError;\n//# sourceMappingURL=NonRetriableError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL05vblJldHJpYWJsZUVycm9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCIiwic291cmNlcyI6WyIvVXNlcnMvaGFyc2hzaHJpdmFzdGF2L0Rlc2t0b3AvQ29kaW5nIFByb2plY3RzL0pvYi1Bc3Npc3RhbnQtQWdlbnQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9Ob25SZXRyaWFibGVFcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTm9uUmV0cmlhYmxlRXJyb3IgPSB2b2lkIDA7XG4vKipcbiAqIEFuIGVycm9yIHRoYXQsIHdoZW4gdGhyb3duLCBpbmRpY2F0ZXMgdG8gSW5uZ2VzdCB0aGF0IHRoZSBmdW5jdGlvbiBzaG91bGRcbiAqIGNlYXNlIGFsbCBleGVjdXRpb24gYW5kIG5vdCByZXRyeS5cbiAqXG4gKiBBIGBtZXNzYWdlYCBtdXN0IGJlIHByb3ZpZGVkLCBhbmQgYW4gb3B0aW9uYWwgYGNhdXNlYCBjYW4gYmUgcHJvdmlkZWQgdG9cbiAqIHByb3ZpZGUgbW9yZSBjb250ZXh0IHRvIHRoZSBlcnJvci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIE5vblJldHJpYWJsZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgdGhpcy5jYXVzZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXVzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJOb25SZXRyaWFibGVFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9uUmV0cmlhYmxlRXJyb3IgPSBOb25SZXRyaWFibGVFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU5vblJldHJpYWJsZUVycm9yLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/NonRetriableError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/RetryAfterError.js":
/*!************************************************************!*\
  !*** ./node_modules/inngest/components/RetryAfterError.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.RetryAfterError = void 0;\nconst ms_1 = __importDefault(__webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\"));\n/**\n * An error that, when thrown, indicates to Inngest that the function should be\n * retried after a given amount of time.\n *\n * A `message` must be provided, as well as a `retryAfter` parameter, which can\n * be a `number` of milliseconds, an `ms`-compatible time string, or a `Date`.\n *\n * An optional `cause` can be provided to provide more context to the error.\n *\n * @public\n */\nclass RetryAfterError extends Error {\n    constructor(message, \n    /**\n     * The time after which the function should be retried. Represents either a\n     * number of milliseconds or a RFC3339 date.\n     */\n    retryAfter, options) {\n        super(message);\n        if (retryAfter instanceof Date) {\n            this.retryAfter = retryAfter.toISOString();\n        }\n        else {\n            const seconds = `${Math.ceil((typeof retryAfter === \"string\" ? (0, ms_1.default)(retryAfter) : retryAfter) / 1000)}`;\n            if (!isFinite(Number(seconds))) {\n                throw new Error(\"retryAfter must be a number of milliseconds, a ms-compatible string, or a Date\");\n            }\n            this.retryAfter = seconds;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.cause = options === null || options === void 0 ? void 0 : options.cause;\n    }\n}\nexports.RetryAfterError = RetryAfterError;\n//# sourceMappingURL=RetryAfterError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1JldHJ5QWZ0ZXJFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2Qiw2QkFBNkIsbUJBQU8sQ0FBQyw0Q0FBSTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdHQUFnRztBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1JldHJ5QWZ0ZXJFcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmV0cnlBZnRlckVycm9yID0gdm9pZCAwO1xuY29uc3QgbXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibXNcIikpO1xuLyoqXG4gKiBBbiBlcnJvciB0aGF0LCB3aGVuIHRocm93biwgaW5kaWNhdGVzIHRvIElubmdlc3QgdGhhdCB0aGUgZnVuY3Rpb24gc2hvdWxkIGJlXG4gKiByZXRyaWVkIGFmdGVyIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUuXG4gKlxuICogQSBgbWVzc2FnZWAgbXVzdCBiZSBwcm92aWRlZCwgYXMgd2VsbCBhcyBhIGByZXRyeUFmdGVyYCBwYXJhbWV0ZXIsIHdoaWNoIGNhblxuICogYmUgYSBgbnVtYmVyYCBvZiBtaWxsaXNlY29uZHMsIGFuIGBtc2AtY29tcGF0aWJsZSB0aW1lIHN0cmluZywgb3IgYSBgRGF0ZWAuXG4gKlxuICogQW4gb3B0aW9uYWwgYGNhdXNlYCBjYW4gYmUgcHJvdmlkZWQgdG8gcHJvdmlkZSBtb3JlIGNvbnRleHQgdG8gdGhlIGVycm9yLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgUmV0cnlBZnRlckVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIFxuICAgIC8qKlxuICAgICAqIFRoZSB0aW1lIGFmdGVyIHdoaWNoIHRoZSBmdW5jdGlvbiBzaG91bGQgYmUgcmV0cmllZC4gUmVwcmVzZW50cyBlaXRoZXIgYVxuICAgICAqIG51bWJlciBvZiBtaWxsaXNlY29uZHMgb3IgYSBSRkMzMzM5IGRhdGUuXG4gICAgICovXG4gICAgcmV0cnlBZnRlciwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgaWYgKHJldHJ5QWZ0ZXIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5QWZ0ZXIgPSByZXRyeUFmdGVyLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzZWNvbmRzID0gYCR7TWF0aC5jZWlsKCh0eXBlb2YgcmV0cnlBZnRlciA9PT0gXCJzdHJpbmdcIiA/ICgwLCBtc18xLmRlZmF1bHQpKHJldHJ5QWZ0ZXIpIDogcmV0cnlBZnRlcikgLyAxMDAwKX1gO1xuICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShOdW1iZXIoc2Vjb25kcykpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmV0cnlBZnRlciBtdXN0IGJlIGEgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYSBtcy1jb21wYXRpYmxlIHN0cmluZywgb3IgYSBEYXRlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXRyeUFmdGVyID0gc2Vjb25kcztcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgIHRoaXMuY2F1c2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2F1c2U7XG4gICAgfVxufVxuZXhwb3J0cy5SZXRyeUFmdGVyRXJyb3IgPSBSZXRyeUFmdGVyRXJyb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZXRyeUFmdGVyRXJyb3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/RetryAfterError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/StepError.js":
/*!******************************************************!*\
  !*** ./node_modules/inngest/components/StepError.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StepError = void 0;\nconst errors_js_1 = __webpack_require__(/*! ../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\n/**\n * An error that represents a step exhausting all retries and failing. This is\n * thrown by an Inngest step if it fails.\n *\n * It's synonymous with an `Error`, with the addition of the `stepId` that\n * failed.\n *\n * @public\n */\nclass StepError extends Error {\n    constructor(\n    /**\n     * The ID of the step that failed.\n     */\n    stepId, err) {\n        var _a;\n        const parsedErr = types_js_1.jsonErrorSchema.parse(err);\n        super(parsedErr.message);\n        this.stepId = stepId;\n        this.name = parsedErr.name;\n        this.stepId = stepId;\n        // Don't show the internal stack trace if we don't have one.\n        this.stack = (_a = parsedErr.stack) !== null && _a !== void 0 ? _a : undefined;\n        // Try setting the cause if we have one\n        this.cause = parsedErr.cause\n            ? (0, errors_js_1.deserializeError)(parsedErr.cause, true)\n            : undefined;\n    }\n}\nexports.StepError = StepError;\n//# sourceMappingURL=StepError.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1N0ZXBFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsb0JBQW9CLG1CQUFPLENBQUMsNEVBQXNCO0FBQ2xELG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL1N0ZXBFcnJvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RlcEVycm9yID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzX2pzXzEgPSByZXF1aXJlKFwiLi4vaGVscGVycy9lcnJvcnMuanNcIik7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4uL3R5cGVzLmpzXCIpO1xuLyoqXG4gKiBBbiBlcnJvciB0aGF0IHJlcHJlc2VudHMgYSBzdGVwIGV4aGF1c3RpbmcgYWxsIHJldHJpZXMgYW5kIGZhaWxpbmcuIFRoaXMgaXNcbiAqIHRocm93biBieSBhbiBJbm5nZXN0IHN0ZXAgaWYgaXQgZmFpbHMuXG4gKlxuICogSXQncyBzeW5vbnltb3VzIHdpdGggYW4gYEVycm9yYCwgd2l0aCB0aGUgYWRkaXRpb24gb2YgdGhlIGBzdGVwSWRgIHRoYXRcbiAqIGZhaWxlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNsYXNzIFN0ZXBFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICAgKiBUaGUgSUQgb2YgdGhlIHN0ZXAgdGhhdCBmYWlsZWQuXG4gICAgICovXG4gICAgc3RlcElkLCBlcnIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBwYXJzZWRFcnIgPSB0eXBlc19qc18xLmpzb25FcnJvclNjaGVtYS5wYXJzZShlcnIpO1xuICAgICAgICBzdXBlcihwYXJzZWRFcnIubWVzc2FnZSk7XG4gICAgICAgIHRoaXMuc3RlcElkID0gc3RlcElkO1xuICAgICAgICB0aGlzLm5hbWUgPSBwYXJzZWRFcnIubmFtZTtcbiAgICAgICAgdGhpcy5zdGVwSWQgPSBzdGVwSWQ7XG4gICAgICAgIC8vIERvbid0IHNob3cgdGhlIGludGVybmFsIHN0YWNrIHRyYWNlIGlmIHdlIGRvbid0IGhhdmUgb25lLlxuICAgICAgICB0aGlzLnN0YWNrID0gKF9hID0gcGFyc2VkRXJyLnN0YWNrKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICAgIC8vIFRyeSBzZXR0aW5nIHRoZSBjYXVzZSBpZiB3ZSBoYXZlIG9uZVxuICAgICAgICB0aGlzLmNhdXNlID0gcGFyc2VkRXJyLmNhdXNlXG4gICAgICAgICAgICA/ICgwLCBlcnJvcnNfanNfMS5kZXNlcmlhbGl6ZUVycm9yKShwYXJzZWRFcnIuY2F1c2UsIHRydWUpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlN0ZXBFcnJvciA9IFN0ZXBFcnJvcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0ZXBFcnJvci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/StepError.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/InngestExecution.js":
/*!***********************************************************************!*\
  !*** ./node_modules/inngest/components/execution/InngestExecution.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestExecution = exports.PREFERRED_EXECUTION_VERSION = exports.ExecutionVersion = void 0;\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst consts_js_1 = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\n/**\n * The execution models the SDK is aware of.\n *\n * This is used in a number of places to ensure all execution versions are\n * accounted for for a given operation.\n */\nvar ExecutionVersion;\n(function (ExecutionVersion) {\n    ExecutionVersion[ExecutionVersion[\"V0\"] = 0] = \"V0\";\n    ExecutionVersion[ExecutionVersion[\"V1\"] = 1] = \"V1\";\n    ExecutionVersion[ExecutionVersion[\"V2\"] = 2] = \"V2\";\n})(ExecutionVersion || (exports.ExecutionVersion = ExecutionVersion = {}));\n/**\n * The preferred execution version that will be used by the SDK when handling\n * brand new runs where the Executor is allowing us to choose.\n *\n * Changing this should not ever be a breaking change, as this will only change\n * new runs, not existing ones.\n */\nexports.PREFERRED_EXECUTION_VERSION = ExecutionVersion.V1;\nclass InngestExecution {\n    constructor(options) {\n        this.options = options;\n        this.debug = (0, debug_1.default)(`${consts_js_1.debugPrefix}:${this.options.runId}`);\n    }\n}\nexports.InngestExecution = InngestExecution;\n//# sourceMappingURL=InngestExecution.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsbUNBQW1DLEdBQUcsd0JBQXdCO0FBQ3pGLGdDQUFnQyxtQkFBTyxDQUFDLHNEQUFPO0FBQy9DLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyx1QkFBdUIsd0JBQXdCLHdCQUF3QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCLEdBQUcsbUJBQW1CO0FBQzNGO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Jbm5nZXN0RXhlY3V0aW9uID0gZXhwb3J0cy5QUkVGRVJSRURfRVhFQ1VUSU9OX1ZFUlNJT04gPSBleHBvcnRzLkV4ZWN1dGlvblZlcnNpb24gPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL2NvbnN0cy5qc1wiKTtcbi8qKlxuICogVGhlIGV4ZWN1dGlvbiBtb2RlbHMgdGhlIFNESyBpcyBhd2FyZSBvZi5cbiAqXG4gKiBUaGlzIGlzIHVzZWQgaW4gYSBudW1iZXIgb2YgcGxhY2VzIHRvIGVuc3VyZSBhbGwgZXhlY3V0aW9uIHZlcnNpb25zIGFyZVxuICogYWNjb3VudGVkIGZvciBmb3IgYSBnaXZlbiBvcGVyYXRpb24uXG4gKi9cbnZhciBFeGVjdXRpb25WZXJzaW9uO1xuKGZ1bmN0aW9uIChFeGVjdXRpb25WZXJzaW9uKSB7XG4gICAgRXhlY3V0aW9uVmVyc2lvbltFeGVjdXRpb25WZXJzaW9uW1wiVjBcIl0gPSAwXSA9IFwiVjBcIjtcbiAgICBFeGVjdXRpb25WZXJzaW9uW0V4ZWN1dGlvblZlcnNpb25bXCJWMVwiXSA9IDFdID0gXCJWMVwiO1xuICAgIEV4ZWN1dGlvblZlcnNpb25bRXhlY3V0aW9uVmVyc2lvbltcIlYyXCJdID0gMl0gPSBcIlYyXCI7XG59KShFeGVjdXRpb25WZXJzaW9uIHx8IChleHBvcnRzLkV4ZWN1dGlvblZlcnNpb24gPSBFeGVjdXRpb25WZXJzaW9uID0ge30pKTtcbi8qKlxuICogVGhlIHByZWZlcnJlZCBleGVjdXRpb24gdmVyc2lvbiB0aGF0IHdpbGwgYmUgdXNlZCBieSB0aGUgU0RLIHdoZW4gaGFuZGxpbmdcbiAqIGJyYW5kIG5ldyBydW5zIHdoZXJlIHRoZSBFeGVjdXRvciBpcyBhbGxvd2luZyB1cyB0byBjaG9vc2UuXG4gKlxuICogQ2hhbmdpbmcgdGhpcyBzaG91bGQgbm90IGV2ZXIgYmUgYSBicmVha2luZyBjaGFuZ2UsIGFzIHRoaXMgd2lsbCBvbmx5IGNoYW5nZVxuICogbmV3IHJ1bnMsIG5vdCBleGlzdGluZyBvbmVzLlxuICovXG5leHBvcnRzLlBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTiA9IEV4ZWN1dGlvblZlcnNpb24uVjE7XG5jbGFzcyBJbm5nZXN0RXhlY3V0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtjb25zdHNfanNfMS5kZWJ1Z1ByZWZpeH06JHt0aGlzLm9wdGlvbnMucnVuSWR9YCk7XG4gICAgfVxufVxuZXhwb3J0cy5Jbm5nZXN0RXhlY3V0aW9uID0gSW5uZ2VzdEV4ZWN1dGlvbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUlubmdlc3RFeGVjdXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/als.js":
/*!**********************************************************!*\
  !*** ./node_modules/inngest/components/execution/als.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || (function () {\n    var ownKeys = function(o) {\n        ownKeys = Object.getOwnPropertyNames || function (o) {\n            var ar = [];\n            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n            return ar;\n        };\n        return ownKeys(o);\n    };\n    return function (mod) {\n        if (mod && mod.__esModule) return mod;\n        var result = {};\n        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n        __setModuleDefault(result, mod);\n        return result;\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getAsyncLocalStorage = exports.getAsyncCtx = void 0;\n/**\n * A local-only symbol used as a key in global state to store the async local\n * storage instance.\n */\nconst alsSymbol = Symbol.for(\"inngest:als\");\n/**\n * Retrieve the async context for the current execution.\n */\nconst getAsyncCtx = async () => {\n    return (0, exports.getAsyncLocalStorage)().then((als) => als.getStore());\n};\nexports.getAsyncCtx = getAsyncCtx;\n/**\n * Get a singleton instance of `AsyncLocalStorage` used to store and retrieve\n * async context for the current execution.\n */\nconst getAsyncLocalStorage = async () => {\n    var _a;\n    var _b;\n    (_a = (_b = globalThis)[alsSymbol]) !== null && _a !== void 0 ? _a : (_b[alsSymbol] = new Promise(\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n    async (resolve) => {\n        try {\n            const { AsyncLocalStorage } = await Promise.resolve().then(() => __importStar(__webpack_require__(/*! node:async_hooks */ \"node:async_hooks\")));\n            resolve(new AsyncLocalStorage());\n        }\n        catch (err) {\n            console.warn(\"node:async_hooks is not supported in this runtime. Experimental async context is disabled.\");\n            resolve({\n                getStore: () => undefined,\n                run: (_, fn) => fn(),\n            });\n        }\n    }));\n    return globalThis[alsSymbol];\n};\nexports.getAsyncLocalStorage = getAsyncLocalStorage;\n//# sourceMappingURL=als.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9hbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxjQUFjO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0Isa0RBQWtELG1CQUFPLENBQUMsMENBQWtCO0FBQ3BIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9hbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG93bktleXMgPSBmdW5jdGlvbihvKSB7XG4gICAgICAgIG93bktleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyB8fCBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgdmFyIGFyID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgICAgICAgICAgcmV0dXJuIGFyO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb3duS2V5cyhvKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kKSB7XG4gICAgICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrID0gb3duS2V5cyhtb2QpLCBpID0gMDsgaSA8IGsubGVuZ3RoOyBpKyspIGlmIChrW2ldICE9PSBcImRlZmF1bHRcIikgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrW2ldKTtcbiAgICAgICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0QXN5bmNMb2NhbFN0b3JhZ2UgPSBleHBvcnRzLmdldEFzeW5jQ3R4ID0gdm9pZCAwO1xuLyoqXG4gKiBBIGxvY2FsLW9ubHkgc3ltYm9sIHVzZWQgYXMgYSBrZXkgaW4gZ2xvYmFsIHN0YXRlIHRvIHN0b3JlIHRoZSBhc3luYyBsb2NhbFxuICogc3RvcmFnZSBpbnN0YW5jZS5cbiAqL1xuY29uc3QgYWxzU3ltYm9sID0gU3ltYm9sLmZvcihcImlubmdlc3Q6YWxzXCIpO1xuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYXN5bmMgY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgZXhlY3V0aW9uLlxuICovXG5jb25zdCBnZXRBc3luY0N0eCA9IGFzeW5jICgpID0+IHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuZ2V0QXN5bmNMb2NhbFN0b3JhZ2UpKCkudGhlbigoYWxzKSA9PiBhbHMuZ2V0U3RvcmUoKSk7XG59O1xuZXhwb3J0cy5nZXRBc3luY0N0eCA9IGdldEFzeW5jQ3R4O1xuLyoqXG4gKiBHZXQgYSBzaW5nbGV0b24gaW5zdGFuY2Ugb2YgYEFzeW5jTG9jYWxTdG9yYWdlYCB1c2VkIHRvIHN0b3JlIGFuZCByZXRyaWV2ZVxuICogYXN5bmMgY29udGV4dCBmb3IgdGhlIGN1cnJlbnQgZXhlY3V0aW9uLlxuICovXG5jb25zdCBnZXRBc3luY0xvY2FsU3RvcmFnZSA9IGFzeW5jICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIF9iO1xuICAgIChfYSA9IChfYiA9IGdsb2JhbFRoaXMpW2Fsc1N5bWJvbF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYlthbHNTeW1ib2xdID0gbmV3IFByb21pc2UoXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzLCBuby1hc3luYy1wcm9taXNlLWV4ZWN1dG9yXG4gICAgYXN5bmMgKHJlc29sdmUpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHsgQXN5bmNMb2NhbFN0b3JhZ2UgfSA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJub2RlOmFzeW5jX2hvb2tzXCIpKSk7XG4gICAgICAgICAgICByZXNvbHZlKG5ldyBBc3luY0xvY2FsU3RvcmFnZSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJub2RlOmFzeW5jX2hvb2tzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBydW50aW1lLiBFeHBlcmltZW50YWwgYXN5bmMgY29udGV4dCBpcyBkaXNhYmxlZC5cIik7XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICBnZXRTdG9yZTogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJ1bjogKF8sIGZuKSA9PiBmbigpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9KSk7XG4gICAgcmV0dXJuIGdsb2JhbFRoaXNbYWxzU3ltYm9sXTtcbn07XG5leHBvcnRzLmdldEFzeW5jTG9jYWxTdG9yYWdlID0gZ2V0QXN5bmNMb2NhbFN0b3JhZ2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/als.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/access.js":
/*!******************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/access.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * A file used to access client processors safely without also importing any\n * otel-specific libraries. Useful for ensuring that the otel libraries can be\n * tree-shaken if they're not used directly by the user.\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.clientProcessorMap = void 0;\n/**\n * A map of Inngest clients to their OTel span processors. This is used to\n * ensure that we only create one span processor per client, and that we can\n * access the span processor from the client without exposing the OTel\n * libraries to the user.\n */\nexports.clientProcessorMap = new WeakMap();\n//# sourceMappingURL=access.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL2FjY2Vzcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL290ZWwvYWNjZXNzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBIGZpbGUgdXNlZCB0byBhY2Nlc3MgY2xpZW50IHByb2Nlc3NvcnMgc2FmZWx5IHdpdGhvdXQgYWxzbyBpbXBvcnRpbmcgYW55XG4gKiBvdGVsLXNwZWNpZmljIGxpYnJhcmllcy4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IHRoZSBvdGVsIGxpYnJhcmllcyBjYW4gYmVcbiAqIHRyZWUtc2hha2VuIGlmIHRoZXkncmUgbm90IHVzZWQgZGlyZWN0bHkgYnkgdGhlIHVzZXIuXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2xpZW50UHJvY2Vzc29yTWFwID0gdm9pZCAwO1xuLyoqXG4gKiBBIG1hcCBvZiBJbm5nZXN0IGNsaWVudHMgdG8gdGhlaXIgT1RlbCBzcGFuIHByb2Nlc3NvcnMuIFRoaXMgaXMgdXNlZCB0b1xuICogZW5zdXJlIHRoYXQgd2Ugb25seSBjcmVhdGUgb25lIHNwYW4gcHJvY2Vzc29yIHBlciBjbGllbnQsIGFuZCB0aGF0IHdlIGNhblxuICogYWNjZXNzIHRoZSBzcGFuIHByb2Nlc3NvciBmcm9tIHRoZSBjbGllbnQgd2l0aG91dCBleHBvc2luZyB0aGUgT1RlbFxuICogbGlicmFyaWVzIHRvIHRoZSB1c2VyLlxuICovXG5leHBvcnRzLmNsaWVudFByb2Nlc3Nvck1hcCA9IG5ldyBXZWFrTWFwKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY2Nlc3MuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/access.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/consts.js":
/*!******************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/consts.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Attribute = exports.TraceStateKey = exports.debugPrefix = void 0;\nexports.debugPrefix = \"inngest:otel\";\nvar TraceStateKey;\n(function (TraceStateKey) {\n    TraceStateKey[\"AppId\"] = \"inngest@app\";\n    TraceStateKey[\"FunctionId\"] = \"inngest@fn\";\n})(TraceStateKey || (exports.TraceStateKey = TraceStateKey = {}));\nvar Attribute;\n(function (Attribute) {\n    Attribute[\"InngestTraceparent\"] = \"inngest.traceparent\";\n    Attribute[\"InngestRunId\"] = \"sdk.run.id\";\n    Attribute[\"InngestAppId1\"] = \"sdk.app.id\";\n    Attribute[\"InngestAppId2\"] = \"sys.app.id\";\n    Attribute[\"InngestFunctionId\"] = \"sys.function.id\";\n})(Attribute || (exports.Attribute = Attribute = {}));\n//# sourceMappingURL=consts.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL2NvbnN0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsR0FBRyxxQkFBcUIsR0FBRyxtQkFBbUI7QUFDL0QsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxvQkFBb0IscUJBQXFCLHFCQUFxQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCLGlCQUFpQixpQkFBaUI7QUFDbkQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL2NvbnN0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXR0cmlidXRlID0gZXhwb3J0cy5UcmFjZVN0YXRlS2V5ID0gZXhwb3J0cy5kZWJ1Z1ByZWZpeCA9IHZvaWQgMDtcbmV4cG9ydHMuZGVidWdQcmVmaXggPSBcImlubmdlc3Q6b3RlbFwiO1xudmFyIFRyYWNlU3RhdGVLZXk7XG4oZnVuY3Rpb24gKFRyYWNlU3RhdGVLZXkpIHtcbiAgICBUcmFjZVN0YXRlS2V5W1wiQXBwSWRcIl0gPSBcImlubmdlc3RAYXBwXCI7XG4gICAgVHJhY2VTdGF0ZUtleVtcIkZ1bmN0aW9uSWRcIl0gPSBcImlubmdlc3RAZm5cIjtcbn0pKFRyYWNlU3RhdGVLZXkgfHwgKGV4cG9ydHMuVHJhY2VTdGF0ZUtleSA9IFRyYWNlU3RhdGVLZXkgPSB7fSkpO1xudmFyIEF0dHJpYnV0ZTtcbihmdW5jdGlvbiAoQXR0cmlidXRlKSB7XG4gICAgQXR0cmlidXRlW1wiSW5uZ2VzdFRyYWNlcGFyZW50XCJdID0gXCJpbm5nZXN0LnRyYWNlcGFyZW50XCI7XG4gICAgQXR0cmlidXRlW1wiSW5uZ2VzdFJ1bklkXCJdID0gXCJzZGsucnVuLmlkXCI7XG4gICAgQXR0cmlidXRlW1wiSW5uZ2VzdEFwcElkMVwiXSA9IFwic2RrLmFwcC5pZFwiO1xuICAgIEF0dHJpYnV0ZVtcIklubmdlc3RBcHBJZDJcIl0gPSBcInN5cy5hcHAuaWRcIjtcbiAgICBBdHRyaWJ1dGVbXCJJbm5nZXN0RnVuY3Rpb25JZFwiXSA9IFwic3lzLmZ1bmN0aW9uLmlkXCI7XG59KShBdHRyaWJ1dGUgfHwgKGV4cG9ydHMuQXR0cmlidXRlID0gQXR0cmlidXRlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbnN0cy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/consts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/middleware.js":
/*!**********************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/middleware.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _InngestOtelDiagLogger_logger;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.otelMiddleware = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst version_js_1 = __webpack_require__(/*! ../../../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst access_js_1 = __webpack_require__(/*! ./access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\nconst consts_js_1 = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/consts.js\");\nconst util_js_1 = __webpack_require__(/*! ./util.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/util.js\");\nconst debug = (0, debug_1.default)(`${consts_js_1.debugPrefix}:middleware`);\nclass InngestOtelDiagLogger {\n    constructor() {\n        _InngestOtelDiagLogger_logger.set(this, (0, debug_1.default)(`${consts_js_1.debugPrefix}:diag`));\n        this.debug = __classPrivateFieldGet(this, _InngestOtelDiagLogger_logger, \"f\");\n        this.error = __classPrivateFieldGet(this, _InngestOtelDiagLogger_logger, \"f\");\n        this.info = __classPrivateFieldGet(this, _InngestOtelDiagLogger_logger, \"f\");\n        this.verbose = __classPrivateFieldGet(this, _InngestOtelDiagLogger_logger, \"f\");\n        this.warn = __classPrivateFieldGet(this, _InngestOtelDiagLogger_logger, \"f\");\n    }\n}\n_InngestOtelDiagLogger_logger = new WeakMap();\n/**\n * Middleware the captures and exports spans relevant to Inngest runs using\n * OTel.\n *\n * This can be used to attach additional spans and data to the existing traces\n * in your Inngest dashboard (or Dev Server).\n */\nconst otelMiddleware = ({ behaviour = \"auto\", instrumentations, logLevel = api_1.DiagLogLevel.ERROR, } = {}) => {\n    debug(\"behaviour:\", behaviour);\n    let processor;\n    switch (behaviour) {\n        case \"auto\": {\n            const extended = (0, util_js_1.extendProvider)(behaviour);\n            if (extended.success) {\n                debug(\"extended existing provider\");\n                processor = extended.processor;\n                break;\n            }\n            const created = (0, util_js_1.createProvider)(behaviour, instrumentations);\n            if (created.success) {\n                debug(\"created new provider\");\n                processor = created.processor;\n                break;\n            }\n            console.warn(\"no provider found to extend and unable to create one\");\n            break;\n        }\n        case \"createProvider\": {\n            const created = (0, util_js_1.createProvider)(behaviour, instrumentations);\n            if (created.success) {\n                debug(\"created new provider\");\n                processor = created.processor;\n                break;\n            }\n            console.warn(\"unable to create provider, OTel middleware will not work\");\n            break;\n        }\n        case \"extendProvider\": {\n            const extended = (0, util_js_1.extendProvider)(behaviour);\n            if (extended.success) {\n                debug(\"extended existing provider\");\n                processor = extended.processor;\n                break;\n            }\n            console.warn('unable to extend provider, OTel middleware will not work. Either allow the middleware to create a provider by setting `behaviour: \"createProvider\"` or `behaviour: \"auto\"`, or make sure that the provider is created and imported before the middleware is used.');\n            break;\n        }\n        case \"off\": {\n            break;\n        }\n        default: {\n            // unknown\n            console.warn(`unknown behaviour ${JSON.stringify(behaviour)}, defaulting to \"off\"`);\n        }\n    }\n    return new InngestMiddleware_js_1.InngestMiddleware({\n        name: \"Inngest: OTel\",\n        init({ client }) {\n            // Set the logger for our otel processors and exporters.\n            // If this is called multiple times (for example by the user in some other\n            // custom code), then only the first call is set, so we don't have to\n            // worry about overwriting it here accidentally.\n            //\n            debug(\"set otel diagLogger:\", api_1.diag.setLogger(new InngestOtelDiagLogger(), logLevel));\n            if (processor) {\n                access_js_1.clientProcessorMap.set(client, processor);\n            }\n            return {\n                onFunctionRun() {\n                    return {\n                        transformInput() {\n                            return {\n                                ctx: {\n                                    /**\n                                     * A tracer that can be used to create spans within a step\n                                     * that will be displayed on the Inngest dashboard (or Dev\n                                     * Server).\n                                     *\n                                     * Note that creating spans outside of steps when the function\n                                     * contains `step.*()` calls is not currently supported.\n                                     */\n                                    tracer: api_1.trace.getTracer(\"inngest\", version_js_1.version),\n                                },\n                            };\n                        },\n                        async beforeResponse() {\n                            // Should this be awaited? And is it fine to flush after every\n                            // execution?\n                            await (processor === null || processor === void 0 ? void 0 : processor.forceFlush());\n                        },\n                    };\n                },\n            };\n        },\n    });\n};\nexports.otelMiddleware = otelMiddleware;\n//# sourceMappingURL=middleware.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL21pZGRsZXdhcmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0I7QUFDdEIsY0FBYyxtQkFBTyxDQUFDLHNGQUFvQjtBQUMxQyxnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQyxxQkFBcUIsbUJBQU8sQ0FBQyxvRUFBcUI7QUFDbEQsK0JBQStCLG1CQUFPLENBQUMsZ0dBQTRCO0FBQ25FLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLHFGQUFhO0FBQ3pDLGtCQUFrQixtQkFBTyxDQUFDLGlGQUFXO0FBQ3JDLHNDQUFzQyx3QkFBd0I7QUFDOUQ7QUFDQTtBQUNBLHdFQUF3RSx3QkFBd0I7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZFQUE2RSxJQUFJO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsMEJBQTBCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL21pZGRsZXdhcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfSW5uZ2VzdE90ZWxEaWFnTG9nZ2VyX2xvZ2dlcjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMub3RlbE1pZGRsZXdhcmUgPSB2b2lkIDA7XG5jb25zdCBhcGlfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9hcGlcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCB2ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vdmVyc2lvbi5qc1wiKTtcbmNvbnN0IElubmdlc3RNaWRkbGV3YXJlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vSW5uZ2VzdE1pZGRsZXdhcmUuanNcIik7XG5jb25zdCBhY2Nlc3NfanNfMSA9IHJlcXVpcmUoXCIuL2FjY2Vzcy5qc1wiKTtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4vY29uc3RzLmpzXCIpO1xuY29uc3QgdXRpbF9qc18xID0gcmVxdWlyZShcIi4vdXRpbC5qc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoYCR7Y29uc3RzX2pzXzEuZGVidWdQcmVmaXh9Om1pZGRsZXdhcmVgKTtcbmNsYXNzIElubmdlc3RPdGVsRGlhZ0xvZ2dlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIF9Jbm5nZXN0T3RlbERpYWdMb2dnZXJfbG9nZ2VyLnNldCh0aGlzLCAoMCwgZGVidWdfMS5kZWZhdWx0KShgJHtjb25zdHNfanNfMS5kZWJ1Z1ByZWZpeH06ZGlhZ2ApKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RPdGVsRGlhZ0xvZ2dlcl9sb2dnZXIsIFwiZlwiKTtcbiAgICAgICAgdGhpcy5lcnJvciA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RPdGVsRGlhZ0xvZ2dlcl9sb2dnZXIsIFwiZlwiKTtcbiAgICAgICAgdGhpcy5pbmZvID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdE90ZWxEaWFnTG9nZ2VyX2xvZ2dlciwgXCJmXCIpO1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0T3RlbERpYWdMb2dnZXJfbG9nZ2VyLCBcImZcIik7XG4gICAgICAgIHRoaXMud2FybiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RPdGVsRGlhZ0xvZ2dlcl9sb2dnZXIsIFwiZlwiKTtcbiAgICB9XG59XG5fSW5uZ2VzdE90ZWxEaWFnTG9nZ2VyX2xvZ2dlciA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIE1pZGRsZXdhcmUgdGhlIGNhcHR1cmVzIGFuZCBleHBvcnRzIHNwYW5zIHJlbGV2YW50IHRvIElubmdlc3QgcnVucyB1c2luZ1xuICogT1RlbC5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGF0dGFjaCBhZGRpdGlvbmFsIHNwYW5zIGFuZCBkYXRhIHRvIHRoZSBleGlzdGluZyB0cmFjZXNcbiAqIGluIHlvdXIgSW5uZ2VzdCBkYXNoYm9hcmQgKG9yIERldiBTZXJ2ZXIpLlxuICovXG5jb25zdCBvdGVsTWlkZGxld2FyZSA9ICh7IGJlaGF2aW91ciA9IFwiYXV0b1wiLCBpbnN0cnVtZW50YXRpb25zLCBsb2dMZXZlbCA9IGFwaV8xLkRpYWdMb2dMZXZlbC5FUlJPUiwgfSA9IHt9KSA9PiB7XG4gICAgZGVidWcoXCJiZWhhdmlvdXI6XCIsIGJlaGF2aW91cik7XG4gICAgbGV0IHByb2Nlc3NvcjtcbiAgICBzd2l0Y2ggKGJlaGF2aW91cikge1xuICAgICAgICBjYXNlIFwiYXV0b1wiOiB7XG4gICAgICAgICAgICBjb25zdCBleHRlbmRlZCA9ICgwLCB1dGlsX2pzXzEuZXh0ZW5kUHJvdmlkZXIpKGJlaGF2aW91cik7XG4gICAgICAgICAgICBpZiAoZXh0ZW5kZWQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZXh0ZW5kZWQgZXhpc3RpbmcgcHJvdmlkZXJcIik7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yID0gZXh0ZW5kZWQucHJvY2Vzc29yO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3JlYXRlZCA9ICgwLCB1dGlsX2pzXzEuY3JlYXRlUHJvdmlkZXIpKGJlaGF2aW91ciwgaW5zdHJ1bWVudGF0aW9ucyk7XG4gICAgICAgICAgICBpZiAoY3JlYXRlZC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjcmVhdGVkIG5ldyBwcm92aWRlclwiKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzb3IgPSBjcmVhdGVkLnByb2Nlc3NvcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIm5vIHByb3ZpZGVyIGZvdW5kIHRvIGV4dGVuZCBhbmQgdW5hYmxlIHRvIGNyZWF0ZSBvbmVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiY3JlYXRlUHJvdmlkZXJcIjoge1xuICAgICAgICAgICAgY29uc3QgY3JlYXRlZCA9ICgwLCB1dGlsX2pzXzEuY3JlYXRlUHJvdmlkZXIpKGJlaGF2aW91ciwgaW5zdHJ1bWVudGF0aW9ucyk7XG4gICAgICAgICAgICBpZiAoY3JlYXRlZC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjcmVhdGVkIG5ldyBwcm92aWRlclwiKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzb3IgPSBjcmVhdGVkLnByb2Nlc3NvcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcInVuYWJsZSB0byBjcmVhdGUgcHJvdmlkZXIsIE9UZWwgbWlkZGxld2FyZSB3aWxsIG5vdCB3b3JrXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImV4dGVuZFByb3ZpZGVyXCI6IHtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVuZGVkID0gKDAsIHV0aWxfanNfMS5leHRlbmRQcm92aWRlcikoYmVoYXZpb3VyKTtcbiAgICAgICAgICAgIGlmIChleHRlbmRlZC5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJleHRlbmRlZCBleGlzdGluZyBwcm92aWRlclwiKTtcbiAgICAgICAgICAgICAgICBwcm9jZXNzb3IgPSBleHRlbmRlZC5wcm9jZXNzb3I7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ3VuYWJsZSB0byBleHRlbmQgcHJvdmlkZXIsIE9UZWwgbWlkZGxld2FyZSB3aWxsIG5vdCB3b3JrLiBFaXRoZXIgYWxsb3cgdGhlIG1pZGRsZXdhcmUgdG8gY3JlYXRlIGEgcHJvdmlkZXIgYnkgc2V0dGluZyBgYmVoYXZpb3VyOiBcImNyZWF0ZVByb3ZpZGVyXCJgIG9yIGBiZWhhdmlvdXI6IFwiYXV0b1wiYCwgb3IgbWFrZSBzdXJlIHRoYXQgdGhlIHByb3ZpZGVyIGlzIGNyZWF0ZWQgYW5kIGltcG9ydGVkIGJlZm9yZSB0aGUgbWlkZGxld2FyZSBpcyB1c2VkLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm9mZlwiOiB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAvLyB1bmtub3duXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYHVua25vd24gYmVoYXZpb3VyICR7SlNPTi5zdHJpbmdpZnkoYmVoYXZpb3VyKX0sIGRlZmF1bHRpbmcgdG8gXCJvZmZcImApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5Jbm5nZXN0TWlkZGxld2FyZSh7XG4gICAgICAgIG5hbWU6IFwiSW5uZ2VzdDogT1RlbFwiLFxuICAgICAgICBpbml0KHsgY2xpZW50IH0pIHtcbiAgICAgICAgICAgIC8vIFNldCB0aGUgbG9nZ2VyIGZvciBvdXIgb3RlbCBwcm9jZXNzb3JzIGFuZCBleHBvcnRlcnMuXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyAoZm9yIGV4YW1wbGUgYnkgdGhlIHVzZXIgaW4gc29tZSBvdGhlclxuICAgICAgICAgICAgLy8gY3VzdG9tIGNvZGUpLCB0aGVuIG9ubHkgdGhlIGZpcnN0IGNhbGwgaXMgc2V0LCBzbyB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAgICAgICAvLyB3b3JyeSBhYm91dCBvdmVyd3JpdGluZyBpdCBoZXJlIGFjY2lkZW50YWxseS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBkZWJ1ZyhcInNldCBvdGVsIGRpYWdMb2dnZXI6XCIsIGFwaV8xLmRpYWcuc2V0TG9nZ2VyKG5ldyBJbm5nZXN0T3RlbERpYWdMb2dnZXIoKSwgbG9nTGV2ZWwpKTtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICBhY2Nlc3NfanNfMS5jbGllbnRQcm9jZXNzb3JNYXAuc2V0KGNsaWVudCwgcHJvY2Vzc29yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb25GdW5jdGlvblJ1bigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybUlucHV0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBBIHRyYWNlciB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSBzcGFucyB3aXRoaW4gYSBzdGVwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IHdpbGwgYmUgZGlzcGxheWVkIG9uIHRoZSBJbm5nZXN0IGRhc2hib2FyZCAob3IgRGV2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBTZXJ2ZXIpLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIE5vdGUgdGhhdCBjcmVhdGluZyBzcGFucyBvdXRzaWRlIG9mIHN0ZXBzIHdoZW4gdGhlIGZ1bmN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBjb250YWlucyBgc3RlcC4qKClgIGNhbGxzIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZXI6IGFwaV8xLnRyYWNlLmdldFRyYWNlcihcImlubmdlc3RcIiwgdmVyc2lvbl9qc18xLnZlcnNpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgYmVmb3JlUmVzcG9uc2UoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2hvdWxkIHRoaXMgYmUgYXdhaXRlZD8gQW5kIGlzIGl0IGZpbmUgdG8gZmx1c2ggYWZ0ZXIgZXZlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBleGVjdXRpb24/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgKHByb2Nlc3NvciA9PT0gbnVsbCB8fCBwcm9jZXNzb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByb2Nlc3Nvci5mb3JjZUZsdXNoKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn07XG5leHBvcnRzLm90ZWxNaWRkbGV3YXJlID0gb3RlbE1pZGRsZXdhcmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1taWRkbGV3YXJlLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/middleware.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/processor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/processor.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar _InngestSpanProcessor_batcher, _InngestSpanProcessor_spansToExport, _InngestSpanProcessor_traceParents, _InngestSpanProcessor_spanCleanup;\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PublicInngestSpanProcessor = exports.InngestSpanProcessor = void 0;\nconst exporter_trace_otlp_http_1 = __webpack_require__(/*! @opentelemetry/exporter-trace-otlp-http */ \"(rsc)/./node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/index.js\");\nconst resources_1 = __webpack_require__(/*! @opentelemetry/resources */ \"(rsc)/./node_modules/@opentelemetry/resources/build/esm/index.js\");\nconst sdk_trace_base_1 = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(rsc)/./node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\nconst debug_1 = __importDefault(__webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\"));\nconst consts_js_1 = __webpack_require__(/*! ../../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst devserver_js_1 = __webpack_require__(/*! ../../../helpers/devserver.js */ \"(rsc)/./node_modules/inngest/helpers/devserver.js\");\nconst env_js_1 = __webpack_require__(/*! ../../../helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\nconst als_js_1 = __webpack_require__(/*! ../als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst access_js_1 = __webpack_require__(/*! ./access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\nconst consts_js_2 = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/consts.js\");\nconst processorDebug = (0, debug_1.default)(`${consts_js_2.debugPrefix}:InngestSpanProcessor`);\n/**\n * A set of resource attributes that are used to identify the Inngest app and\n *  the function that is being executed. This is used to store the resource\n * attributes for the spans that are exported to the Inngest endpoint, and cache\n *  them for later use.\n */\nlet _resourceAttributes;\n/**\n * An OTel span processor that is used to export spans to the Inngest endpoint.\n * This is used to track spans that are created within an Inngest run and export\n * them to the Inngest endpoint for tracing.\n *\n * It's careful to only pick relevant spans to export and will not send any\n * irrelevant spans to the Inngest endpoint.\n *\n * THIS IS THE INTERNAL IMPLEMENTATION OF THE SPAN PROCESSOR AND SHOULD NOT BE\n * USED BY USERS DIRECTLY. USE THE {@link PublicInngestSpanProcessor} CLASS\n * INSTEAD.\n */\nclass InngestSpanProcessor {\n    /**\n     * An OTel span processor that is used to export spans to the Inngest endpoint.\n     * This is used to track spans that are created within an Inngest run and export\n     * them to the Inngest endpoint for tracing.\n     *\n     * It's careful to only pick relevant spans to export and will not send any\n     * irrelevant spans to the Inngest endpoint.\n     */\n    constructor(\n    /**\n     * The app that this span processor is associated with. This is used to\n     * determine the Inngest endpoint to export spans to.\n     *\n     * It is optional here as this is the private constructor and only used\n     * internally; we set `app` elsewhere as when we create the processor (as\n     * early as possible when the process starts) we don't necessarily have the\n     * app available yet.\n     *\n     * So, internally we can delay setting ths until later.\n     */\n    app) {\n        /**\n         * A `BatchSpanProcessor` that is used to export spans to the Inngest\n         * endpoint. This is created lazily to avoid creating it until the Inngest App\n         * has been initialized and has had a chance to receive environment variables,\n         * which may be from an incoming request.\n         */\n        _InngestSpanProcessor_batcher.set(this, void 0);\n        /**\n         * A set of spans used to track spans that we care about, so that we can\n         * export them to the OTel endpoint.\n         *\n         * If a span falls out of reference, it will be removed from this set as we'll\n         * never get a chance to export it or remove it anyway.\n         */\n        _InngestSpanProcessor_spansToExport.set(this, new WeakSet());\n        /**\n         * A map of span IDs to their parent state, which includes a block of\n         * information that can be used and pushed back to the Inngest endpoint to\n         * ingest spans.\n         */\n        _InngestSpanProcessor_traceParents.set(this, new Map());\n        /**\n         * A registry used to clean up items from the `traceParents` map when spans\n         * fall out of reference. This is used to avoid memory leaks in the case where\n         * a span is not exported, remains unended, and is left in memory before being\n         * GC'd.\n         */\n        _InngestSpanProcessor_spanCleanup.set(this, new FinalizationRegistry((spanId) => {\n            if (spanId) {\n                __classPrivateFieldGet(this, _InngestSpanProcessor_traceParents, \"f\").delete(spanId);\n            }\n        }));\n        if (app) {\n            access_js_1.clientProcessorMap.set(app, this);\n        }\n    }\n    /**\n     * In order to only capture a subset of spans, we need to declare the initial\n     * span that we care about and then export its children.\n     *\n     * Call this method (ideally just before execution starts) with that initial\n     * span to trigger capturing all following children as well as initialize the\n     * batcher.\n     */\n    declareStartingSpan({ span, runId, traceparent, tracestate, }) {\n        // Upsert the batcher ready for later. We do this here to bootstrap it with\n        // the correct async context as soon as we can. As this method is only\n        // called just before execution, we know we're all set up.\n        //\n        // Waiting to call this until we actually need the batcher would mean that\n        // we might not have the correct async context set up, as we'd likely be in\n        // some span lifecycle method that doesn't have the same chain of execution.\n        void this.ensureBatcherInitialized();\n        // If we don't have a traceparent, then we can't track this span. This is\n        // likely a span that we don't care about, so we can ignore it.\n        if (!traceparent) {\n            return processorDebug(\"no traceparent found for span\", span.spanContext().spanId, \"so skipping it\");\n        }\n        // We also attempt to use `tracestate`. The values we fetch from these\n        // should be optional, as it's likely the Executor won't need us to parrot\n        // them back in later versions.\n        let appId;\n        let functionId;\n        if (tracestate) {\n            try {\n                const entries = Object.fromEntries(tracestate.split(\",\").map((kv) => kv.split(\"=\")));\n                appId = entries[consts_js_2.TraceStateKey.AppId];\n                functionId = entries[consts_js_2.TraceStateKey.FunctionId];\n            }\n            catch (err) {\n                processorDebug(\"failed to parse tracestate\", tracestate, \"so skipping it;\", err);\n            }\n        }\n        // This is a span that we care about, so let's make sure it and its\n        // children are exported.\n        processorDebug.extend(\"declareStartingSpan\")(\"declaring:\", span.spanContext().spanId, \"for traceparent\", traceparent);\n        // Set a load of attributes on this span so that we can nicely identify\n        // runtime, paths, etc. Only this span will have these attributes.\n        span.setAttributes(InngestSpanProcessor.resourceAttributes.attributes);\n        this.trackSpan({\n            appId,\n            functionId,\n            runId,\n            traceparent,\n        }, span);\n    }\n    /**\n     * A getter for retrieving resource attributes for the current process. This\n     * is used to set the resource attributes for the spans that are exported to\n     * the Inngest endpoint, and cache them for later use.\n     */\n    static get resourceAttributes() {\n        if (!_resourceAttributes) {\n            _resourceAttributes = (0, resources_1.detectResourcesSync)({\n                detectors: [\n                    resources_1.osDetectorSync,\n                    resources_1.envDetectorSync,\n                    resources_1.hostDetectorSync,\n                    resources_1.processDetectorSync,\n                    resources_1.serviceInstanceIdDetectorSync,\n                ],\n            });\n        }\n        return _resourceAttributes;\n    }\n    /**\n     * The batcher is a singleton that is used to export spans to the OTel\n     * endpoint. It is created lazily to avoid creating it until the Inngest App\n     * has been initialized and has had a chance to receive environment variables,\n     * which may be from an incoming request.\n     *\n     * The batcher is only referenced once we've found a span we're interested in,\n     * so this should always have everything it needs on the app by then.\n     */\n    ensureBatcherInitialized() {\n        if (!__classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\")) {\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n            __classPrivateFieldSet(this, _InngestSpanProcessor_batcher, new Promise(async (resolve, reject) => {\n                var _a;\n                try {\n                    // We retrieve the app from the async context, so we must make sure\n                    // that this function is called from the correct chain.\n                    const store = await (0, als_js_1.getAsyncCtx)();\n                    if (!store) {\n                        throw new Error(\"No async context found; cannot create batcher to export traces\");\n                    }\n                    const app = store.app;\n                    // Fetch the URL for the Inngest endpoint using the app's config.\n                    let url;\n                    const path = \"/v1/traces/userland\";\n                    if (app.apiBaseUrl) {\n                        url = new URL(path, app.apiBaseUrl);\n                    }\n                    else {\n                        url = new URL(path, consts_js_1.defaultInngestApiBaseUrl);\n                        if (app[\"mode\"] && app[\"mode\"].isDev && app[\"mode\"].isInferred) {\n                            const devHost = (0, env_js_1.devServerHost)() || consts_js_1.defaultDevServerHost;\n                            const hasDevServer = await (0, devserver_js_1.devServerAvailable)(devHost, app[\"fetch\"]);\n                            if (hasDevServer) {\n                                url = new URL(path, devHost);\n                            }\n                        }\n                        else if ((_a = app[\"mode\"]) === null || _a === void 0 ? void 0 : _a.explicitDevUrl) {\n                            url = new URL(path, app[\"mode\"].explicitDevUrl.href);\n                        }\n                    }\n                    processorDebug(\"batcher lazily accessed; creating new batcher with URL\", url);\n                    const exporter = new exporter_trace_otlp_http_1.OTLPTraceExporter({\n                        url: url.href,\n                        headers: {\n                            Authorization: `Bearer ${app[\"inngestApi\"][\"signingKey\"]}`,\n                        },\n                    });\n                    resolve(new sdk_trace_base_1.BatchSpanProcessor(exporter));\n                }\n                catch (err) {\n                    reject(err);\n                }\n            }), \"f\");\n        }\n        return __classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\");\n    }\n    /**\n     * Mark a span as being tracked by this processor, meaning it will be exported\n     * to the Inggest endpoint when it ends.\n     */\n    trackSpan(parentState, span) {\n        const spanId = span.spanContext().spanId;\n        __classPrivateFieldGet(this, _InngestSpanProcessor_spanCleanup, \"f\").register(span, spanId, span);\n        __classPrivateFieldGet(this, _InngestSpanProcessor_spansToExport, \"f\").add(span);\n        __classPrivateFieldGet(this, _InngestSpanProcessor_traceParents, \"f\").set(spanId, parentState);\n        span.setAttribute(consts_js_2.Attribute.InngestTraceparent, parentState.traceparent);\n        span.setAttribute(consts_js_2.Attribute.InngestRunId, parentState.runId);\n        // Setting app ID is optional; it's likely in future versions of the\n        // Executor that we don't need to parrot this back.\n        if (parentState.appId) {\n            span.setAttribute(consts_js_2.Attribute.InngestAppId1, parentState.appId);\n            span.setAttribute(consts_js_2.Attribute.InngestAppId2, parentState.appId);\n        }\n        // Setting function ID is optional; it's likely in future versions of the\n        // Executor that we don't need to parrot this back.\n        if (parentState.functionId) {\n            span.setAttribute(consts_js_2.Attribute.InngestFunctionId, parentState.functionId);\n        }\n    }\n    /**\n     * Clean up any references to a span that has ended. This is used to avoid\n     * memory leaks in the case where a span is not exported, remains unended, and\n     * is left in memory before being GC'd.\n     */\n    cleanupSpan(span) {\n        const spanId = span.spanContext().spanId;\n        // This span is no longer in use, so we can remove it from the cleanup\n        // registry.\n        __classPrivateFieldGet(this, _InngestSpanProcessor_spanCleanup, \"f\").unregister(span);\n        __classPrivateFieldGet(this, _InngestSpanProcessor_spansToExport, \"f\").delete(span);\n        __classPrivateFieldGet(this, _InngestSpanProcessor_traceParents, \"f\").delete(spanId);\n    }\n    /**\n     * An implementation of the `onStart` method from the `SpanProcessor`\n     * interface. This is called when a span is started, and is used to track\n     * spans that are children of spans we care about.\n     */\n    onStart(span) {\n        const debug = processorDebug.extend(\"onStart\");\n        const spanId = span.spanContext().spanId;\n        //  It seems to work\n        const parentSpanId = span.parentSpanId;\n        // The root span isn't captured here, but we can capture children of it\n        // here.\n        if (!parentSpanId) {\n            // All spans that Inngest cares about will have a parent, so ignore this\n            debug(\"no parent span ID for\", spanId, \"so skipping it\");\n            return;\n        }\n        const parentState = __classPrivateFieldGet(this, _InngestSpanProcessor_traceParents, \"f\").get(parentSpanId);\n        if (parentState) {\n            // This span is a child of a span we care about, so add it to the list of\n            // tracked spans so that we also capture its children\n            debug(\"found traceparent\", parentState, \"in span ID\", parentSpanId, \"so adding\", spanId);\n            this.trackSpan(parentState, span);\n        }\n    }\n    /**\n     * An implementation of the `onEnd` method from the `SpanProcessor` interface.\n     * This is called when a span ends, and is used to export spans to the Inngest\n     * endpoint.\n     */\n    onEnd(span) {\n        const debug = processorDebug.extend(\"onEnd\");\n        const spanId = span.spanContext().spanId;\n        try {\n            if (__classPrivateFieldGet(this, _InngestSpanProcessor_spansToExport, \"f\").has(span)) {\n                if (!__classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\")) {\n                    return debug(\"batcher not initialized, so failed exporting span\", spanId);\n                }\n                debug(\"exporting span\", spanId);\n                return void __classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\").then((batcher) => batcher.onEnd(span));\n            }\n            debug(\"not exporting span\", spanId, \"as we don't care about it\");\n        }\n        finally {\n            this.cleanupSpan(span);\n        }\n    }\n    /**\n     * An implementation of the `forceFlush` method from the `SpanProcessor`\n     * interface. This is called to force the processor to flush any spans that\n     * are currently in the batcher. This is used to ensure that spans are\n     * exported to the Inngest endpoint before the process exits.\n     *\n     * Notably, we call this in the `beforeResponse` middleware hook to ensure\n     * that spans for a run as exported as soon as possible and before the\n     * serverless process is killed.\n     */\n    async forceFlush() {\n        var _a;\n        const flushDebug = processorDebug.extend(\"forceFlush\");\n        flushDebug(\"force flushing batcher\");\n        return (_a = __classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\")) === null || _a === void 0 ? void 0 : _a.then((batcher) => batcher.forceFlush()).catch((err) => {\n            flushDebug(\"error flushing batcher\", err, \"ignoring\");\n        });\n    }\n    async shutdown() {\n        var _a;\n        processorDebug.extend(\"shutdown\")(\"shutting down batcher\");\n        return (_a = __classPrivateFieldGet(this, _InngestSpanProcessor_batcher, \"f\")) === null || _a === void 0 ? void 0 : _a.then((batcher) => batcher.shutdown());\n    }\n}\nexports.InngestSpanProcessor = InngestSpanProcessor;\n_InngestSpanProcessor_batcher = new WeakMap(), _InngestSpanProcessor_spansToExport = new WeakMap(), _InngestSpanProcessor_traceParents = new WeakMap(), _InngestSpanProcessor_spanCleanup = new WeakMap();\n/**\n * An OTel span processor that is used to export spans to the Inngest endpoint.\n * This is used to track spans that are created within an Inngest run and export\n * them to the Inngest endpoint for tracing.\n *\n * It's careful to only pick relevant spans to export and will not send any\n * irrelevant spans to the Inngest endpoint.\n */\nclass PublicInngestSpanProcessor extends InngestSpanProcessor {\n    constructor(\n    /**\n     * The app that this span processor is associated with. This is used to\n     * determine the Inngest endpoint to export spans to.\n     */\n    app) {\n        super(app);\n    }\n}\nexports.PublicInngestSpanProcessor = PublicInngestSpanProcessor;\n//# sourceMappingURL=processor.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL3Byb2Nlc3Nvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGtDQUFrQyxHQUFHLDRCQUE0QjtBQUNqRSxtQ0FBbUMsbUJBQU8sQ0FBQyxnSUFBeUM7QUFDcEYsb0JBQW9CLG1CQUFPLENBQUMsa0dBQTBCO0FBQ3RELHlCQUF5QixtQkFBTyxDQUFDLDRHQUErQjtBQUNoRSxnQ0FBZ0MsbUJBQU8sQ0FBQyxzREFBTztBQUMvQyxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBNEI7QUFDeEQsdUJBQXVCLG1CQUFPLENBQUMsd0ZBQStCO0FBQzlELGlCQUFpQixtQkFBTyxDQUFDLDRFQUF5QjtBQUNsRCxpQkFBaUIsbUJBQU8sQ0FBQywyRUFBVztBQUNwQyxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBYTtBQUN6QyxvQkFBb0IsbUJBQU8sQ0FBQyxxRkFBYTtBQUN6QywrQ0FBK0Msd0JBQXdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGtDQUFrQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxnQ0FBZ0M7QUFDckYseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL3Byb2Nlc3Nvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbnZhciBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfYmF0Y2hlciwgX0lubmdlc3RTcGFuUHJvY2Vzc29yX3NwYW5zVG9FeHBvcnQsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl90cmFjZVBhcmVudHMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9zcGFuQ2xlYW51cDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHVibGljSW5uZ2VzdFNwYW5Qcm9jZXNzb3IgPSBleHBvcnRzLklubmdlc3RTcGFuUHJvY2Vzc29yID0gdm9pZCAwO1xuY29uc3QgZXhwb3J0ZXJfdHJhY2Vfb3RscF9odHRwXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvZXhwb3J0ZXItdHJhY2Utb3RscC1odHRwXCIpO1xuY29uc3QgcmVzb3VyY2VzXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvcmVzb3VyY2VzXCIpO1xuY29uc3Qgc2RrX3RyYWNlX2Jhc2VfMSA9IHJlcXVpcmUoXCJAb3BlbnRlbGVtZXRyeS9zZGstdHJhY2UtYmFzZVwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuY29uc3QgZGV2c2VydmVyX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vaGVscGVycy9kZXZzZXJ2ZXIuanNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9oZWxwZXJzL2Vudi5qc1wiKTtcbmNvbnN0IGFsc19qc18xID0gcmVxdWlyZShcIi4uL2Fscy5qc1wiKTtcbmNvbnN0IGFjY2Vzc19qc18xID0gcmVxdWlyZShcIi4vYWNjZXNzLmpzXCIpO1xuY29uc3QgY29uc3RzX2pzXzIgPSByZXF1aXJlKFwiLi9jb25zdHMuanNcIik7XG5jb25zdCBwcm9jZXNzb3JEZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke2NvbnN0c19qc18yLmRlYnVnUHJlZml4fTpJbm5nZXN0U3BhblByb2Nlc3NvcmApO1xuLyoqXG4gKiBBIHNldCBvZiByZXNvdXJjZSBhdHRyaWJ1dGVzIHRoYXQgYXJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIElubmdlc3QgYXBwIGFuZFxuICogIHRoZSBmdW5jdGlvbiB0aGF0IGlzIGJlaW5nIGV4ZWN1dGVkLiBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIHJlc291cmNlXG4gKiBhdHRyaWJ1dGVzIGZvciB0aGUgc3BhbnMgdGhhdCBhcmUgZXhwb3J0ZWQgdG8gdGhlIElubmdlc3QgZW5kcG9pbnQsIGFuZCBjYWNoZVxuICogIHRoZW0gZm9yIGxhdGVyIHVzZS5cbiAqL1xubGV0IF9yZXNvdXJjZUF0dHJpYnV0ZXM7XG4vKipcbiAqIEFuIE9UZWwgc3BhbiBwcm9jZXNzb3IgdGhhdCBpcyB1c2VkIHRvIGV4cG9ydCBzcGFucyB0byB0aGUgSW5uZ2VzdCBlbmRwb2ludC5cbiAqIFRoaXMgaXMgdXNlZCB0byB0cmFjayBzcGFucyB0aGF0IGFyZSBjcmVhdGVkIHdpdGhpbiBhbiBJbm5nZXN0IHJ1biBhbmQgZXhwb3J0XG4gKiB0aGVtIHRvIHRoZSBJbm5nZXN0IGVuZHBvaW50IGZvciB0cmFjaW5nLlxuICpcbiAqIEl0J3MgY2FyZWZ1bCB0byBvbmx5IHBpY2sgcmVsZXZhbnQgc3BhbnMgdG8gZXhwb3J0IGFuZCB3aWxsIG5vdCBzZW5kIGFueVxuICogaXJyZWxldmFudCBzcGFucyB0byB0aGUgSW5uZ2VzdCBlbmRwb2ludC5cbiAqXG4gKiBUSElTIElTIFRIRSBJTlRFUk5BTCBJTVBMRU1FTlRBVElPTiBPRiBUSEUgU1BBTiBQUk9DRVNTT1IgQU5EIFNIT1VMRCBOT1QgQkVcbiAqIFVTRUQgQlkgVVNFUlMgRElSRUNUTFkuIFVTRSBUSEUge0BsaW5rIFB1YmxpY0lubmdlc3RTcGFuUHJvY2Vzc29yfSBDTEFTU1xuICogSU5TVEVBRC5cbiAqL1xuY2xhc3MgSW5uZ2VzdFNwYW5Qcm9jZXNzb3Ige1xuICAgIC8qKlxuICAgICAqIEFuIE9UZWwgc3BhbiBwcm9jZXNzb3IgdGhhdCBpcyB1c2VkIHRvIGV4cG9ydCBzcGFucyB0byB0aGUgSW5uZ2VzdCBlbmRwb2ludC5cbiAgICAgKiBUaGlzIGlzIHVzZWQgdG8gdHJhY2sgc3BhbnMgdGhhdCBhcmUgY3JlYXRlZCB3aXRoaW4gYW4gSW5uZ2VzdCBydW4gYW5kIGV4cG9ydFxuICAgICAqIHRoZW0gdG8gdGhlIElubmdlc3QgZW5kcG9pbnQgZm9yIHRyYWNpbmcuXG4gICAgICpcbiAgICAgKiBJdCdzIGNhcmVmdWwgdG8gb25seSBwaWNrIHJlbGV2YW50IHNwYW5zIHRvIGV4cG9ydCBhbmQgd2lsbCBub3Qgc2VuZCBhbnlcbiAgICAgKiBpcnJlbGV2YW50IHNwYW5zIHRvIHRoZSBJbm5nZXN0IGVuZHBvaW50LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBhcHAgdGhhdCB0aGlzIHNwYW4gcHJvY2Vzc29yIGlzIGFzc29jaWF0ZWQgd2l0aC4gVGhpcyBpcyB1c2VkIHRvXG4gICAgICogZGV0ZXJtaW5lIHRoZSBJbm5nZXN0IGVuZHBvaW50IHRvIGV4cG9ydCBzcGFucyB0by5cbiAgICAgKlxuICAgICAqIEl0IGlzIG9wdGlvbmFsIGhlcmUgYXMgdGhpcyBpcyB0aGUgcHJpdmF0ZSBjb25zdHJ1Y3RvciBhbmQgb25seSB1c2VkXG4gICAgICogaW50ZXJuYWxseTsgd2Ugc2V0IGBhcHBgIGVsc2V3aGVyZSBhcyB3aGVuIHdlIGNyZWF0ZSB0aGUgcHJvY2Vzc29yIChhc1xuICAgICAqIGVhcmx5IGFzIHBvc3NpYmxlIHdoZW4gdGhlIHByb2Nlc3Mgc3RhcnRzKSB3ZSBkb24ndCBuZWNlc3NhcmlseSBoYXZlIHRoZVxuICAgICAqIGFwcCBhdmFpbGFibGUgeWV0LlxuICAgICAqXG4gICAgICogU28sIGludGVybmFsbHkgd2UgY2FuIGRlbGF5IHNldHRpbmcgdGhzIHVudGlsIGxhdGVyLlxuICAgICAqL1xuICAgIGFwcCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBgQmF0Y2hTcGFuUHJvY2Vzc29yYCB0aGF0IGlzIHVzZWQgdG8gZXhwb3J0IHNwYW5zIHRvIHRoZSBJbm5nZXN0XG4gICAgICAgICAqIGVuZHBvaW50LiBUaGlzIGlzIGNyZWF0ZWQgbGF6aWx5IHRvIGF2b2lkIGNyZWF0aW5nIGl0IHVudGlsIHRoZSBJbm5nZXN0IEFwcFxuICAgICAgICAgKiBoYXMgYmVlbiBpbml0aWFsaXplZCBhbmQgaGFzIGhhZCBhIGNoYW5jZSB0byByZWNlaXZlIGVudmlyb25tZW50IHZhcmlhYmxlcyxcbiAgICAgICAgICogd2hpY2ggbWF5IGJlIGZyb20gYW4gaW5jb21pbmcgcmVxdWVzdC5cbiAgICAgICAgICovXG4gICAgICAgIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9iYXRjaGVyLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBzZXQgb2Ygc3BhbnMgdXNlZCB0byB0cmFjayBzcGFucyB0aGF0IHdlIGNhcmUgYWJvdXQsIHNvIHRoYXQgd2UgY2FuXG4gICAgICAgICAqIGV4cG9ydCB0aGVtIHRvIHRoZSBPVGVsIGVuZHBvaW50LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBhIHNwYW4gZmFsbHMgb3V0IG9mIHJlZmVyZW5jZSwgaXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhpcyBzZXQgYXMgd2UnbGxcbiAgICAgICAgICogbmV2ZXIgZ2V0IGEgY2hhbmNlIHRvIGV4cG9ydCBpdCBvciByZW1vdmUgaXQgYW55d2F5LlxuICAgICAgICAgKi9cbiAgICAgICAgX0lubmdlc3RTcGFuUHJvY2Vzc29yX3NwYW5zVG9FeHBvcnQuc2V0KHRoaXMsIG5ldyBXZWFrU2V0KCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2Ygc3BhbiBJRHMgdG8gdGhlaXIgcGFyZW50IHN0YXRlLCB3aGljaCBpbmNsdWRlcyBhIGJsb2NrIG9mXG4gICAgICAgICAqIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIHVzZWQgYW5kIHB1c2hlZCBiYWNrIHRvIHRoZSBJbm5nZXN0IGVuZHBvaW50IHRvXG4gICAgICAgICAqIGluZ2VzdCBzcGFucy5cbiAgICAgICAgICovXG4gICAgICAgIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl90cmFjZVBhcmVudHMuc2V0KHRoaXMsIG5ldyBNYXAoKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZ2lzdHJ5IHVzZWQgdG8gY2xlYW4gdXAgaXRlbXMgZnJvbSB0aGUgYHRyYWNlUGFyZW50c2AgbWFwIHdoZW4gc3BhbnNcbiAgICAgICAgICogZmFsbCBvdXQgb2YgcmVmZXJlbmNlLiBUaGlzIGlzIHVzZWQgdG8gYXZvaWQgbWVtb3J5IGxlYWtzIGluIHRoZSBjYXNlIHdoZXJlXG4gICAgICAgICAqIGEgc3BhbiBpcyBub3QgZXhwb3J0ZWQsIHJlbWFpbnMgdW5lbmRlZCwgYW5kIGlzIGxlZnQgaW4gbWVtb3J5IGJlZm9yZSBiZWluZ1xuICAgICAgICAgKiBHQydkLlxuICAgICAgICAgKi9cbiAgICAgICAgX0lubmdlc3RTcGFuUHJvY2Vzc29yX3NwYW5DbGVhbnVwLnNldCh0aGlzLCBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKHNwYW5JZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNwYW5JZCkge1xuICAgICAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RTcGFuUHJvY2Vzc29yX3RyYWNlUGFyZW50cywgXCJmXCIpLmRlbGV0ZShzcGFuSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChhcHApIHtcbiAgICAgICAgICAgIGFjY2Vzc19qc18xLmNsaWVudFByb2Nlc3Nvck1hcC5zZXQoYXBwLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbiBvcmRlciB0byBvbmx5IGNhcHR1cmUgYSBzdWJzZXQgb2Ygc3BhbnMsIHdlIG5lZWQgdG8gZGVjbGFyZSB0aGUgaW5pdGlhbFxuICAgICAqIHNwYW4gdGhhdCB3ZSBjYXJlIGFib3V0IGFuZCB0aGVuIGV4cG9ydCBpdHMgY2hpbGRyZW4uXG4gICAgICpcbiAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIChpZGVhbGx5IGp1c3QgYmVmb3JlIGV4ZWN1dGlvbiBzdGFydHMpIHdpdGggdGhhdCBpbml0aWFsXG4gICAgICogc3BhbiB0byB0cmlnZ2VyIGNhcHR1cmluZyBhbGwgZm9sbG93aW5nIGNoaWxkcmVuIGFzIHdlbGwgYXMgaW5pdGlhbGl6ZSB0aGVcbiAgICAgKiBiYXRjaGVyLlxuICAgICAqL1xuICAgIGRlY2xhcmVTdGFydGluZ1NwYW4oeyBzcGFuLCBydW5JZCwgdHJhY2VwYXJlbnQsIHRyYWNlc3RhdGUsIH0pIHtcbiAgICAgICAgLy8gVXBzZXJ0IHRoZSBiYXRjaGVyIHJlYWR5IGZvciBsYXRlci4gV2UgZG8gdGhpcyBoZXJlIHRvIGJvb3RzdHJhcCBpdCB3aXRoXG4gICAgICAgIC8vIHRoZSBjb3JyZWN0IGFzeW5jIGNvbnRleHQgYXMgc29vbiBhcyB3ZSBjYW4uIEFzIHRoaXMgbWV0aG9kIGlzIG9ubHlcbiAgICAgICAgLy8gY2FsbGVkIGp1c3QgYmVmb3JlIGV4ZWN1dGlvbiwgd2Uga25vdyB3ZSdyZSBhbGwgc2V0IHVwLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXYWl0aW5nIHRvIGNhbGwgdGhpcyB1bnRpbCB3ZSBhY3R1YWxseSBuZWVkIHRoZSBiYXRjaGVyIHdvdWxkIG1lYW4gdGhhdFxuICAgICAgICAvLyB3ZSBtaWdodCBub3QgaGF2ZSB0aGUgY29ycmVjdCBhc3luYyBjb250ZXh0IHNldCB1cCwgYXMgd2UnZCBsaWtlbHkgYmUgaW5cbiAgICAgICAgLy8gc29tZSBzcGFuIGxpZmVjeWNsZSBtZXRob2QgdGhhdCBkb2Vzbid0IGhhdmUgdGhlIHNhbWUgY2hhaW4gb2YgZXhlY3V0aW9uLlxuICAgICAgICB2b2lkIHRoaXMuZW5zdXJlQmF0Y2hlckluaXRpYWxpemVkKCk7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSB0cmFjZXBhcmVudCwgdGhlbiB3ZSBjYW4ndCB0cmFjayB0aGlzIHNwYW4uIFRoaXMgaXNcbiAgICAgICAgLy8gbGlrZWx5IGEgc3BhbiB0aGF0IHdlIGRvbid0IGNhcmUgYWJvdXQsIHNvIHdlIGNhbiBpZ25vcmUgaXQuXG4gICAgICAgIGlmICghdHJhY2VwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9jZXNzb3JEZWJ1ZyhcIm5vIHRyYWNlcGFyZW50IGZvdW5kIGZvciBzcGFuXCIsIHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQsIFwic28gc2tpcHBpbmcgaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgYWxzbyBhdHRlbXB0IHRvIHVzZSBgdHJhY2VzdGF0ZWAuIFRoZSB2YWx1ZXMgd2UgZmV0Y2ggZnJvbSB0aGVzZVxuICAgICAgICAvLyBzaG91bGQgYmUgb3B0aW9uYWwsIGFzIGl0J3MgbGlrZWx5IHRoZSBFeGVjdXRvciB3b24ndCBuZWVkIHVzIHRvIHBhcnJvdFxuICAgICAgICAvLyB0aGVtIGJhY2sgaW4gbGF0ZXIgdmVyc2lvbnMuXG4gICAgICAgIGxldCBhcHBJZDtcbiAgICAgICAgbGV0IGZ1bmN0aW9uSWQ7XG4gICAgICAgIGlmICh0cmFjZXN0YXRlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZnJvbUVudHJpZXModHJhY2VzdGF0ZS5zcGxpdChcIixcIikubWFwKChrdikgPT4ga3Yuc3BsaXQoXCI9XCIpKSk7XG4gICAgICAgICAgICAgICAgYXBwSWQgPSBlbnRyaWVzW2NvbnN0c19qc18yLlRyYWNlU3RhdGVLZXkuQXBwSWRdO1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uSWQgPSBlbnRyaWVzW2NvbnN0c19qc18yLlRyYWNlU3RhdGVLZXkuRnVuY3Rpb25JZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc29yRGVidWcoXCJmYWlsZWQgdG8gcGFyc2UgdHJhY2VzdGF0ZVwiLCB0cmFjZXN0YXRlLCBcInNvIHNraXBwaW5nIGl0O1wiLCBlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGFuIHRoYXQgd2UgY2FyZSBhYm91dCwgc28gbGV0J3MgbWFrZSBzdXJlIGl0IGFuZCBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gYXJlIGV4cG9ydGVkLlxuICAgICAgICBwcm9jZXNzb3JEZWJ1Zy5leHRlbmQoXCJkZWNsYXJlU3RhcnRpbmdTcGFuXCIpKFwiZGVjbGFyaW5nOlwiLCBzcGFuLnNwYW5Db250ZXh0KCkuc3BhbklkLCBcImZvciB0cmFjZXBhcmVudFwiLCB0cmFjZXBhcmVudCk7XG4gICAgICAgIC8vIFNldCBhIGxvYWQgb2YgYXR0cmlidXRlcyBvbiB0aGlzIHNwYW4gc28gdGhhdCB3ZSBjYW4gbmljZWx5IGlkZW50aWZ5XG4gICAgICAgIC8vIHJ1bnRpbWUsIHBhdGhzLCBldGMuIE9ubHkgdGhpcyBzcGFuIHdpbGwgaGF2ZSB0aGVzZSBhdHRyaWJ1dGVzLlxuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoSW5uZ2VzdFNwYW5Qcm9jZXNzb3IucmVzb3VyY2VBdHRyaWJ1dGVzLmF0dHJpYnV0ZXMpO1xuICAgICAgICB0aGlzLnRyYWNrU3Bhbih7XG4gICAgICAgICAgICBhcHBJZCxcbiAgICAgICAgICAgIGZ1bmN0aW9uSWQsXG4gICAgICAgICAgICBydW5JZCxcbiAgICAgICAgICAgIHRyYWNlcGFyZW50LFxuICAgICAgICB9LCBzcGFuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBnZXR0ZXIgZm9yIHJldHJpZXZpbmcgcmVzb3VyY2UgYXR0cmlidXRlcyBmb3IgdGhlIGN1cnJlbnQgcHJvY2Vzcy4gVGhpc1xuICAgICAqIGlzIHVzZWQgdG8gc2V0IHRoZSByZXNvdXJjZSBhdHRyaWJ1dGVzIGZvciB0aGUgc3BhbnMgdGhhdCBhcmUgZXhwb3J0ZWQgdG9cbiAgICAgKiB0aGUgSW5uZ2VzdCBlbmRwb2ludCwgYW5kIGNhY2hlIHRoZW0gZm9yIGxhdGVyIHVzZS5cbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHJlc291cmNlQXR0cmlidXRlcygpIHtcbiAgICAgICAgaWYgKCFfcmVzb3VyY2VBdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBfcmVzb3VyY2VBdHRyaWJ1dGVzID0gKDAsIHJlc291cmNlc18xLmRldGVjdFJlc291cmNlc1N5bmMpKHtcbiAgICAgICAgICAgICAgICBkZXRlY3RvcnM6IFtcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzXzEub3NEZXRlY3RvclN5bmMsXG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlc18xLmVudkRldGVjdG9yU3luYyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzXzEuaG9zdERldGVjdG9yU3luYyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzXzEucHJvY2Vzc0RldGVjdG9yU3luYyxcbiAgICAgICAgICAgICAgICAgICAgcmVzb3VyY2VzXzEuc2VydmljZUluc3RhbmNlSWREZXRlY3RvclN5bmMsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfcmVzb3VyY2VBdHRyaWJ1dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYmF0Y2hlciBpcyBhIHNpbmdsZXRvbiB0aGF0IGlzIHVzZWQgdG8gZXhwb3J0IHNwYW5zIHRvIHRoZSBPVGVsXG4gICAgICogZW5kcG9pbnQuIEl0IGlzIGNyZWF0ZWQgbGF6aWx5IHRvIGF2b2lkIGNyZWF0aW5nIGl0IHVudGlsIHRoZSBJbm5nZXN0IEFwcFxuICAgICAqIGhhcyBiZWVuIGluaXRpYWxpemVkIGFuZCBoYXMgaGFkIGEgY2hhbmNlIHRvIHJlY2VpdmUgZW52aXJvbm1lbnQgdmFyaWFibGVzLFxuICAgICAqIHdoaWNoIG1heSBiZSBmcm9tIGFuIGluY29taW5nIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBUaGUgYmF0Y2hlciBpcyBvbmx5IHJlZmVyZW5jZWQgb25jZSB3ZSd2ZSBmb3VuZCBhIHNwYW4gd2UncmUgaW50ZXJlc3RlZCBpbixcbiAgICAgKiBzbyB0aGlzIHNob3VsZCBhbHdheXMgaGF2ZSBldmVyeXRoaW5nIGl0IG5lZWRzIG9uIHRoZSBhcHAgYnkgdGhlbi5cbiAgICAgKi9cbiAgICBlbnN1cmVCYXRjaGVySW5pdGlhbGl6ZWQoKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfYmF0Y2hlciwgXCJmXCIpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXMsIG5vLWFzeW5jLXByb21pc2UtZXhlY3V0b3JcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0lubmdlc3RTcGFuUHJvY2Vzc29yX2JhdGNoZXIsIG5ldyBQcm9taXNlKGFzeW5jIChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgcmV0cmlldmUgdGhlIGFwcCBmcm9tIHRoZSBhc3luYyBjb250ZXh0LCBzbyB3ZSBtdXN0IG1ha2Ugc3VyZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIGZyb20gdGhlIGNvcnJlY3QgY2hhaW4uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgKDAsIGFsc19qc18xLmdldEFzeW5jQ3R4KSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0b3JlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBhc3luYyBjb250ZXh0IGZvdW5kOyBjYW5ub3QgY3JlYXRlIGJhdGNoZXIgdG8gZXhwb3J0IHRyYWNlc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcHAgPSBzdG9yZS5hcHA7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIHRoZSBVUkwgZm9yIHRoZSBJbm5nZXN0IGVuZHBvaW50IHVzaW5nIHRoZSBhcHAncyBjb25maWcuXG4gICAgICAgICAgICAgICAgICAgIGxldCB1cmw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSBcIi92MS90cmFjZXMvdXNlcmxhbmRcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFwcC5hcGlCYXNlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBuZXcgVVJMKHBhdGgsIGFwcC5hcGlCYXNlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IG5ldyBVUkwocGF0aCwgY29uc3RzX2pzXzEuZGVmYXVsdElubmdlc3RBcGlCYXNlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcHBbXCJtb2RlXCJdICYmIGFwcFtcIm1vZGVcIl0uaXNEZXYgJiYgYXBwW1wibW9kZVwiXS5pc0luZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGV2SG9zdCA9ICgwLCBlbnZfanNfMS5kZXZTZXJ2ZXJIb3N0KSgpIHx8IGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc0RldlNlcnZlciA9IGF3YWl0ICgwLCBkZXZzZXJ2ZXJfanNfMS5kZXZTZXJ2ZXJBdmFpbGFibGUpKGRldkhvc3QsIGFwcFtcImZldGNoXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaGFzRGV2U2VydmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IG5ldyBVUkwocGF0aCwgZGV2SG9zdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoKF9hID0gYXBwW1wibW9kZVwiXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4cGxpY2l0RGV2VXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gbmV3IFVSTChwYXRoLCBhcHBbXCJtb2RlXCJdLmV4cGxpY2l0RGV2VXJsLmhyZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NvckRlYnVnKFwiYmF0Y2hlciBsYXppbHkgYWNjZXNzZWQ7IGNyZWF0aW5nIG5ldyBiYXRjaGVyIHdpdGggVVJMXCIsIHVybCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4cG9ydGVyID0gbmV3IGV4cG9ydGVyX3RyYWNlX290bHBfaHR0cF8xLk9UTFBUcmFjZUV4cG9ydGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLmhyZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2FwcFtcImlubmdlc3RBcGlcIl1bXCJzaWduaW5nS2V5XCJdfWAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgc2RrX3RyYWNlX2Jhc2VfMS5CYXRjaFNwYW5Qcm9jZXNzb3IoZXhwb3J0ZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9iYXRjaGVyLCBcImZcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgYSBzcGFuIGFzIGJlaW5nIHRyYWNrZWQgYnkgdGhpcyBwcm9jZXNzb3IsIG1lYW5pbmcgaXQgd2lsbCBiZSBleHBvcnRlZFxuICAgICAqIHRvIHRoZSBJbmdnZXN0IGVuZHBvaW50IHdoZW4gaXQgZW5kcy5cbiAgICAgKi9cbiAgICB0cmFja1NwYW4ocGFyZW50U3RhdGUsIHNwYW4pIHtcbiAgICAgICAgY29uc3Qgc3BhbklkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3Jfc3BhbkNsZWFudXAsIFwiZlwiKS5yZWdpc3RlcihzcGFuLCBzcGFuSWQsIHNwYW4pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9zcGFuc1RvRXhwb3J0LCBcImZcIikuYWRkKHNwYW4pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl90cmFjZVBhcmVudHMsIFwiZlwiKS5zZXQoc3BhbklkLCBwYXJlbnRTdGF0ZSk7XG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKGNvbnN0c19qc18yLkF0dHJpYnV0ZS5Jbm5nZXN0VHJhY2VwYXJlbnQsIHBhcmVudFN0YXRlLnRyYWNlcGFyZW50KTtcbiAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RzX2pzXzIuQXR0cmlidXRlLklubmdlc3RSdW5JZCwgcGFyZW50U3RhdGUucnVuSWQpO1xuICAgICAgICAvLyBTZXR0aW5nIGFwcCBJRCBpcyBvcHRpb25hbDsgaXQncyBsaWtlbHkgaW4gZnV0dXJlIHZlcnNpb25zIG9mIHRoZVxuICAgICAgICAvLyBFeGVjdXRvciB0aGF0IHdlIGRvbid0IG5lZWQgdG8gcGFycm90IHRoaXMgYmFjay5cbiAgICAgICAgaWYgKHBhcmVudFN0YXRlLmFwcElkKSB7XG4gICAgICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZShjb25zdHNfanNfMi5BdHRyaWJ1dGUuSW5uZ2VzdEFwcElkMSwgcGFyZW50U3RhdGUuYXBwSWQpO1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RzX2pzXzIuQXR0cmlidXRlLklubmdlc3RBcHBJZDIsIHBhcmVudFN0YXRlLmFwcElkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXR0aW5nIGZ1bmN0aW9uIElEIGlzIG9wdGlvbmFsOyBpdCdzIGxpa2VseSBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgdGhlXG4gICAgICAgIC8vIEV4ZWN1dG9yIHRoYXQgd2UgZG9uJ3QgbmVlZCB0byBwYXJyb3QgdGhpcyBiYWNrLlxuICAgICAgICBpZiAocGFyZW50U3RhdGUuZnVuY3Rpb25JZCkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGUoY29uc3RzX2pzXzIuQXR0cmlidXRlLklubmdlc3RGdW5jdGlvbklkLCBwYXJlbnRTdGF0ZS5mdW5jdGlvbklkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbiB1cCBhbnkgcmVmZXJlbmNlcyB0byBhIHNwYW4gdGhhdCBoYXMgZW5kZWQuIFRoaXMgaXMgdXNlZCB0byBhdm9pZFxuICAgICAqIG1lbW9yeSBsZWFrcyBpbiB0aGUgY2FzZSB3aGVyZSBhIHNwYW4gaXMgbm90IGV4cG9ydGVkLCByZW1haW5zIHVuZW5kZWQsIGFuZFxuICAgICAqIGlzIGxlZnQgaW4gbWVtb3J5IGJlZm9yZSBiZWluZyBHQydkLlxuICAgICAqL1xuICAgIGNsZWFudXBTcGFuKHNwYW4pIHtcbiAgICAgICAgY29uc3Qgc3BhbklkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgICAgICAgLy8gVGhpcyBzcGFuIGlzIG5vIGxvbmdlciBpbiB1c2UsIHNvIHdlIGNhbiByZW1vdmUgaXQgZnJvbSB0aGUgY2xlYW51cFxuICAgICAgICAvLyByZWdpc3RyeS5cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3Jfc3BhbkNsZWFudXAsIFwiZlwiKS51bnJlZ2lzdGVyKHNwYW4pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl9zcGFuc1RvRXhwb3J0LCBcImZcIikuZGVsZXRlKHNwYW4pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl90cmFjZVBhcmVudHMsIFwiZlwiKS5kZWxldGUoc3BhbklkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gaW1wbGVtZW50YXRpb24gb2YgdGhlIGBvblN0YXJ0YCBtZXRob2QgZnJvbSB0aGUgYFNwYW5Qcm9jZXNzb3JgXG4gICAgICogaW50ZXJmYWNlLiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgc3BhbiBpcyBzdGFydGVkLCBhbmQgaXMgdXNlZCB0byB0cmFja1xuICAgICAqIHNwYW5zIHRoYXQgYXJlIGNoaWxkcmVuIG9mIHNwYW5zIHdlIGNhcmUgYWJvdXQuXG4gICAgICovXG4gICAgb25TdGFydChzcGFuKSB7XG4gICAgICAgIGNvbnN0IGRlYnVnID0gcHJvY2Vzc29yRGVidWcuZXh0ZW5kKFwib25TdGFydFwiKTtcbiAgICAgICAgY29uc3Qgc3BhbklkID0gc3Bhbi5zcGFuQ29udGV4dCgpLnNwYW5JZDtcbiAgICAgICAgLy8g8J+kqyBJdCBzZWVtcyB0byB3b3JrXG4gICAgICAgIGNvbnN0IHBhcmVudFNwYW5JZCA9IHNwYW4ucGFyZW50U3BhbklkO1xuICAgICAgICAvLyBUaGUgcm9vdCBzcGFuIGlzbid0IGNhcHR1cmVkIGhlcmUsIGJ1dCB3ZSBjYW4gY2FwdHVyZSBjaGlsZHJlbiBvZiBpdFxuICAgICAgICAvLyBoZXJlLlxuICAgICAgICBpZiAoIXBhcmVudFNwYW5JZCkge1xuICAgICAgICAgICAgLy8gQWxsIHNwYW5zIHRoYXQgSW5uZ2VzdCBjYXJlcyBhYm91dCB3aWxsIGhhdmUgYSBwYXJlbnQsIHNvIGlnbm9yZSB0aGlzXG4gICAgICAgICAgICBkZWJ1ZyhcIm5vIHBhcmVudCBzcGFuIElEIGZvclwiLCBzcGFuSWQsIFwic28gc2tpcHBpbmcgaXRcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50U3RhdGUgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl90cmFjZVBhcmVudHMsIFwiZlwiKS5nZXQocGFyZW50U3BhbklkKTtcbiAgICAgICAgaWYgKHBhcmVudFN0YXRlKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHNwYW4gaXMgYSBjaGlsZCBvZiBhIHNwYW4gd2UgY2FyZSBhYm91dCwgc28gYWRkIGl0IHRvIHRoZSBsaXN0IG9mXG4gICAgICAgICAgICAvLyB0cmFja2VkIHNwYW5zIHNvIHRoYXQgd2UgYWxzbyBjYXB0dXJlIGl0cyBjaGlsZHJlblxuICAgICAgICAgICAgZGVidWcoXCJmb3VuZCB0cmFjZXBhcmVudFwiLCBwYXJlbnRTdGF0ZSwgXCJpbiBzcGFuIElEXCIsIHBhcmVudFNwYW5JZCwgXCJzbyBhZGRpbmdcIiwgc3BhbklkKTtcbiAgICAgICAgICAgIHRoaXMudHJhY2tTcGFuKHBhcmVudFN0YXRlLCBzcGFuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYG9uRW5kYCBtZXRob2QgZnJvbSB0aGUgYFNwYW5Qcm9jZXNzb3JgIGludGVyZmFjZS5cbiAgICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIGEgc3BhbiBlbmRzLCBhbmQgaXMgdXNlZCB0byBleHBvcnQgc3BhbnMgdG8gdGhlIElubmdlc3RcbiAgICAgKiBlbmRwb2ludC5cbiAgICAgKi9cbiAgICBvbkVuZChzcGFuKSB7XG4gICAgICAgIGNvbnN0IGRlYnVnID0gcHJvY2Vzc29yRGVidWcuZXh0ZW5kKFwib25FbmRcIik7XG4gICAgICAgIGNvbnN0IHNwYW5JZCA9IHNwYW4uc3BhbkNvbnRleHQoKS5zcGFuSWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3Jfc3BhbnNUb0V4cG9ydCwgXCJmXCIpLmhhcyhzcGFuKSkge1xuICAgICAgICAgICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3JfYmF0Y2hlciwgXCJmXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWJ1ZyhcImJhdGNoZXIgbm90IGluaXRpYWxpemVkLCBzbyBmYWlsZWQgZXhwb3J0aW5nIHNwYW5cIiwgc3BhbklkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoXCJleHBvcnRpbmcgc3BhblwiLCBzcGFuSWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RTcGFuUHJvY2Vzc29yX2JhdGNoZXIsIFwiZlwiKS50aGVuKChiYXRjaGVyKSA9PiBiYXRjaGVyLm9uRW5kKHNwYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnKFwibm90IGV4cG9ydGluZyBzcGFuXCIsIHNwYW5JZCwgXCJhcyB3ZSBkb24ndCBjYXJlIGFib3V0IGl0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5jbGVhbnVwU3BhbihzcGFuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYGZvcmNlRmx1c2hgIG1ldGhvZCBmcm9tIHRoZSBgU3BhblByb2Nlc3NvcmBcbiAgICAgKiBpbnRlcmZhY2UuIFRoaXMgaXMgY2FsbGVkIHRvIGZvcmNlIHRoZSBwcm9jZXNzb3IgdG8gZmx1c2ggYW55IHNwYW5zIHRoYXRcbiAgICAgKiBhcmUgY3VycmVudGx5IGluIHRoZSBiYXRjaGVyLiBUaGlzIGlzIHVzZWQgdG8gZW5zdXJlIHRoYXQgc3BhbnMgYXJlXG4gICAgICogZXhwb3J0ZWQgdG8gdGhlIElubmdlc3QgZW5kcG9pbnQgYmVmb3JlIHRoZSBwcm9jZXNzIGV4aXRzLlxuICAgICAqXG4gICAgICogTm90YWJseSwgd2UgY2FsbCB0aGlzIGluIHRoZSBgYmVmb3JlUmVzcG9uc2VgIG1pZGRsZXdhcmUgaG9vayB0byBlbnN1cmVcbiAgICAgKiB0aGF0IHNwYW5zIGZvciBhIHJ1biBhcyBleHBvcnRlZCBhcyBzb29uIGFzIHBvc3NpYmxlIGFuZCBiZWZvcmUgdGhlXG4gICAgICogc2VydmVybGVzcyBwcm9jZXNzIGlzIGtpbGxlZC5cbiAgICAgKi9cbiAgICBhc3luYyBmb3JjZUZsdXNoKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGZsdXNoRGVidWcgPSBwcm9jZXNzb3JEZWJ1Zy5leHRlbmQoXCJmb3JjZUZsdXNoXCIpO1xuICAgICAgICBmbHVzaERlYnVnKFwiZm9yY2UgZmx1c2hpbmcgYmF0Y2hlclwiKTtcbiAgICAgICAgcmV0dXJuIChfYSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RTcGFuUHJvY2Vzc29yX2JhdGNoZXIsIFwiZlwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRoZW4oKGJhdGNoZXIpID0+IGJhdGNoZXIuZm9yY2VGbHVzaCgpKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBmbHVzaERlYnVnKFwiZXJyb3IgZmx1c2hpbmcgYmF0Y2hlclwiLCBlcnIsIFwiaWdub3JpbmdcIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBzaHV0ZG93bigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBwcm9jZXNzb3JEZWJ1Zy5leHRlbmQoXCJzaHV0ZG93blwiKShcInNodXR0aW5nIGRvd24gYmF0Y2hlclwiKTtcbiAgICAgICAgcmV0dXJuIChfYSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmdlc3RTcGFuUHJvY2Vzc29yX2JhdGNoZXIsIFwiZlwiKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRoZW4oKGJhdGNoZXIpID0+IGJhdGNoZXIuc2h1dGRvd24oKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Jbm5nZXN0U3BhblByb2Nlc3NvciA9IElubmdlc3RTcGFuUHJvY2Vzc29yO1xuX0lubmdlc3RTcGFuUHJvY2Vzc29yX2JhdGNoZXIgPSBuZXcgV2Vha01hcCgpLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3Jfc3BhbnNUb0V4cG9ydCA9IG5ldyBXZWFrTWFwKCksIF9Jbm5nZXN0U3BhblByb2Nlc3Nvcl90cmFjZVBhcmVudHMgPSBuZXcgV2Vha01hcCgpLCBfSW5uZ2VzdFNwYW5Qcm9jZXNzb3Jfc3BhbkNsZWFudXAgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBBbiBPVGVsIHNwYW4gcHJvY2Vzc29yIHRoYXQgaXMgdXNlZCB0byBleHBvcnQgc3BhbnMgdG8gdGhlIElubmdlc3QgZW5kcG9pbnQuXG4gKiBUaGlzIGlzIHVzZWQgdG8gdHJhY2sgc3BhbnMgdGhhdCBhcmUgY3JlYXRlZCB3aXRoaW4gYW4gSW5uZ2VzdCBydW4gYW5kIGV4cG9ydFxuICogdGhlbSB0byB0aGUgSW5uZ2VzdCBlbmRwb2ludCBmb3IgdHJhY2luZy5cbiAqXG4gKiBJdCdzIGNhcmVmdWwgdG8gb25seSBwaWNrIHJlbGV2YW50IHNwYW5zIHRvIGV4cG9ydCBhbmQgd2lsbCBub3Qgc2VuZCBhbnlcbiAqIGlycmVsZXZhbnQgc3BhbnMgdG8gdGhlIElubmdlc3QgZW5kcG9pbnQuXG4gKi9cbmNsYXNzIFB1YmxpY0lubmdlc3RTcGFuUHJvY2Vzc29yIGV4dGVuZHMgSW5uZ2VzdFNwYW5Qcm9jZXNzb3Ige1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgICAqIFRoZSBhcHAgdGhhdCB0aGlzIHNwYW4gcHJvY2Vzc29yIGlzIGFzc29jaWF0ZWQgd2l0aC4gVGhpcyBpcyB1c2VkIHRvXG4gICAgICogZGV0ZXJtaW5lIHRoZSBJbm5nZXN0IGVuZHBvaW50IHRvIGV4cG9ydCBzcGFucyB0by5cbiAgICAgKi9cbiAgICBhcHApIHtcbiAgICAgICAgc3VwZXIoYXBwKTtcbiAgICB9XG59XG5leHBvcnRzLlB1YmxpY0lubmdlc3RTcGFuUHJvY2Vzc29yID0gUHVibGljSW5uZ2VzdFNwYW5Qcm9jZXNzb3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcm9jZXNzb3IuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/processor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/otel/util.js":
/*!****************************************************************!*\
  !*** ./node_modules/inngest/components/execution/otel/util.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.extendProvider = exports.createProvider = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nconst auto_instrumentations_node_1 = __webpack_require__(/*! @opentelemetry/auto-instrumentations-node */ \"(rsc)/./node_modules/@opentelemetry/auto-instrumentations-node/build/src/index.js\");\nconst context_async_hooks_1 = __webpack_require__(/*! @opentelemetry/context-async-hooks */ \"(rsc)/./node_modules/@opentelemetry/context-async-hooks/build/src/index.js\");\nconst instrumentation_1 = __webpack_require__(/*! @opentelemetry/instrumentation */ \"(rsc)/./node_modules/@opentelemetry/instrumentation/build/esm/index.js\");\nconst sdk_trace_base_1 = __webpack_require__(/*! @opentelemetry/sdk-trace-base */ \"(rsc)/./node_modules/@opentelemetry/sdk-trace-base/build/esm/index.js\");\nconst processor_js_1 = __webpack_require__(/*! ./processor.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/processor.js\");\nconst createProvider = (behaviour, instrumentations = []) => {\n    // TODO Check if there's an existing provider\n    const processor = new processor_js_1.InngestSpanProcessor();\n    const p = new sdk_trace_base_1.BasicTracerProvider({\n        spanProcessors: [processor],\n    });\n    const instrList = [\n        ...instrumentations,\n        ...(0, auto_instrumentations_node_1.getNodeAutoInstrumentations)(),\n    ];\n    (0, instrumentation_1.registerInstrumentations)({\n        instrumentations: instrList,\n    });\n    p.register({\n        contextManager: new context_async_hooks_1.AsyncHooksContextManager().enable(),\n    });\n    return { success: true, processor };\n};\nexports.createProvider = createProvider;\n/**\n * Attempts to extend the existing OTel provider with our processor. Returns true\n * if the provider was extended, false if it was not.\n */\nconst extendProvider = (behaviour) => {\n    // Attempt to add our processor and export to the existing provider\n    const existingProvider = api_1.trace.getTracerProvider();\n    if (!existingProvider) {\n        if (behaviour !== \"auto\") {\n            console.warn('No existing OTel provider found and behaviour is \"extendProvider\". Inngest\\'s OTel middleware will not work. Either allow the middleware to create a provider by setting `behaviour: \"createProvider\"` or `behaviour: \"auto\"`, or make sure that the provider is created and imported before the middleware is used.');\n        }\n        return { success: false };\n    }\n    if (!(\"addSpanProcessor\" in existingProvider) ||\n        typeof existingProvider.addSpanProcessor !== \"function\") {\n        // TODO Could we also add a function the user can provide that takes the\n        // processor and adds it? That way they could support many different\n        // providers.\n        if (behaviour !== \"auto\") {\n            console.warn(\"Existing OTel provider is not a BasicTracerProvider. Inngest's OTel middleware will not work, as it can only extend an existing processor if it's a BasicTracerProvider.\");\n        }\n        return { success: false };\n    }\n    const processor = new processor_js_1.InngestSpanProcessor();\n    existingProvider.addSpanProcessor(processor);\n    return { success: true, processor };\n};\nexports.extendProvider = extendProvider;\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLEdBQUcsc0JBQXNCO0FBQy9DLGNBQWMsbUJBQU8sQ0FBQyxzRkFBb0I7QUFDMUMscUNBQXFDLG1CQUFPLENBQUMsb0lBQTJDO0FBQ3hGLDhCQUE4QixtQkFBTyxDQUFDLHNIQUFvQztBQUMxRSwwQkFBMEIsbUJBQU8sQ0FBQyw4R0FBZ0M7QUFDbEUseUJBQXlCLG1CQUFPLENBQUMsNEdBQStCO0FBQ2hFLHVCQUF1QixtQkFBTyxDQUFDLDJGQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQkFBc0I7QUFDdEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuZFByb3ZpZGVyID0gZXhwb3J0cy5jcmVhdGVQcm92aWRlciA9IHZvaWQgMDtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IGF1dG9faW5zdHJ1bWVudGF0aW9uc19ub2RlXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXV0by1pbnN0cnVtZW50YXRpb25zLW5vZGVcIik7XG5jb25zdCBjb250ZXh0X2FzeW5jX2hvb2tzXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvY29udGV4dC1hc3luYy1ob29rc1wiKTtcbmNvbnN0IGluc3RydW1lbnRhdGlvbl8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2luc3RydW1lbnRhdGlvblwiKTtcbmNvbnN0IHNka190cmFjZV9iYXNlXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvc2RrLXRyYWNlLWJhc2VcIik7XG5jb25zdCBwcm9jZXNzb3JfanNfMSA9IHJlcXVpcmUoXCIuL3Byb2Nlc3Nvci5qc1wiKTtcbmNvbnN0IGNyZWF0ZVByb3ZpZGVyID0gKGJlaGF2aW91ciwgaW5zdHJ1bWVudGF0aW9ucyA9IFtdKSA9PiB7XG4gICAgLy8gVE9ETyBDaGVjayBpZiB0aGVyZSdzIGFuIGV4aXN0aW5nIHByb3ZpZGVyXG4gICAgY29uc3QgcHJvY2Vzc29yID0gbmV3IHByb2Nlc3Nvcl9qc18xLklubmdlc3RTcGFuUHJvY2Vzc29yKCk7XG4gICAgY29uc3QgcCA9IG5ldyBzZGtfdHJhY2VfYmFzZV8xLkJhc2ljVHJhY2VyUHJvdmlkZXIoe1xuICAgICAgICBzcGFuUHJvY2Vzc29yczogW3Byb2Nlc3Nvcl0sXG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJMaXN0ID0gW1xuICAgICAgICAuLi5pbnN0cnVtZW50YXRpb25zLFxuICAgICAgICAuLi4oMCwgYXV0b19pbnN0cnVtZW50YXRpb25zX25vZGVfMS5nZXROb2RlQXV0b0luc3RydW1lbnRhdGlvbnMpKCksXG4gICAgXTtcbiAgICAoMCwgaW5zdHJ1bWVudGF0aW9uXzEucmVnaXN0ZXJJbnN0cnVtZW50YXRpb25zKSh7XG4gICAgICAgIGluc3RydW1lbnRhdGlvbnM6IGluc3RyTGlzdCxcbiAgICB9KTtcbiAgICBwLnJlZ2lzdGVyKHtcbiAgICAgICAgY29udGV4dE1hbmFnZXI6IG5ldyBjb250ZXh0X2FzeW5jX2hvb2tzXzEuQXN5bmNIb29rc0NvbnRleHRNYW5hZ2VyKCkuZW5hYmxlKCksXG4gICAgfSk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgcHJvY2Vzc29yIH07XG59O1xuZXhwb3J0cy5jcmVhdGVQcm92aWRlciA9IGNyZWF0ZVByb3ZpZGVyO1xuLyoqXG4gKiBBdHRlbXB0cyB0byBleHRlbmQgdGhlIGV4aXN0aW5nIE9UZWwgcHJvdmlkZXIgd2l0aCBvdXIgcHJvY2Vzc29yLiBSZXR1cm5zIHRydWVcbiAqIGlmIHRoZSBwcm92aWRlciB3YXMgZXh0ZW5kZWQsIGZhbHNlIGlmIGl0IHdhcyBub3QuXG4gKi9cbmNvbnN0IGV4dGVuZFByb3ZpZGVyID0gKGJlaGF2aW91cikgPT4ge1xuICAgIC8vIEF0dGVtcHQgdG8gYWRkIG91ciBwcm9jZXNzb3IgYW5kIGV4cG9ydCB0byB0aGUgZXhpc3RpbmcgcHJvdmlkZXJcbiAgICBjb25zdCBleGlzdGluZ1Byb3ZpZGVyID0gYXBpXzEudHJhY2UuZ2V0VHJhY2VyUHJvdmlkZXIoKTtcbiAgICBpZiAoIWV4aXN0aW5nUHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKGJlaGF2aW91ciAhPT0gXCJhdXRvXCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTm8gZXhpc3RpbmcgT1RlbCBwcm92aWRlciBmb3VuZCBhbmQgYmVoYXZpb3VyIGlzIFwiZXh0ZW5kUHJvdmlkZXJcIi4gSW5uZ2VzdFxcJ3MgT1RlbCBtaWRkbGV3YXJlIHdpbGwgbm90IHdvcmsuIEVpdGhlciBhbGxvdyB0aGUgbWlkZGxld2FyZSB0byBjcmVhdGUgYSBwcm92aWRlciBieSBzZXR0aW5nIGBiZWhhdmlvdXI6IFwiY3JlYXRlUHJvdmlkZXJcImAgb3IgYGJlaGF2aW91cjogXCJhdXRvXCJgLCBvciBtYWtlIHN1cmUgdGhhdCB0aGUgcHJvdmlkZXIgaXMgY3JlYXRlZCBhbmQgaW1wb3J0ZWQgYmVmb3JlIHRoZSBtaWRkbGV3YXJlIGlzIHVzZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICB9XG4gICAgaWYgKCEoXCJhZGRTcGFuUHJvY2Vzc29yXCIgaW4gZXhpc3RpbmdQcm92aWRlcikgfHxcbiAgICAgICAgdHlwZW9mIGV4aXN0aW5nUHJvdmlkZXIuYWRkU3BhblByb2Nlc3NvciAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIFRPRE8gQ291bGQgd2UgYWxzbyBhZGQgYSBmdW5jdGlvbiB0aGUgdXNlciBjYW4gcHJvdmlkZSB0aGF0IHRha2VzIHRoZVxuICAgICAgICAvLyBwcm9jZXNzb3IgYW5kIGFkZHMgaXQ/IFRoYXQgd2F5IHRoZXkgY291bGQgc3VwcG9ydCBtYW55IGRpZmZlcmVudFxuICAgICAgICAvLyBwcm92aWRlcnMuXG4gICAgICAgIGlmIChiZWhhdmlvdXIgIT09IFwiYXV0b1wiKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJFeGlzdGluZyBPVGVsIHByb3ZpZGVyIGlzIG5vdCBhIEJhc2ljVHJhY2VyUHJvdmlkZXIuIElubmdlc3QncyBPVGVsIG1pZGRsZXdhcmUgd2lsbCBub3Qgd29yaywgYXMgaXQgY2FuIG9ubHkgZXh0ZW5kIGFuIGV4aXN0aW5nIHByb2Nlc3NvciBpZiBpdCdzIGEgQmFzaWNUcmFjZXJQcm92aWRlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UgfTtcbiAgICB9XG4gICAgY29uc3QgcHJvY2Vzc29yID0gbmV3IHByb2Nlc3Nvcl9qc18xLklubmdlc3RTcGFuUHJvY2Vzc29yKCk7XG4gICAgZXhpc3RpbmdQcm92aWRlci5hZGRTcGFuUHJvY2Vzc29yKHByb2Nlc3Nvcik7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgcHJvY2Vzc29yIH07XG59O1xuZXhwb3J0cy5leHRlbmRQcm92aWRlciA9IGV4dGVuZFByb3ZpZGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/otel/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v0.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v0.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._internals = exports.V0InngestExecution = exports.createV0InngestExecution = void 0;\nconst canonicalize_1 = __importDefault(__webpack_require__(/*! canonicalize */ \"(rsc)/./node_modules/canonicalize/lib/canonicalize.js\"));\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst errors_js_1 = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst promises_js_1 = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst types_js_1 = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst RetryAfterError_js_1 = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst createV0InngestExecution = (options) => {\n    return new V0InngestExecution(options);\n};\nexports.createV0InngestExecution = createV0InngestExecution;\nclass V0InngestExecution extends InngestExecution_js_1.InngestExecution {\n    constructor(options) {\n        super(options);\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n    }\n    start() {\n        var _a;\n        this.debug(\"starting V0 execution\");\n        return ((_a = this.execution) !== null && _a !== void 0 ? _a : (this.execution = this._start().then((result) => {\n            this.debug(\"result:\", result);\n            return result;\n        })));\n    }\n    async _start() {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n        this.state.hooks = await this.initializeMiddleware();\n        try {\n            await this.transformInput();\n            await ((_b = (_a = this.state.hooks).beforeMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            if (this.state.opStack.length === 0 && !this.options.requestedRunStep) {\n                await ((_d = (_c = this.state.hooks).afterMemoization) === null || _d === void 0 ? void 0 : _d.call(_c));\n                await ((_f = (_e = this.state.hooks).beforeExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n            }\n            const userFnPromise = (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg));\n            let pos = -1;\n            do {\n                if (pos >= 0) {\n                    if (!this.options.requestedRunStep &&\n                        pos === this.state.opStack.length - 1) {\n                        await ((_h = (_g = this.state.hooks).afterMemoization) === null || _h === void 0 ? void 0 : _h.call(_g));\n                        await ((_k = (_j = this.state.hooks).beforeExecution) === null || _k === void 0 ? void 0 : _k.call(_j));\n                    }\n                    this.state.tickOps = {};\n                    const incomingOp = this.state.opStack[pos];\n                    this.state.currentOp = this.state.allFoundOps[incomingOp.id];\n                    if (!this.state.currentOp) {\n                        /**\n                         * We're trying to resume the function, but we can't find where to go.\n                         *\n                         * This means that either the function has changed or there are async\n                         * actions in-between steps that we haven't noticed in previous\n                         * executions.\n                         *\n                         * Whichever the case, this is bad and we can't continue in this\n                         * undefined state.\n                         */\n                        throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.prettyError)({\n                            whatHappened: \" Your function was stopped from running\",\n                            why: \"We couldn't resume your function's state because it may have changed since the run started or there are async actions in-between steps that we haven't noticed in previous executions.\",\n                            consequences: \"Continuing to run the function may result in unexpected behaviour, so we've stopped your function to ensure nothing unexpected happened!\",\n                            toFixNow: \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n                            otherwise: \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n                            stack: true,\n                            code: errors_js_1.ErrCode.NON_DETERMINISTIC_FUNCTION,\n                        }));\n                    }\n                    this.state.currentOp.fulfilled = true;\n                    if (typeof incomingOp.data !== \"undefined\") {\n                        this.state.currentOp.resolve(incomingOp.data);\n                    }\n                    else {\n                        this.state.currentOp.reject(incomingOp.error);\n                    }\n                }\n                await (0, promises_js_1.resolveAfterPending)();\n                this.state.reset();\n                pos++;\n            } while (pos < this.state.opStack.length);\n            await ((_m = (_l = this.state.hooks).afterMemoization) === null || _m === void 0 ? void 0 : _m.call(_l));\n            const discoveredOps = Object.values(this.state.tickOps).map(tickOpToOutgoing);\n            const runStep = this.options.requestedRunStep ||\n                this.getEarlyExecRunStep(discoveredOps);\n            if (runStep) {\n                const userFnOp = this.state.allFoundOps[runStep];\n                const stepToRun = userFnOp === null || userFnOp === void 0 ? void 0 : userFnOp.fn;\n                if (!stepToRun) {\n                    throw new Error(`Bad stack; executor requesting to run unknown step \"${runStep}\"`);\n                }\n                const outgoingUserFnOp = Object.assign(Object.assign({}, tickOpToOutgoing(userFnOp)), { op: types_js_1.StepOpCode.Step });\n                await ((_p = (_o = this.state.hooks).beforeExecution) === null || _p === void 0 ? void 0 : _p.call(_o));\n                this.state.executingStep = true;\n                const result = await (0, promises_js_1.runAsPromise)(stepToRun)\n                    .finally(() => {\n                    this.state.executingStep = false;\n                })\n                    .catch(async (error) => {\n                    return await this.transformOutput({ error }, outgoingUserFnOp);\n                })\n                    .then(async (data) => {\n                    var _a, _b;\n                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));\n                    return await this.transformOutput({ data }, outgoingUserFnOp);\n                });\n                const { type: _type } = result, rest = __rest(result, [\"type\"]);\n                return {\n                    type: \"step-ran\",\n                    ctx: this.fnArg,\n                    ops: this.ops,\n                    step: Object.assign(Object.assign({}, outgoingUserFnOp), rest),\n                };\n            }\n            if (!discoveredOps.length) {\n                const fnRet = await Promise.race([\n                    userFnPromise.then((data) => ({ type: \"complete\", data })),\n                    (0, promises_js_1.resolveNextTick)().then(() => ({ type: \"incomplete\" })),\n                ]);\n                if (fnRet.type === \"complete\") {\n                    await ((_r = (_q = this.state.hooks).afterExecution) === null || _r === void 0 ? void 0 : _r.call(_q));\n                    const allOpsFulfilled = Object.values(this.state.allFoundOps).every((op) => {\n                        return op.fulfilled;\n                    });\n                    if (allOpsFulfilled) {\n                        return await this.transformOutput({ data: fnRet.data });\n                    }\n                }\n                else if (!this.state.hasUsedTools) {\n                    this.state.nonStepFnDetected = true;\n                    const data = await userFnPromise;\n                    await ((_t = (_s = this.state.hooks).afterExecution) === null || _t === void 0 ? void 0 : _t.call(_s));\n                    return await this.transformOutput({ data });\n                }\n                else {\n                    const hasOpsPending = Object.values(this.state.allFoundOps).some((op) => {\n                        return op.fulfilled === false;\n                    });\n                    if (!hasOpsPending) {\n                        throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.functionStoppedRunningErr)(errors_js_1.ErrCode.ASYNC_DETECTED_AFTER_MEMOIZATION));\n                    }\n                }\n            }\n            await ((_v = (_u = this.state.hooks).afterExecution) === null || _v === void 0 ? void 0 : _v.call(_u));\n            return {\n                type: \"steps-found\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                steps: discoveredOps,\n            };\n        }\n        catch (error) {\n            return await this.transformOutput({ error });\n        }\n        finally {\n            await ((_x = (_w = this.state.hooks).beforeResponse) === null || _x === void 0 ? void 0 : _x.call(_w));\n        }\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs,\n        }, {\n            transformInput: (prev, output) => {\n                return {\n                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i) => {\n                        var _a;\n                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));\n                    }),\n                    reqArgs: prev.reqArgs,\n                };\n            },\n            transformOutput: (prev, output) => {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    step: prev.step,\n                };\n            },\n        });\n        return hooks;\n    }\n    createExecutionState() {\n        const state = {\n            allFoundOps: {},\n            tickOps: {},\n            tickOpHashes: {},\n            currentOp: undefined,\n            hasUsedTools: false,\n            reset: () => {\n                state.tickOpHashes = {};\n                state.allFoundOps = Object.assign(Object.assign({}, state.allFoundOps), state.tickOps);\n            },\n            nonStepFnDetected: false,\n            executingStep: false,\n            opStack: this.options.stepCompletionOrder.reduce((acc, stepId) => {\n                const stepState = this.options.stepState[stepId];\n                if (!stepState) {\n                    return acc;\n                }\n                return [...acc, stepState];\n            }, []),\n        };\n        return state;\n    }\n    get ops() {\n        return Object.fromEntries(Object.entries(this.state.allFoundOps).map(([id, op]) => [\n            id,\n            {\n                id: op.id,\n                rawArgs: op.rawArgs,\n                data: op.data,\n                error: op.error,\n                fulfilled: op.fulfilled,\n                seen: true,\n            },\n        ]));\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) {\n            return this.options.fn[\"fn\"];\n        }\n        if (!this.options.fn[\"onFailureFn\"]) {\n            /**\n             * Somehow, we've ended up detecting that this is a failure handler but\n             * doesn't have an `onFailure` function. This should never happen.\n             */\n            throw new Error(\"Cannot find function `onFailure` handler\");\n        }\n        // TODO: Review; inferred types results in an `any` here!\n        return this.options.fn[\"onFailureFn\"];\n    }\n    createFnArg() {\n        var _a, _b, _c, _d;\n        // Start referencing everything\n        this.state.tickOps = this.state.allFoundOps;\n        /**\n         * Create a unique hash of an operation using only a subset of the operation's\n         * properties; will never use `data` and will guarantee the order of the\n         * object so we don't rely on individual tools for that.\n         *\n         * If the operation already contains an ID, the current ID will be used\n         * instead, so that users can provide their own IDs.\n         */\n        const hashOp = (\n        /**\n         * The op to generate a hash from. We only use a subset of the op's\n         * properties when creating the hash.\n         */\n        op) => {\n            var _a, _b, _c, _d;\n            /**\n             * It's difficult for v0 to understand whether or not an op has\n             * historically contained a custom ID, as all step usage now require them.\n             *\n             * For this reason, we make the assumption that steps in v0 do not have a\n             * custom ID and generate one for them as we would in all recommendations\n             * and examples.\n             */\n            const obj = {\n                parent: (_b = (_a = this.state.currentOp) === null || _a === void 0 ? void 0 : _a.id) !== null && _b !== void 0 ? _b : null,\n                op: op.op,\n                name: op.name,\n                // Historically, no v0 runs could have options for `step.run()` call,\n                // but this object can be specified in future versions.\n                //\n                // For this purpose, we change this to always use `null` if the op is\n                // that of a `step.run()`.\n                opts: op.op === types_js_1.StepOpCode.StepPlanned ? null : (_c = op.opts) !== null && _c !== void 0 ? _c : null,\n            };\n            const collisionHash = exports._internals.hashData(obj);\n            const pos = (this.state.tickOpHashes[collisionHash] =\n                ((_d = this.state.tickOpHashes[collisionHash]) !== null && _d !== void 0 ? _d : -1) + 1);\n            return Object.assign(Object.assign({}, op), { id: exports._internals.hashData(Object.assign({ pos }, obj)) });\n        };\n        const stepHandler = ({ args, matchOp, opts }) => {\n            if (this.state.nonStepFnDetected) {\n                throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.functionStoppedRunningErr)(errors_js_1.ErrCode.STEP_USED_AFTER_ASYNC));\n            }\n            if (this.state.executingStep) {\n                throw new NonRetriableError_js_1.NonRetriableError((0, errors_js_1.prettyError)({\n                    whatHappened: \"Your function was stopped from running\",\n                    why: \"We detected that you have nested `step.*` tooling.\",\n                    consequences: \"Nesting `step.*` tooling is not supported.\",\n                    stack: true,\n                    toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                    otherwise: \"For more information on step functions with Inngest, see https://www.inngest.com/docs/functions/multi-step\",\n                    code: errors_js_1.ErrCode.NESTING_STEPS,\n                }));\n            }\n            this.state.hasUsedTools = true;\n            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);\n            const opId = hashOp(matchOp(stepOptions, ...args.slice(1)));\n            return new Promise((resolve, reject) => {\n                this.state.tickOps[opId.id] = Object.assign(Object.assign(Object.assign({}, opId), ((opts === null || opts === void 0 ? void 0 : opts.fn) ? { fn: () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...args); } } : {})), { rawArgs: args, resolve,\n                    reject, fulfilled: false });\n            });\n        };\n        const step = (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);\n        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });\n        if (this.options.isFailureHandler) {\n            const eventData = zod_1.z\n                .object({ error: types_js_1.jsonErrorSchema })\n                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);\n            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });\n        }\n        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;\n    }\n    /**\n     * Using middleware, transform input before running.\n     */\n    async transformInput() {\n        var _a, _b;\n        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            ctx: Object.assign({}, this.fnArg),\n            steps: Object.values(this.options.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs,\n        }));\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {\n            this.fnArg = inputMutations.ctx;\n        }\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {\n            this.state.opStack = [...inputMutations.steps];\n        }\n    }\n    getEarlyExecRunStep(ops) {\n        if (ops.length !== 1)\n            return;\n        const op = ops[0];\n        if (op &&\n            op.op === types_js_1.StepOpCode.StepPlanned\n        // TODO We must individually check properties here that we do not want to\n        // execute on, such as retry counts. Nothing exists here that falls in to\n        // this case, but should be accounted for when we add them.\n        // && typeof op.opts === \"undefined\"\n        ) {\n            return op.id;\n        }\n    }\n    /**\n     * Using middleware, transform output before returning.\n     */\n    async transformOutput(dataOrError, step) {\n        var _a, _b, _c, _d;\n        const output = Object.assign({}, dataOrError);\n        if (typeof output.error !== \"undefined\") {\n            output.data = (0, errors_js_1.serializeError)(output.error);\n        }\n        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            result: Object.assign({}, output),\n            step,\n        }));\n        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);\n        if (!step) {\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {\n                result: Object.assign({}, (typeof error !== \"undefined\" ? { error } : { data })),\n            }));\n        }\n        if (typeof error !== \"undefined\") {\n            /**\n             * Ensure we give middleware the chance to decide on retriable behaviour\n             * by looking at the error returned from output transformation.\n             */\n            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError);\n            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {\n                retriable = error.retryAfter;\n            }\n            const serializedError = (0, errors_js_1.serializeError)(error);\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable,\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0, functions_js_1.undefinedToNull)(data),\n        };\n    }\n}\nexports.V0InngestExecution = V0InngestExecution;\nconst tickOpToOutgoing = (op) => {\n    return {\n        op: op.op,\n        id: op.id,\n        name: op.name,\n        opts: op.opts,\n    };\n};\nconst hashData = (op) => {\n    return (0, hash_js_1.sha1)().update((0, canonicalize_1.default)(op)).digest(\"hex\");\n};\n/**\n * Exported for testing.\n */\nexports._internals = { hashData };\n//# sourceMappingURL=v0.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsMEJBQTBCLEdBQUcsZ0NBQWdDO0FBQ2xGLHVDQUF1QyxtQkFBTyxDQUFDLDJFQUFjO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHlEQUFTO0FBQ25DLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMscUZBQTRCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDM0MsK0JBQStCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ2hFLDhCQUE4QixtQkFBTyxDQUFDLDJGQUF3QjtBQUM5RCwrQkFBK0IsbUJBQU8sQ0FBQyw2RkFBeUI7QUFDaEUsNkJBQTZCLG1CQUFPLENBQUMseUZBQXVCO0FBQzVELDhCQUE4QixtQkFBTyxDQUFDLG9HQUF1QjtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELDJDQUEyQyxRQUFRO0FBQ25HO0FBQ0EsdUVBQXVFLGlDQUFpQyxnQ0FBZ0M7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLHdEQUF3RCxPQUFPO0FBQy9ELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsTUFBTTtBQUM5RCxpQkFBaUI7QUFDakIsd0JBQXdCLGNBQWM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsd0JBQXdCO0FBQzVFLHVFQUF1RSxvQkFBb0I7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLDREQUE0RCxrQkFBa0I7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELE1BQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxTQUFTLGdEQUFnRCxLQUFLLFNBQVM7QUFDeEg7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLG9FQUFvRSxZQUFZLFFBQVEsdUZBQXVGLElBQUksTUFBTTtBQUNuUiw4Q0FBOEM7QUFDOUMsYUFBYTtBQUNiO0FBQ0E7QUFDQSxrREFBa0Qsd0JBQXdCLE1BQU07QUFDaEY7QUFDQTtBQUNBLDBCQUEwQixtQ0FBbUM7QUFDN0Q7QUFDQSxrREFBa0QsWUFBWSwyREFBMkQ7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0EsU0FBUztBQUNULGdCQUFnQixjQUFjLGdDQUFnQztBQUM5RDtBQUNBO0FBQ0Esd0NBQXdDLG9DQUFvQyxRQUFRLElBQUksTUFBTTtBQUM5RixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL3YwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVzdCA9ICh0aGlzICYmIHRoaXMuX19yZXN0KSB8fCBmdW5jdGlvbiAocywgZSkge1xuICAgIHZhciB0ID0ge307XG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXG4gICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5faW50ZXJuYWxzID0gZXhwb3J0cy5WMElubmdlc3RFeGVjdXRpb24gPSBleHBvcnRzLmNyZWF0ZVYwSW5uZ2VzdEV4ZWN1dGlvbiA9IHZvaWQgMDtcbmNvbnN0IGNhbm9uaWNhbGl6ZV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJjYW5vbmljYWxpemVcIikpO1xuY29uc3QgaGFzaF9qc18xID0gcmVxdWlyZShcImhhc2guanNcIik7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL2Vycm9ycy5qc1wiKTtcbmNvbnN0IGZ1bmN0aW9uc19qc18xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvZnVuY3Rpb25zLmpzXCIpO1xuY29uc3QgcHJvbWlzZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VzLmpzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlcy5qc1wiKTtcbmNvbnN0IElubmdlc3RNaWRkbGV3YXJlX2pzXzEgPSByZXF1aXJlKFwiLi4vSW5uZ2VzdE1pZGRsZXdhcmUuanNcIik7XG5jb25zdCBJbm5nZXN0U3RlcFRvb2xzX2pzXzEgPSByZXF1aXJlKFwiLi4vSW5uZ2VzdFN0ZXBUb29scy5qc1wiKTtcbmNvbnN0IE5vblJldHJpYWJsZUVycm9yX2pzXzEgPSByZXF1aXJlKFwiLi4vTm9uUmV0cmlhYmxlRXJyb3IuanNcIik7XG5jb25zdCBSZXRyeUFmdGVyRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9SZXRyeUFmdGVyRXJyb3IuanNcIik7XG5jb25zdCBJbm5nZXN0RXhlY3V0aW9uX2pzXzEgPSByZXF1aXJlKFwiLi9Jbm5nZXN0RXhlY3V0aW9uLmpzXCIpO1xuY29uc3QgY3JlYXRlVjBJbm5nZXN0RXhlY3V0aW9uID0gKG9wdGlvbnMpID0+IHtcbiAgICByZXR1cm4gbmV3IFYwSW5uZ2VzdEV4ZWN1dGlvbihvcHRpb25zKTtcbn07XG5leHBvcnRzLmNyZWF0ZVYwSW5uZ2VzdEV4ZWN1dGlvbiA9IGNyZWF0ZVYwSW5uZ2VzdEV4ZWN1dGlvbjtcbmNsYXNzIFYwSW5uZ2VzdEV4ZWN1dGlvbiBleHRlbmRzIElubmdlc3RFeGVjdXRpb25fanNfMS5Jbm5nZXN0RXhlY3V0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnVzZXJGblRvUnVuID0gdGhpcy5nZXRVc2VyRm5Ub1J1bigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5jcmVhdGVFeGVjdXRpb25TdGF0ZSgpO1xuICAgICAgICB0aGlzLmZuQXJnID0gdGhpcy5jcmVhdGVGbkFyZygpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmRlYnVnKFwic3RhcnRpbmcgVjAgZXhlY3V0aW9uXCIpO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuZXhlY3V0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAodGhpcy5leGVjdXRpb24gPSB0aGlzLl9zdGFydCgpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcInJlc3VsdDpcIiwgcmVzdWx0KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pKSk7XG4gICAgfVxuICAgIGFzeW5jIF9zdGFydCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rLCBfbCwgX20sIF9vLCBfcCwgX3EsIF9yLCBfcywgX3QsIF91LCBfdiwgX3csIF94O1xuICAgICAgICB0aGlzLnN0YXRlLmhvb2tzID0gYXdhaXQgdGhpcy5pbml0aWFsaXplTWlkZGxld2FyZSgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy50cmFuc2Zvcm1JbnB1dCgpO1xuICAgICAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpLmJlZm9yZU1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUub3BTdGFjay5sZW5ndGggPT09IDAgJiYgIXRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgKChfZiA9IChfZSA9IHRoaXMuc3RhdGUuaG9va3MpLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVzZXJGblByb21pc2UgPSAoMCwgcHJvbWlzZXNfanNfMS5ydW5Bc1Byb21pc2UpKCgpID0+IHRoaXMudXNlckZuVG9SdW4odGhpcy5mbkFyZykpO1xuICAgICAgICAgICAgbGV0IHBvcyA9IC0xO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChwb3MgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBwb3MgPT09IHRoaXMuc3RhdGUub3BTdGFjay5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCAoKF9oID0gKF9nID0gdGhpcy5zdGF0ZS5ob29rcykuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLmNhbGwoX2cpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0ICgoX2sgPSAoX2ogPSB0aGlzLnN0YXRlLmhvb2tzKS5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9rID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfay5jYWxsKF9qKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS50aWNrT3BzID0ge307XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGluY29taW5nT3AgPSB0aGlzLnN0YXRlLm9wU3RhY2tbcG9zXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5jdXJyZW50T3AgPSB0aGlzLnN0YXRlLmFsbEZvdW5kT3BzW2luY29taW5nT3AuaWRdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuY3VycmVudE9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFdlJ3JlIHRyeWluZyB0byByZXN1bWUgdGhlIGZ1bmN0aW9uLCBidXQgd2UgY2FuJ3QgZmluZCB3aGVyZSB0byBnby5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGlzIG1lYW5zIHRoYXQgZWl0aGVyIHRoZSBmdW5jdGlvbiBoYXMgY2hhbmdlZCBvciB0aGVyZSBhcmUgYXN5bmNcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGFjdGlvbnMgaW4tYmV0d2VlbiBzdGVwcyB0aGF0IHdlIGhhdmVuJ3Qgbm90aWNlZCBpbiBwcmV2aW91c1xuICAgICAgICAgICAgICAgICAgICAgICAgICogZXhlY3V0aW9ucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBXaGljaGV2ZXIgdGhlIGNhc2UsIHRoaXMgaXMgYmFkIGFuZCB3ZSBjYW4ndCBjb250aW51ZSBpbiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB1bmRlZmluZWQgc3RhdGUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCIgWW91ciBmdW5jdGlvbiB3YXMgc3RvcHBlZCBmcm9tIHJ1bm5pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aHk6IFwiV2UgY291bGRuJ3QgcmVzdW1lIHlvdXIgZnVuY3Rpb24ncyBzdGF0ZSBiZWNhdXNlIGl0IG1heSBoYXZlIGNoYW5nZWQgc2luY2UgdGhlIHJ1biBzdGFydGVkIG9yIHRoZXJlIGFyZSBhc3luYyBhY3Rpb25zIGluLWJldHdlZW4gc3RlcHMgdGhhdCB3ZSBoYXZlbid0IG5vdGljZWQgaW4gcHJldmlvdXMgZXhlY3V0aW9ucy5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zZXF1ZW5jZXM6IFwiQ29udGludWluZyB0byBydW4gdGhlIGZ1bmN0aW9uIG1heSByZXN1bHQgaW4gdW5leHBlY3RlZCBiZWhhdmlvdXIsIHNvIHdlJ3ZlIHN0b3BwZWQgeW91ciBmdW5jdGlvbiB0byBlbnN1cmUgbm90aGluZyB1bmV4cGVjdGVkIGhhcHBlbmVkIVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvRml4Tm93OiBcIkVuc3VyZSB0aGF0IHlvdXIgZnVuY3Rpb24gaXMgZWl0aGVyIGVudGlyZWx5IHN0ZXAtYmFzZWQgb3IgZW50aXJlbHkgbm9uLXN0ZXAtYmFzZWQsIGJ5IGVpdGhlciB3cmFwcGluZyBhbGwgYXN5bmNocm9ub3VzIGxvZ2ljIGluIGBzdGVwLnJ1bigpYCBjYWxscyBvciBieSByZW1vdmluZyBhbGwgYHN0ZXAuKigpYCBjYWxscy5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvdGhlcndpc2U6IFwiRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gd2h5IHN0ZXAgZnVuY3Rpb25zIHdvcmsgaW4gdGhpcyBtYW5uZXIsIHNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL2Z1bmN0aW9ucy9tdWx0aS1zdGVwI2dvdGNoYXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvcnNfanNfMS5FcnJDb2RlLk5PTl9ERVRFUk1JTklTVElDX0ZVTkNUSU9OLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuY3VycmVudE9wLmZ1bGZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5jb21pbmdPcC5kYXRhICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRPcC5yZXNvbHZlKGluY29taW5nT3AuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmN1cnJlbnRPcC5yZWplY3QoaW5jb21pbmdPcC5lcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgKDAsIHByb21pc2VzX2pzXzEucmVzb2x2ZUFmdGVyUGVuZGluZykoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICB9IHdoaWxlIChwb3MgPCB0aGlzLnN0YXRlLm9wU3RhY2subGVuZ3RoKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX20gPSAoX2wgPSB0aGlzLnN0YXRlLmhvb2tzKS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX20uY2FsbChfbCkpO1xuICAgICAgICAgICAgY29uc3QgZGlzY292ZXJlZE9wcyA9IE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS50aWNrT3BzKS5tYXAodGlja09wVG9PdXRnb2luZyk7XG4gICAgICAgICAgICBjb25zdCBydW5TdGVwID0gdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXAgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmdldEVhcmx5RXhlY1J1blN0ZXAoZGlzY292ZXJlZE9wcyk7XG4gICAgICAgICAgICBpZiAocnVuU3RlcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJGbk9wID0gdGhpcy5zdGF0ZS5hbGxGb3VuZE9wc1tydW5TdGVwXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwVG9SdW4gPSB1c2VyRm5PcCA9PT0gbnVsbCB8fCB1c2VyRm5PcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlckZuT3AuZm47XG4gICAgICAgICAgICAgICAgaWYgKCFzdGVwVG9SdW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgc3RhY2s7IGV4ZWN1dG9yIHJlcXVlc3RpbmcgdG8gcnVuIHVua25vd24gc3RlcCBcIiR7cnVuU3RlcH1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBvdXRnb2luZ1VzZXJGbk9wID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aWNrT3BUb091dGdvaW5nKHVzZXJGbk9wKSksIHsgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwIH0pO1xuICAgICAgICAgICAgICAgIGF3YWl0ICgoX3AgPSAoX28gPSB0aGlzLnN0YXRlLmhvb2tzKS5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfcC5jYWxsKF9vKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoMCwgcHJvbWlzZXNfanNfMS5ydW5Bc1Byb21pc2UpKHN0ZXBUb1J1bilcbiAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXAgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goYXN5bmMgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGVycm9yIH0sIG91dGdvaW5nVXNlckZuT3ApO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGRhdGEgfSwgb3V0Z29pbmdVc2VyRm5PcCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0eXBlOiBfdHlwZSB9ID0gcmVzdWx0LCByZXN0ID0gX19yZXN0KHJlc3VsdCwgW1widHlwZVwiXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLXJhblwiLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICAgICAgICAgIG9wczogdGhpcy5vcHMsXG4gICAgICAgICAgICAgICAgICAgIHN0ZXA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0Z29pbmdVc2VyRm5PcCksIHJlc3QpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRpc2NvdmVyZWRPcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm5SZXQgPSBhd2FpdCBQcm9taXNlLnJhY2UoW1xuICAgICAgICAgICAgICAgICAgICB1c2VyRm5Qcm9taXNlLnRoZW4oKGRhdGEpID0+ICh7IHR5cGU6IFwiY29tcGxldGVcIiwgZGF0YSB9KSksXG4gICAgICAgICAgICAgICAgICAgICgwLCBwcm9taXNlc19qc18xLnJlc29sdmVOZXh0VGljaykoKS50aGVuKCgpID0+ICh7IHR5cGU6IFwiaW5jb21wbGV0ZVwiIH0pKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICBpZiAoZm5SZXQudHlwZSA9PT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgoX3IgPSAoX3EgPSB0aGlzLnN0YXRlLmhvb2tzKS5hZnRlckV4ZWN1dGlvbikgPT09IG51bGwgfHwgX3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9yLmNhbGwoX3EpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWxsT3BzRnVsZmlsbGVkID0gT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlLmFsbEZvdW5kT3BzKS5ldmVyeSgob3ApID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvcC5mdWxmaWxsZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsT3BzRnVsZmlsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBkYXRhOiBmblJldC5kYXRhIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCF0aGlzLnN0YXRlLmhhc1VzZWRUb29scykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm5vblN0ZXBGbkRldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IHVzZXJGblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgoX3QgPSAoX3MgPSB0aGlzLnN0YXRlLmhvb2tzKS5hZnRlckV4ZWN1dGlvbikgPT09IG51bGwgfHwgX3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90LmNhbGwoX3MpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZGF0YSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhc09wc1BlbmRpbmcgPSBPYmplY3QudmFsdWVzKHRoaXMuc3RhdGUuYWxsRm91bmRPcHMpLnNvbWUoKG9wKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3AuZnVsZmlsbGVkID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaGFzT3BzUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vblJldHJpYWJsZUVycm9yX2pzXzEuTm9uUmV0cmlhYmxlRXJyb3IoKDAsIGVycm9yc19qc18xLmZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnIpKGVycm9yc19qc18xLkVyckNvZGUuQVNZTkNfREVURUNURURfQUZURVJfTUVNT0laQVRJT04pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgoX3YgPSAoX3UgPSB0aGlzLnN0YXRlLmhvb2tzKS5hZnRlckV4ZWN1dGlvbikgPT09IG51bGwgfHwgX3YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF92LmNhbGwoX3UpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwcy1mb3VuZFwiLFxuICAgICAgICAgICAgICAgIGN0eDogdGhpcy5mbkFyZyxcbiAgICAgICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgICAgIHN0ZXBzOiBkaXNjb3ZlcmVkT3BzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgKChfeCA9IChfdyA9IHRoaXMuc3RhdGUuaG9va3MpLmJlZm9yZVJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfeCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3guY2FsbChfdykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVNaWRkbGV3YXJlKCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLm9wdGlvbnMuZGF0YTtcbiAgICAgICAgY29uc3QgaG9va3MgPSBhd2FpdCAoMCwgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5nZXRIb29rU3RhY2spKHRoaXMub3B0aW9ucy5mbltcIm1pZGRsZXdhcmVcIl0sIFwib25GdW5jdGlvblJ1blwiLCB7XG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICBmbjogdGhpcy5vcHRpb25zLmZuLFxuICAgICAgICAgICAgc3RlcHM6IE9iamVjdC52YWx1ZXModGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSksXG4gICAgICAgICAgICByZXFBcmdzOiB0aGlzLm9wdGlvbnMucmVxQXJncyxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdHJhbnNmb3JtSW5wdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjdHg6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldi5jdHgpLCBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQuY3R4KSxcbiAgICAgICAgICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgICAgICAgICAgc3RlcHM6IHByZXYuc3RlcHMubWFwKChzdGVwLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcCksIChfYSA9IG91dHB1dCA9PT0gbnVsbCB8fCBvdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG91dHB1dC5zdGVwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICByZXFBcmdzOiBwcmV2LnJlcUFyZ3MsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2Zvcm1PdXRwdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldi5yZXN1bHQpLCBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQucmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogcHJldi5zdGVwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhvb2tzO1xuICAgIH1cbiAgICBjcmVhdGVFeGVjdXRpb25TdGF0ZSgpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgICAgICBhbGxGb3VuZE9wczoge30sXG4gICAgICAgICAgICB0aWNrT3BzOiB7fSxcbiAgICAgICAgICAgIHRpY2tPcEhhc2hlczoge30sXG4gICAgICAgICAgICBjdXJyZW50T3A6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGhhc1VzZWRUb29sczogZmFsc2UsXG4gICAgICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHN0YXRlLnRpY2tPcEhhc2hlcyA9IHt9O1xuICAgICAgICAgICAgICAgIHN0YXRlLmFsbEZvdW5kT3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hbGxGb3VuZE9wcyksIHN0YXRlLnRpY2tPcHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5vblN0ZXBGbkRldGVjdGVkOiBmYWxzZSxcbiAgICAgICAgICAgIGV4ZWN1dGluZ1N0ZXA6IGZhbHNlLFxuICAgICAgICAgICAgb3BTdGFjazogdGhpcy5vcHRpb25zLnN0ZXBDb21wbGV0aW9uT3JkZXIucmVkdWNlKChhY2MsIHN0ZXBJZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0ZXBTdGF0ZSA9IHRoaXMub3B0aW9ucy5zdGVwU3RhdGVbc3RlcElkXTtcbiAgICAgICAgICAgICAgICBpZiAoIXN0ZXBTdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLmFjYywgc3RlcFN0YXRlXTtcbiAgICAgICAgICAgIH0sIFtdKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBnZXQgb3BzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKE9iamVjdC5lbnRyaWVzKHRoaXMuc3RhdGUuYWxsRm91bmRPcHMpLm1hcCgoW2lkLCBvcF0pID0+IFtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlkOiBvcC5pZCxcbiAgICAgICAgICAgICAgICByYXdBcmdzOiBvcC5yYXdBcmdzLFxuICAgICAgICAgICAgICAgIGRhdGE6IG9wLmRhdGEsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG9wLmVycm9yLFxuICAgICAgICAgICAgICAgIGZ1bGZpbGxlZDogb3AuZnVsZmlsbGVkLFxuICAgICAgICAgICAgICAgIHNlZW46IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKSk7XG4gICAgfVxuICAgIGdldFVzZXJGblRvUnVuKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0ZhaWx1cmVIYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZuW1wiZm5cIl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZm5bXCJvbkZhaWx1cmVGblwiXSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTb21laG93LCB3ZSd2ZSBlbmRlZCB1cCBkZXRlY3RpbmcgdGhhdCB0aGlzIGlzIGEgZmFpbHVyZSBoYW5kbGVyIGJ1dFxuICAgICAgICAgICAgICogZG9lc24ndCBoYXZlIGFuIGBvbkZhaWx1cmVgIGZ1bmN0aW9uLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZ1bmN0aW9uIGBvbkZhaWx1cmVgIGhhbmRsZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogUmV2aWV3OyBpbmZlcnJlZCB0eXBlcyByZXN1bHRzIGluIGFuIGBhbnlgIGhlcmUhXG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZm5bXCJvbkZhaWx1cmVGblwiXTtcbiAgICB9XG4gICAgY3JlYXRlRm5BcmcoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gU3RhcnQgcmVmZXJlbmNpbmcgZXZlcnl0aGluZ1xuICAgICAgICB0aGlzLnN0YXRlLnRpY2tPcHMgPSB0aGlzLnN0YXRlLmFsbEZvdW5kT3BzO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgdW5pcXVlIGhhc2ggb2YgYW4gb3BlcmF0aW9uIHVzaW5nIG9ubHkgYSBzdWJzZXQgb2YgdGhlIG9wZXJhdGlvbidzXG4gICAgICAgICAqIHByb3BlcnRpZXM7IHdpbGwgbmV2ZXIgdXNlIGBkYXRhYCBhbmQgd2lsbCBndWFyYW50ZWUgdGhlIG9yZGVyIG9mIHRoZVxuICAgICAgICAgKiBvYmplY3Qgc28gd2UgZG9uJ3QgcmVseSBvbiBpbmRpdmlkdWFsIHRvb2xzIGZvciB0aGF0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGUgb3BlcmF0aW9uIGFscmVhZHkgY29udGFpbnMgYW4gSUQsIHRoZSBjdXJyZW50IElEIHdpbGwgYmUgdXNlZFxuICAgICAgICAgKiBpbnN0ZWFkLCBzbyB0aGF0IHVzZXJzIGNhbiBwcm92aWRlIHRoZWlyIG93biBJRHMuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBoYXNoT3AgPSAoXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgb3AgdG8gZ2VuZXJhdGUgYSBoYXNoIGZyb20uIFdlIG9ubHkgdXNlIGEgc3Vic2V0IG9mIHRoZSBvcCdzXG4gICAgICAgICAqIHByb3BlcnRpZXMgd2hlbiBjcmVhdGluZyB0aGUgaGFzaC5cbiAgICAgICAgICovXG4gICAgICAgIG9wKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEl0J3MgZGlmZmljdWx0IGZvciB2MCB0byB1bmRlcnN0YW5kIHdoZXRoZXIgb3Igbm90IGFuIG9wIGhhc1xuICAgICAgICAgICAgICogaGlzdG9yaWNhbGx5IGNvbnRhaW5lZCBhIGN1c3RvbSBJRCwgYXMgYWxsIHN0ZXAgdXNhZ2Ugbm93IHJlcXVpcmUgdGhlbS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGb3IgdGhpcyByZWFzb24sIHdlIG1ha2UgdGhlIGFzc3VtcHRpb24gdGhhdCBzdGVwcyBpbiB2MCBkbyBub3QgaGF2ZSBhXG4gICAgICAgICAgICAgKiBjdXN0b20gSUQgYW5kIGdlbmVyYXRlIG9uZSBmb3IgdGhlbSBhcyB3ZSB3b3VsZCBpbiBhbGwgcmVjb21tZW5kYXRpb25zXG4gICAgICAgICAgICAgKiBhbmQgZXhhbXBsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IHtcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IChfYiA9IChfYSA9IHRoaXMuc3RhdGUuY3VycmVudE9wKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG51bGwsXG4gICAgICAgICAgICAgICAgb3A6IG9wLm9wLFxuICAgICAgICAgICAgICAgIG5hbWU6IG9wLm5hbWUsXG4gICAgICAgICAgICAgICAgLy8gSGlzdG9yaWNhbGx5LCBubyB2MCBydW5zIGNvdWxkIGhhdmUgb3B0aW9ucyBmb3IgYHN0ZXAucnVuKClgIGNhbGwsXG4gICAgICAgICAgICAgICAgLy8gYnV0IHRoaXMgb2JqZWN0IGNhbiBiZSBzcGVjaWZpZWQgaW4gZnV0dXJlIHZlcnNpb25zLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gRm9yIHRoaXMgcHVycG9zZSwgd2UgY2hhbmdlIHRoaXMgdG8gYWx3YXlzIHVzZSBgbnVsbGAgaWYgdGhlIG9wIGlzXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBvZiBhIGBzdGVwLnJ1bigpYC5cbiAgICAgICAgICAgICAgICBvcHRzOiBvcC5vcCA9PT0gdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBQbGFubmVkID8gbnVsbCA6IChfYyA9IG9wLm9wdHMpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgY29sbGlzaW9uSGFzaCA9IGV4cG9ydHMuX2ludGVybmFscy5oYXNoRGF0YShvYmopO1xuICAgICAgICAgICAgY29uc3QgcG9zID0gKHRoaXMuc3RhdGUudGlja09wSGFzaGVzW2NvbGxpc2lvbkhhc2hdID1cbiAgICAgICAgICAgICAgICAoKF9kID0gdGhpcy5zdGF0ZS50aWNrT3BIYXNoZXNbY29sbGlzaW9uSGFzaF0pICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IC0xKSArIDEpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ApLCB7IGlkOiBleHBvcnRzLl9pbnRlcm5hbHMuaGFzaERhdGEoT2JqZWN0LmFzc2lnbih7IHBvcyB9LCBvYmopKSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RlcEhhbmRsZXIgPSAoeyBhcmdzLCBtYXRjaE9wLCBvcHRzIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLm5vblN0ZXBGbkRldGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vblJldHJpYWJsZUVycm9yX2pzXzEuTm9uUmV0cmlhYmxlRXJyb3IoKDAsIGVycm9yc19qc18xLmZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnIpKGVycm9yc19qc18xLkVyckNvZGUuU1RFUF9VU0VEX0FGVEVSX0FTWU5DKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5vblJldHJpYWJsZUVycm9yX2pzXzEuTm9uUmV0cmlhYmxlRXJyb3IoKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCJZb3VyIGZ1bmN0aW9uIHdhcyBzdG9wcGVkIGZyb20gcnVubmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICB3aHk6IFwiV2UgZGV0ZWN0ZWQgdGhhdCB5b3UgaGF2ZSBuZXN0ZWQgYHN0ZXAuKmAgdG9vbGluZy5cIixcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIk5lc3RpbmcgYHN0ZXAuKmAgdG9vbGluZyBpcyBub3Qgc3VwcG9ydGVkLlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdG9GaXhOb3c6IFwiTWFrZSBzdXJlIHlvdSdyZSBub3QgdXNpbmcgYHN0ZXAuKmAgdG9vbGluZyBpbnNpZGUgb2Ygb3RoZXIgYHN0ZXAuKmAgdG9vbGluZy4gSWYgeW91IG5lZWQgdG8gY29tcG9zZSBzdGVwcyB0b2dldGhlciwgeW91IGNhbiBjcmVhdGUgYSBuZXcgYXN5bmMgZnVuY3Rpb24gYW5kIGNhbGwgaXQgZnJvbSB3aXRoaW4geW91ciBzdGVwIGZ1bmN0aW9uLCBvciB1c2UgcHJvbWlzZSBjaGFpbmluZy5cIixcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJ3aXNlOiBcIkZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHN0ZXAgZnVuY3Rpb25zIHdpdGggSW5uZ2VzdCwgc2VlIGh0dHBzOi8vd3d3Lmlubmdlc3QuY29tL2RvY3MvZnVuY3Rpb25zL211bHRpLXN0ZXBcIixcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JzX2pzXzEuRXJyQ29kZS5ORVNUSU5HX1NURVBTLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhdGUuaGFzVXNlZFRvb2xzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBPcHRpb25zID0gKDAsIElubmdlc3RTdGVwVG9vbHNfanNfMS5nZXRTdGVwT3B0aW9ucykoYXJnc1swXSk7XG4gICAgICAgICAgICBjb25zdCBvcElkID0gaGFzaE9wKG1hdGNoT3Aoc3RlcE9wdGlvbnMsIC4uLmFyZ3Muc2xpY2UoMSkpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS50aWNrT3BzW29wSWQuaWRdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wSWQpLCAoKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5mbikgPyB7IGZuOiAoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IG9wdHMuZm4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdHMsIC4uLmFyZ3MpOyB9IH0gOiB7fSkpLCB7IHJhd0FyZ3M6IGFyZ3MsIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCwgZnVsZmlsbGVkOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdGVwID0gKDAsIElubmdlc3RTdGVwVG9vbHNfanNfMS5jcmVhdGVTdGVwVG9vbHMpKHRoaXMub3B0aW9ucy5jbGllbnQsIHRoaXMsIHN0ZXBIYW5kbGVyKTtcbiAgICAgICAgbGV0IGZuQXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMuZGF0YSksIHsgc3RlcCB9KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0ZhaWx1cmVIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudERhdGEgPSB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7IGVycm9yOiB0eXBlc19qc18xLmpzb25FcnJvclNjaGVtYSB9KVxuICAgICAgICAgICAgICAgIC5wYXJzZSgoX2EgPSBmbkFyZy5ldmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpO1xuICAgICAgICAgICAgZm5BcmcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZuQXJnKSwgeyBlcnJvcjogKDAsIGVycm9yc19qc18xLmRlc2VyaWFsaXplRXJyb3IpKGV2ZW50RGF0YS5lcnJvcikgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfZCA9IChfYyA9IChfYiA9IHRoaXMub3B0aW9ucykudHJhbnNmb3JtQ3R4KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgZm5BcmcpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmbkFyZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIGlucHV0IGJlZm9yZSBydW5uaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybUlucHV0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBpbnB1dE11dGF0aW9ucyA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNmb3JtSW5wdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICAgICAgICBjdHg6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZm5BcmcpLFxuICAgICAgICAgICAgc3RlcHM6IE9iamVjdC52YWx1ZXModGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSksXG4gICAgICAgICAgICBmbjogdGhpcy5vcHRpb25zLmZuLFxuICAgICAgICAgICAgcmVxQXJnczogdGhpcy5vcHRpb25zLnJlcUFyZ3MsXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKGlucHV0TXV0YXRpb25zID09PSBudWxsIHx8IGlucHV0TXV0YXRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dE11dGF0aW9ucy5jdHgpIHtcbiAgICAgICAgICAgIHRoaXMuZm5BcmcgPSBpbnB1dE11dGF0aW9ucy5jdHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0TXV0YXRpb25zID09PSBudWxsIHx8IGlucHV0TXV0YXRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dE11dGF0aW9ucy5zdGVwcykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5vcFN0YWNrID0gWy4uLmlucHV0TXV0YXRpb25zLnN0ZXBzXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFYXJseUV4ZWNSdW5TdGVwKG9wcykge1xuICAgICAgICBpZiAob3BzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3AgPSBvcHNbMF07XG4gICAgICAgIGlmIChvcCAmJlxuICAgICAgICAgICAgb3Aub3AgPT09IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUGxhbm5lZFxuICAgICAgICAvLyBUT0RPIFdlIG11c3QgaW5kaXZpZHVhbGx5IGNoZWNrIHByb3BlcnRpZXMgaGVyZSB0aGF0IHdlIGRvIG5vdCB3YW50IHRvXG4gICAgICAgIC8vIGV4ZWN1dGUgb24sIHN1Y2ggYXMgcmV0cnkgY291bnRzLiBOb3RoaW5nIGV4aXN0cyBoZXJlIHRoYXQgZmFsbHMgaW4gdG9cbiAgICAgICAgLy8gdGhpcyBjYXNlLCBidXQgc2hvdWxkIGJlIGFjY291bnRlZCBmb3Igd2hlbiB3ZSBhZGQgdGhlbS5cbiAgICAgICAgLy8gJiYgdHlwZW9mIG9wLm9wdHMgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgKSB7XG4gICAgICAgICAgICByZXR1cm4gb3AuaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIG91dHB1dCBiZWZvcmUgcmV0dXJuaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybU91dHB1dChkYXRhT3JFcnJvciwgc3RlcCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGFPckVycm9yKTtcbiAgICAgICAgaWYgKHR5cGVvZiBvdXRwdXQuZXJyb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIG91dHB1dC5kYXRhID0gKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShvdXRwdXQuZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkT3V0cHV0ID0gYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmFuc2Zvcm1PdXRwdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oe30sIG91dHB1dCksXG4gICAgICAgICAgICBzdGVwLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0KSwgdHJhbnNmb3JtZWRPdXRwdXQgPT09IG51bGwgfHwgdHJhbnNmb3JtZWRPdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybWVkT3V0cHV0LnJlc3VsdCk7XG4gICAgICAgIGlmICghc3RlcCkge1xuICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5maW5pc2hlZCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MsIHtcbiAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oe30sICh0eXBlb2YgZXJyb3IgIT09IFwidW5kZWZpbmVkXCIgPyB7IGVycm9yIH0gOiB7IGRhdGEgfSkpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXJyb3IgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRW5zdXJlIHdlIGdpdmUgbWlkZGxld2FyZSB0aGUgY2hhbmNlIHRvIGRlY2lkZSBvbiByZXRyaWFibGUgYmVoYXZpb3VyXG4gICAgICAgICAgICAgKiBieSBsb29raW5nIGF0IHRoZSBlcnJvciByZXR1cm5lZCBmcm9tIG91dHB1dCB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IHJldHJpYWJsZSA9ICEoZXJyb3IgaW5zdGFuY2VvZiBOb25SZXRyaWFibGVFcnJvcl9qc18xLk5vblJldHJpYWJsZUVycm9yKTtcbiAgICAgICAgICAgIGlmIChyZXRyaWFibGUgJiYgZXJyb3IgaW5zdGFuY2VvZiBSZXRyeUFmdGVyRXJyb3JfanNfMS5SZXRyeUFmdGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXRyaWFibGUgPSBlcnJvci5yZXRyeUFmdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZEVycm9yID0gKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb24tcmVqZWN0ZWRcIixcbiAgICAgICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICAgICAgb3BzOiB0aGlzLm9wcyxcbiAgICAgICAgICAgICAgICBlcnJvcjogc2VyaWFsaXplZEVycm9yLFxuICAgICAgICAgICAgICAgIHJldHJpYWJsZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb24tcmVzb2x2ZWRcIixcbiAgICAgICAgICAgIGN0eDogdGhpcy5mbkFyZyxcbiAgICAgICAgICAgIG9wczogdGhpcy5vcHMsXG4gICAgICAgICAgICBkYXRhOiAoMCwgZnVuY3Rpb25zX2pzXzEudW5kZWZpbmVkVG9OdWxsKShkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnRzLlYwSW5uZ2VzdEV4ZWN1dGlvbiA9IFYwSW5uZ2VzdEV4ZWN1dGlvbjtcbmNvbnN0IHRpY2tPcFRvT3V0Z29pbmcgPSAob3ApID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcDogb3Aub3AsXG4gICAgICAgIGlkOiBvcC5pZCxcbiAgICAgICAgbmFtZTogb3AubmFtZSxcbiAgICAgICAgb3B0czogb3Aub3B0cyxcbiAgICB9O1xufTtcbmNvbnN0IGhhc2hEYXRhID0gKG9wKSA9PiB7XG4gICAgcmV0dXJuICgwLCBoYXNoX2pzXzEuc2hhMSkoKS51cGRhdGUoKDAsIGNhbm9uaWNhbGl6ZV8xLmRlZmF1bHQpKG9wKSkuZGlnZXN0KFwiaGV4XCIpO1xufTtcbi8qKlxuICogRXhwb3J0ZWQgZm9yIHRlc3RpbmcuXG4gKi9cbmV4cG9ydHMuX2ludGVybmFscyA9IHsgaGFzaERhdGEgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXYwLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v0.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v1.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v1.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._internals = exports.createV1InngestExecution = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst errors_js_1 = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst promises_js_1 = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst types_js_1 = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst version_js_1 = __webpack_require__(/*! ../../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst RetryAfterError_js_1 = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nconst StepError_js_1 = __webpack_require__(/*! ../StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst als_js_1 = __webpack_require__(/*! ./als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst access_js_1 = __webpack_require__(/*! ./otel/access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\nconst createV1InngestExecution = (options) => {\n    return new V1InngestExecution(options);\n};\nexports.createV1InngestExecution = createV1InngestExecution;\nclass V1InngestExecution extends InngestExecution_js_1.InngestExecution {\n    constructor(options) {\n        super(options);\n        this.timeoutDuration = 1000 * 10;\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n        this.checkpointHandlers = this.createCheckpointHandlers();\n        this.initializeTimer(this.state);\n        this.debug(\"created new V1 execution for run;\", this.options.requestedRunStep\n            ? `wanting to run step \"${this.options.requestedRunStep}\"`\n            : \"discovering steps\");\n        this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n    }\n    /**\n     * Idempotently start the execution of the user's function.\n     */\n    start() {\n        if (!this.execution) {\n            this.debug(\"starting V1 execution\");\n            const tracer = api_1.trace.getTracer(\"inngest\", version_js_1.version);\n            this.execution = (0, als_js_1.getAsyncLocalStorage)().then((als) => {\n                return als.run({ app: this.options.client, ctx: this.fnArg }, async () => {\n                    return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n                        var _a;\n                        (_a = access_js_1.clientProcessorMap.get(this.options.client)) === null || _a === void 0 ? void 0 : _a.declareStartingSpan({\n                            span,\n                            runId: this.options.runId,\n                            traceparent: this.options.headers[consts_js_1.headerKeys.TraceParent],\n                            tracestate: this.options.headers[consts_js_1.headerKeys.TraceState],\n                        });\n                        return this._start()\n                            .then((result) => {\n                            this.debug(\"result:\", result);\n                            return result;\n                        })\n                            .finally(() => {\n                            span.end();\n                        });\n                    });\n                });\n            });\n        }\n        return this.execution;\n    }\n    /**\n     * Starts execution of the user's function and the core loop.\n     */\n    async _start() {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        try {\n            const allCheckpointHandler = this.getCheckpointHandler(\"\");\n            this.state.hooks = await this.initializeMiddleware();\n            await this.startExecution();\n            try {\n                for (var _f = true, _g = __asyncValues(this.state.loop), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                    _c = _h.value;\n                    _f = false;\n                    const checkpoint = _c;\n                    await allCheckpointHandler(checkpoint);\n                    const handler = this.getCheckpointHandler(checkpoint.type);\n                    const result = await handler(checkpoint);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        catch (error) {\n            return await this.transformOutput({ error });\n        }\n        finally {\n            void this.state.loop.return();\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeResponse) === null || _e === void 0 ? void 0 : _e.call(_d));\n        }\n        /**\n         * If we're here, the generator somehow finished without returning a value.\n         * This should never happen.\n         */\n        throw new Error(\"Core loop finished without returning a value\");\n    }\n    /**\n     * Creates a handler for every checkpoint type, defining what to do when we\n     * reach that checkpoint in the core loop.\n     */\n    createCheckpointHandlers() {\n        return {\n            /**\n             * Run for all checkpoints. Best used for logging or common actions.\n             * Use other handlers to return values and interrupt the core loop.\n             */\n            \"\": (checkpoint) => {\n                this.debug(\"checkpoint:\", checkpoint);\n            },\n            /**\n             * The user's function has completed and returned a value.\n             */\n            \"function-resolved\": async (checkpoint) => {\n                return await this.transformOutput({ data: checkpoint.data });\n            },\n            /**\n             * The user's function has thrown an error.\n             */\n            \"function-rejected\": async (checkpoint) => {\n                return await this.transformOutput({ error: checkpoint.error });\n            },\n            /**\n             * We've found one or more steps. Here we may want to run a step or report\n             * them back to Inngest.\n             */\n            \"steps-found\": async ({ steps }) => {\n                const stepResult = await this.tryExecuteStep(steps);\n                if (stepResult) {\n                    const transformResult = await this.transformOutput(stepResult);\n                    /**\n                     * Transforming output will always return either function rejection or\n                     * resolution. In most cases, this can be immediately returned, but in\n                     * this particular case we want to handle it differently.\n                     */\n                    if (transformResult.type === \"function-resolved\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { data: transformResult.data })),\n                        };\n                    }\n                    else if (transformResult.type === \"function-rejected\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { error: transformResult.error })),\n                            retriable: transformResult.retriable,\n                        };\n                    }\n                    return transformResult;\n                }\n                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));\n                if (newSteps) {\n                    return {\n                        type: \"steps-found\",\n                        ctx: this.fnArg,\n                        ops: this.ops,\n                        steps: newSteps,\n                    };\n                }\n            },\n            /**\n             * While trying to find a step that Inngest has told us to run, we've\n             * timed out or have otherwise decided that it doesn't exist.\n             */\n            \"step-not-found\": ({ step }) => {\n                return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n            },\n        };\n    }\n    getCheckpointHandler(type) {\n        return this.checkpointHandlers[type];\n    }\n    async tryExecuteStep(steps) {\n        var _a;\n        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n        if (!hashedStepIdToRun) {\n            return;\n        }\n        const step = steps.find((step) => step.hashedId === hashedStepIdToRun && step.fn);\n        if (step) {\n            return await this.executeStep(step);\n        }\n        /**\n         * Ensure we reset the timeout if we have a requested run step but couldn't\n         * find it, but also that we don't reset if we found and executed it.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.reset());\n    }\n    /**\n     * Given a list of outgoing ops, decide if we can execute an op early and\n     * return the ID of the step to execute if we can.\n     */\n    getEarlyExecRunStep(steps) {\n        /**\n         * We may have been disabled due to parallelism, in which case we can't\n         * immediately execute unless explicitly requested.\n         */\n        if (this.options.disableImmediateExecution)\n            return;\n        const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n        if (unfulfilledSteps.length !== 1)\n            return;\n        const op = unfulfilledSteps[0];\n        if (op &&\n            op.op === types_js_1.StepOpCode.StepPlanned\n        // TODO We must individually check properties here that we do not want to\n        // execute on, such as retry counts. Nothing exists here that falls in to\n        // this case, but should be accounted for when we add them.\n        // && typeof op.opts === \"undefined\"\n        ) {\n            return op.hashedId;\n        }\n    }\n    async filterNewSteps(foundSteps) {\n        var _a, _b, _c, _d, _e, _f;\n        if (this.options.requestedRunStep) {\n            return;\n        }\n        /**\n         * Gather any steps that aren't memoized and report them.\n         */\n        const newSteps = foundSteps.filter((step) => !step.fulfilled);\n        if (!newSteps.length) {\n            return;\n        }\n        /**\n         * Warn if we've found new steps but haven't yet seen all previous\n         * steps. This may indicate that step presence isn't determinate.\n         */\n        let knownSteps = 0;\n        for (const step of foundSteps) {\n            if (step.fulfilled) {\n                knownSteps++;\n            }\n        }\n        const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n        if (!foundAllCompletedSteps) {\n            // TODO Tag\n            console.warn((0, errors_js_1.prettyError)({\n                type: \"warn\",\n                whatHappened: \"Function may be indeterminate\",\n                why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n                consequences: \"This may cause unexpected behaviour as Inngest executes your function.\",\n                reassurance: \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n            }));\n        }\n        /**\n         * We're finishing up; let's trigger the last of the hooks.\n         */\n        await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n        await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n        await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        const stepList = newSteps.map((step) => ({\n            displayName: step.displayName,\n            op: step.op,\n            id: step.hashedId,\n            name: step.name,\n            opts: step.opts,\n        }));\n        /**\n         * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n         * to ensure that their `data` is transformed correctly.\n         */\n        return await this.transformNewSteps(stepList);\n    }\n    /**\n     * Using middleware, transform any newly-found steps before returning them to\n     * an Inngest Server.\n     */\n    async transformNewSteps(steps) {\n        return Promise.all(steps.map(async (step) => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (step.op !== types_js_1.StepOpCode.InvokeFunction) {\n                return step;\n            }\n            const onSendEventHooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onSendEvent\", undefined, {\n                transformInput: (prev, output) => {\n                    return Object.assign(Object.assign({}, prev), output);\n                },\n                transformOutput: (prev, output) => {\n                    return {\n                        result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    };\n                },\n            });\n            /**\n             * For each event being sent, create a new `onSendEvent` hook stack to\n             * process it. We do this as middleware hooks are intended to run once\n             * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n             * is run for every single event.\n             *\n             * This is done because a developer can use this hook to filter out\n             * events entirely; if we batch all of the events together, we can't\n             * tell which ones were filtered out if we're processing >1 invocation\n             * here.\n             */\n            const transformedPayload = await ((_a = onSendEventHooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(onSendEventHooks, {\n                payloads: [\n                    Object.assign(Object.assign({}, ((_c = (_b = step.opts) === null || _b === void 0 ? void 0 : _b.payload) !== null && _c !== void 0 ? _c : {})), { name: consts_js_1.internalEvents.FunctionInvoked }),\n                ],\n            }));\n            const newPayload = InngestStepTools_js_1.invokePayloadSchema.parse((_e = (_d = transformedPayload === null || transformedPayload === void 0 ? void 0 : transformedPayload.payloads) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : {});\n            return Object.assign(Object.assign({}, step), { opts: Object.assign(Object.assign({}, step.opts), { payload: Object.assign(Object.assign({}, ((_g = (_f = step.opts) === null || _f === void 0 ? void 0 : _f.payload) !== null && _g !== void 0 ? _g : {})), newPayload) }) });\n        }));\n    }\n    async executeStep({ id, name, opts, fn, displayName, }) {\n        var _a, _b, _c, _d, _e;\n        (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.afterMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(_d));\n        const outgoingOp = {\n            id,\n            op: types_js_1.StepOpCode.StepRun,\n            name,\n            opts,\n            displayName,\n        };\n        this.state.executingStep = outgoingOp;\n        const store = await (0, als_js_1.getAsyncCtx)();\n        if (store) {\n            store.executingStep = {\n                id,\n                name: displayName,\n            };\n        }\n        this.debug(`executing step \"${id}\"`);\n        return ((0, promises_js_1.runAsPromise)(fn)\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b;\n            if (store) {\n                delete store.executingStep;\n            }\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));\n        })\n            .then((data) => {\n            return Object.assign(Object.assign({}, outgoingOp), { data });\n        })\n            .catch((error) => {\n            return Object.assign(Object.assign({}, outgoingOp), { op: types_js_1.StepOpCode.StepError, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                error });\n        }));\n    }\n    /**\n     * Starts execution of the user's function, including triggering checkpoints\n     * and middleware hooks where appropriate.\n     */\n    async startExecution() {\n        var _a, _b, _c, _d, _e, _f, _g;\n        /**\n         * Mutate input as neccessary based on middleware.\n         */\n        await this.transformInput();\n        /**\n         * Start the timer to time out the run if needed.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.start());\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        /**\n         * If we had no state to begin with, immediately end the memoization phase.\n         */\n        if (this.state.allStateUsed()) {\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.afterMemoization) === null || _e === void 0 ? void 0 : _e.call(_d));\n            await ((_g = (_f = this.state.hooks) === null || _f === void 0 ? void 0 : _f.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(_f));\n        }\n        /**\n         * Trigger the user's function.\n         */\n        (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg))\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        })\n            .then((data) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-resolved\", data });\n        })\n            .catch((error) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-rejected\", error });\n        });\n    }\n    /**\n     * Using middleware, transform input before running.\n     */\n    async transformInput() {\n        var _a, _b;\n        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            ctx: Object.assign({}, this.fnArg),\n            steps: Object.values(this.state.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs,\n        }));\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {\n            this.fnArg = inputMutations.ctx;\n        }\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {\n            this.state.stepState = Object.fromEntries(inputMutations.steps.map((step) => [step.id, step]));\n        }\n    }\n    /**\n     * Using middleware, transform output before returning.\n     */\n    async transformOutput(dataOrError) {\n        var _a, _b, _c, _d;\n        const output = Object.assign({}, dataOrError);\n        /**\n         * If we've been given an error and it's one that we just threw from a step,\n         * we should return a `NonRetriableError` to stop execution.\n         */\n        if (typeof output.error !== \"undefined\") {\n            output.data = (0, errors_js_1.serializeError)(output.error);\n        }\n        const isStepExecution = Boolean(this.state.executingStep);\n        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            result: Object.assign({}, output),\n            step: this.state.executingStep,\n        }));\n        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);\n        if (!isStepExecution) {\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {\n                result: Object.assign({}, (typeof error !== \"undefined\" ? { error } : { data })),\n            }));\n        }\n        if (typeof error !== \"undefined\") {\n            /**\n             * Ensure we give middleware the chance to decide on retriable behaviour\n             * by looking at the error returned from output transformation.\n             */\n            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError || error instanceof StepError_js_1.StepError);\n            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {\n                retriable = error.retryAfter;\n            }\n            const serializedError = (0, errors_js_1.minifyPrettyError)((0, errors_js_1.serializeError)(error));\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable,\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0, functions_js_1.undefinedToNull)(data),\n        };\n    }\n    createExecutionState() {\n        const d = (0, promises_js_1.createDeferredPromiseWithStack)();\n        let checkpointResolve = d.deferred.resolve;\n        const checkpointResults = d.results;\n        const loop = (function (cleanUp) {\n            return __asyncGenerator(this, arguments, function* () {\n                try {\n                    while (true) {\n                        const res = (yield __await(checkpointResults.next())).value;\n                        if (res) {\n                            yield yield __await(res);\n                        }\n                    }\n                }\n                finally {\n                    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();\n                }\n            });\n        })(() => {\n            var _a;\n            (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n            void checkpointResults.return();\n        });\n        const stepsToFulfill = Object.keys(this.options.stepState).length;\n        const state = {\n            stepState: this.options.stepState,\n            stepsToFulfill,\n            steps: new Map(),\n            loop,\n            hasSteps: Boolean(stepsToFulfill),\n            stepCompletionOrder: [...this.options.stepCompletionOrder],\n            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n            setCheckpoint: (checkpoint) => {\n                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n            },\n            allStateUsed: () => {\n                return this.state.remainingStepsToBeSeen.size === 0;\n            },\n        };\n        return state;\n    }\n    get ops() {\n        return Object.fromEntries(this.state.steps);\n    }\n    createFnArg() {\n        var _a, _b, _c, _d;\n        const step = this.createStepTools();\n        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });\n        /**\n         * Handle use of the `onFailure` option by deserializing the error.\n         */\n        if (this.options.isFailureHandler) {\n            const eventData = zod_1.z\n                .object({ error: types_js_1.jsonErrorSchema })\n                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);\n            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });\n        }\n        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;\n    }\n    createStepTools() {\n        /**\n         * A list of steps that have been found and are being rolled up before being\n         * reported to the core loop.\n         */\n        const foundStepsToReport = new Map();\n        /**\n         * A map of the subset of found steps to report that have not yet been\n         * handled. Used for fast access to steps that need to be handled in order.\n         */\n        const unhandledFoundStepsToReport = new Map();\n        /**\n         * A map of the latest sequential step indexes found for each step ID. Used\n         * to ensure that we don't index steps in parallel.\n         *\n         * Note that these must be sequential; if we've seen or assigned `a:1`,\n         * `a:2` and `a:4`, the latest sequential step index is `2`.\n         *\n         */\n        const expectedNextStepIndexes = new Map();\n        /**\n         * An ordered list of step IDs that have yet to be handled in this\n         * execution. Used to ensure that we handle steps in the order they were\n         * found and based on the `stepCompletionOrder` in this execution's state.\n         */\n        const remainingStepCompletionOrder = this.state.stepCompletionOrder.slice();\n        /**\n         * A promise that's used to ensure that step reporting cannot be run more than\n         * once in a given asynchronous time span.\n         */\n        let foundStepsReportPromise;\n        /**\n         * A promise that's used to represent middleware hooks running before\n         * execution.\n         */\n        let beforeExecHooksPromise;\n        /**\n         * A flag used to ensure that we only warn about parallel indexing once per\n         * execution to avoid spamming the console.\n         */\n        let warnOfParallelIndexing = false;\n        /**\n         * Counts the number of times we've extended this tick.\n         */\n        let tickExtensionCount = 0;\n        /**\n         * Given a colliding step ID, maybe warn the user about parallel indexing.\n         */\n        const maybeWarnOfParallelIndexing = (collisionId) => {\n            if (warnOfParallelIndexing) {\n                return;\n            }\n            const stepExists = this.state.steps.has(collisionId);\n            if (stepExists) {\n                const stepFoundThisTick = foundStepsToReport.has(collisionId);\n                if (!stepFoundThisTick) {\n                    warnOfParallelIndexing = true;\n                    console.warn((0, errors_js_1.prettyError)({\n                        type: \"warn\",\n                        whatHappened: \"We detected that you have multiple steps with the same ID.\",\n                        code: errors_js_1.ErrCode.AUTOMATIC_PARALLEL_INDEXING,\n                        why: `This can happen if you're using the same ID for multiple steps across different chains of parallel work. We found the issue with step \"${collisionId}\".`,\n                        reassurance: \"Your function is still running, though it may exhibit unexpected behaviour.\",\n                        consequences: \"Using the same IDs across parallel chains of work can cause unexpected behaviour.\",\n                        toFixNow: \"We recommend using a unique ID for each step, especially those happening in parallel.\",\n                    }));\n                }\n            }\n        };\n        /**\n         * A helper used to report steps to the core loop. Used after adding an item\n         * to `foundStepsToReport`.\n         */\n        const reportNextTick = () => {\n            // Being explicit instead of using `??=` to appease TypeScript.\n            if (foundStepsReportPromise) {\n                return;\n            }\n            let extensionPromise;\n            if (++tickExtensionCount >= 10) {\n                tickExtensionCount = 0;\n                extensionPromise = new Promise((resolve) => setTimeout(resolve));\n            }\n            else {\n                extensionPromise = (0, promises_js_1.resolveAfterPending)();\n            }\n            foundStepsReportPromise = extensionPromise\n                /**\n                 * Ensure that we wait for this promise to resolve before continuing.\n                 *\n                 * The groups in which steps are reported can affect how we detect some\n                 * more complex determinism issues like parallel indexing. This promise\n                 * can represent middleware hooks being run early, in the middle of\n                 * ingesting steps to report.\n                 *\n                 * Because of this, it's important we wait for this middleware to resolve\n                 * before continuing to report steps to ensure that all steps have a\n                 * chance to be reported throughout this asynchronous action.\n                 */\n                .then(() => beforeExecHooksPromise)\n                .then(() => {\n                var _a;\n                foundStepsReportPromise = undefined;\n                for (let i = 0; i < remainingStepCompletionOrder.length; i++) {\n                    const nextStepId = remainingStepCompletionOrder[i];\n                    if (!nextStepId) {\n                        // Strange - skip this empty index\n                        continue;\n                    }\n                    const handled = (_a = unhandledFoundStepsToReport\n                        .get(nextStepId)) === null || _a === void 0 ? void 0 : _a.handle();\n                    if (handled) {\n                        remainingStepCompletionOrder.splice(i, 1);\n                        unhandledFoundStepsToReport.delete(nextStepId);\n                        return void reportNextTick();\n                    }\n                }\n                // If we've handled no steps in this \"tick,\" roll up everything we've\n                // found and report it.\n                const steps = [...foundStepsToReport.values()];\n                foundStepsToReport.clear();\n                unhandledFoundStepsToReport.clear();\n                return void this.state.setCheckpoint({\n                    type: \"steps-found\",\n                    steps: steps,\n                });\n            });\n        };\n        /**\n         * A helper used to push a step to the list of steps to report.\n         */\n        const pushStepToReport = (step) => {\n            foundStepsToReport.set(step.id, step);\n            unhandledFoundStepsToReport.set(step.hashedId, step);\n            reportNextTick();\n        };\n        const stepHandler = async ({ args, matchOp, opts, }) => {\n            var _a, _b, _c, _d;\n            await beforeExecHooksPromise;\n            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);\n            const opId = matchOp(stepOptions, ...args.slice(1));\n            if (this.state.executingStep) {\n                /**\n                 * If a step is found after asynchronous actions during another step's\n                 * execution, everything is fine. The problem here is if we've found\n                 * that a step nested inside another a step, which is something we don't\n                 * support at the time of writing.\n                 *\n                 * In this case, we could use something like Async Hooks to understand\n                 * how the step is being triggered, though this isn't available in all\n                 * environments.\n                 *\n                 * Therefore, we'll only show a warning here to indicate that this is\n                 * potentially an issue.\n                 */\n                console.warn((0, errors_js_1.prettyError)({\n                    whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${(_a = opId.displayName) !== null && _a !== void 0 ? _a : opId.id}\\``,\n                    consequences: \"Nesting `step.*` tooling is not supported.\",\n                    type: \"warn\",\n                    reassurance: \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n                    stack: true,\n                    toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                    code: errors_js_1.ErrCode.NESTING_STEPS,\n                }));\n            }\n            if (this.state.steps.has(opId.id)) {\n                const originalId = opId.id;\n                maybeWarnOfParallelIndexing(originalId);\n                const expectedNextIndex = (_b = expectedNextStepIndexes.get(originalId)) !== null && _b !== void 0 ? _b : 1;\n                for (let i = expectedNextIndex;; i++) {\n                    const newId = originalId + InngestStepTools_js_1.STEP_INDEXING_SUFFIX + i;\n                    if (!this.state.steps.has(newId)) {\n                        expectedNextStepIndexes.set(originalId, i + 1);\n                        opId.id = newId;\n                        break;\n                    }\n                }\n            }\n            const { promise, resolve, reject } = (0, promises_js_1.createDeferredPromise)();\n            const hashedId = exports._internals.hashId(opId.id);\n            const stepState = this.state.stepState[hashedId];\n            let isFulfilled = false;\n            if (stepState) {\n                stepState.seen = true;\n                this.state.remainingStepsToBeSeen.delete(hashedId);\n                if (typeof stepState.input === \"undefined\") {\n                    isFulfilled = true;\n                }\n            }\n            let extraOpts;\n            let fnArgs = [...args];\n            if (typeof (stepState === null || stepState === void 0 ? void 0 : stepState.input) !== \"undefined\" &&\n                Array.isArray(stepState.input)) {\n                switch (opId.op) {\n                    // `step.run()` has its function input affected\n                    case types_js_1.StepOpCode.StepPlanned: {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        fnArgs = [...args.slice(0, 2), ...stepState.input];\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        extraOpts = { input: [...stepState.input] };\n                        break;\n                    }\n                    // `step.ai.infer()` has its body affected\n                    case types_js_1.StepOpCode.AiGateway: {\n                        extraOpts = {\n                            body: Object.assign(Object.assign({}, (typeof ((_c = opId.opts) === null || _c === void 0 ? void 0 : _c.body) === \"object\"\n                                ? Object.assign({}, opId.opts.body) : {})), stepState.input[0]),\n                        };\n                        break;\n                    }\n                }\n            }\n            const step = Object.assign(Object.assign({}, opId), { opts: Object.assign(Object.assign({}, opId.opts), extraOpts), rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n                hashedId, input: stepState === null || stepState === void 0 ? void 0 : stepState.input, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                fn: (opts === null || opts === void 0 ? void 0 : opts.fn) ? () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...fnArgs); } : undefined, promise, fulfilled: isFulfilled, hasStepState: Boolean(stepState), displayName: (_d = opId.displayName) !== null && _d !== void 0 ? _d : opId.id, handled: false, handle: () => {\n                    if (step.handled) {\n                        return false;\n                    }\n                    step.handled = true;\n                    if (isFulfilled && stepState) {\n                        stepState.fulfilled = true;\n                        // For some execution scenarios such as testing, `data`, `error`,\n                        // and `input` may be `Promises`. This could also be the case for\n                        // future middleware applications. For this reason, we'll make sure\n                        // the values are fully resolved before continuing.\n                        void Promise.all([\n                            stepState.data,\n                            stepState.error,\n                            stepState.input,\n                        ]).then(() => {\n                            if (typeof stepState.data !== \"undefined\") {\n                                resolve(stepState.data);\n                            }\n                            else {\n                                this.state.recentlyRejectedStepError = new StepError_js_1.StepError(opId.id, stepState.error);\n                                reject(this.state.recentlyRejectedStepError);\n                            }\n                        });\n                    }\n                    return true;\n                } });\n            this.state.steps.set(opId.id, step);\n            this.state.hasSteps = true;\n            pushStepToReport(step);\n            /**\n             * If this is the last piece of state we had, we've now finished\n             * memoizing.\n             */\n            if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n                await (beforeExecHooksPromise = (async () => {\n                    var _a, _b, _c, _d;\n                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n                    await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n                })());\n            }\n            return promise;\n        };\n        return (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) {\n            return this.options.fn[\"fn\"];\n        }\n        if (!this.options.fn[\"onFailureFn\"]) {\n            /**\n             * Somehow, we've ended up detecting that this is a failure handler but\n             * doesn't have an `onFailure` function. This should never happen.\n             */\n            throw new Error(\"Cannot find function `onFailure` handler\");\n        }\n        return this.options.fn[\"onFailureFn\"];\n    }\n    initializeTimer(state) {\n        if (!this.options.requestedRunStep) {\n            return;\n        }\n        this.timeout = (0, promises_js_1.createTimeoutPromise)(this.timeoutDuration);\n        void this.timeout.then(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n            state.setCheckpoint({\n                type: \"step-not-found\",\n                step: {\n                    id: this.options.requestedRunStep,\n                    op: types_js_1.StepOpCode.StepNotFound,\n                },\n            });\n        });\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs,\n        }, {\n            transformInput: (prev, output) => {\n                return {\n                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i) => {\n                        var _a;\n                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));\n                    }),\n                    reqArgs: prev.reqArgs,\n                };\n            },\n            transformOutput: (prev, output) => {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    step: prev.step,\n                };\n            },\n        });\n        return hooks;\n    }\n}\nconst hashId = (id) => {\n    return (0, hash_js_1.sha1)().update(id).digest(\"hex\");\n};\nconst hashOp = (op) => {\n    return Object.assign(Object.assign({}, op), { id: hashId(op.id) });\n};\n/**\n * Exported for testing.\n */\nexports._internals = { hashOp, hashId };\n//# sourceMappingURL=v1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92MS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZ0NBQWdDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxzRkFBb0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMseURBQVM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMscUZBQTRCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsaUVBQWtCO0FBQy9DLCtCQUErQixtQkFBTyxDQUFDLDZGQUF5QjtBQUNoRSw4QkFBOEIsbUJBQU8sQ0FBQywyRkFBd0I7QUFDOUQsK0JBQStCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ2hFLDZCQUE2QixtQkFBTyxDQUFDLHlGQUF1QjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDaEQsOEJBQThCLG1CQUFPLENBQUMsb0dBQXVCO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLDBFQUFVO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDBGQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHNDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHlDQUF5QztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1QkFBdUI7QUFDM0UsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QjtBQUM3RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixpQkFBaUIsNEJBQTRCO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGlCQUFpQiw4QkFBOEI7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw4R0FBOEcsTUFBTSxrREFBa0Q7QUFDeE47QUFDQSxhQUFhO0FBQ2IsK1FBQStRO0FBQy9RLGlEQUFpRCxXQUFXLG9DQUFvQyxnQkFBZ0IsdUNBQXVDLDhHQUE4RyxpQkFBaUIsR0FBRztBQUN6UixTQUFTO0FBQ1Q7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlEQUFpRCxpQkFBaUIsTUFBTTtBQUN4RSxTQUFTO0FBQ1Q7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0EsdUJBQXVCO0FBQ3ZCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1QyxpQ0FBaUM7QUFDeEUsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsY0FBYyxnQ0FBZ0M7QUFDOUQ7QUFDQTtBQUNBLHdDQUF3QyxvQ0FBb0MsUUFBUSxJQUFJLE1BQU07QUFDOUYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0IsTUFBTTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBLGtEQUFrRCxZQUFZLDJEQUEyRDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUtBQXVLLFlBQVk7QUFDbkw7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHlDQUF5QztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzQkFBc0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEYsaUVBQWlFO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkJBQTJCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRSxrREFBa0Qsc0JBQXNCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsV0FBVyxvQ0FBb0M7QUFDdEc7QUFDQTtBQUNBLG9GQUFvRixRQUFRLHVGQUF1RjtBQUNuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUyxtQkFBbUI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L2NvbXBvbmVudHMvZXhlY3V0aW9uL3YxLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXN5bmNWYWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNWYWx1ZXMpIHx8IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufTtcbnZhciBfX2F3YWl0ID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0KSB8fCBmdW5jdGlvbiAodikgeyByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTsgfVxudmFyIF9fYXN5bmNHZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fYXN5bmNHZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XG4gICAgcmV0dXJuIGkgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgQXN5bmNJdGVyYXRvciA9PT0gXCJmdW5jdGlvblwiID8gQXN5bmNJdGVyYXRvciA6IE9iamVjdCkucHJvdG90eXBlKSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiLCBhd2FpdFJldHVybiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAoZ1tuXSkgeyBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyBpZiAoZikgaVtuXSA9IGYoaVtuXSk7IH0gfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLl9pbnRlcm5hbHMgPSBleHBvcnRzLmNyZWF0ZVYxSW5uZ2VzdEV4ZWN1dGlvbiA9IHZvaWQgMDtcbmNvbnN0IGFwaV8xID0gcmVxdWlyZShcIkBvcGVudGVsZW1ldHJ5L2FwaVwiKTtcbmNvbnN0IGhhc2hfanNfMSA9IHJlcXVpcmUoXCJoYXNoLmpzXCIpO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3QgY29uc3RzX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9jb25zdHMuanNcIik7XG5jb25zdCBlcnJvcnNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL2Vycm9ycy5qc1wiKTtcbmNvbnN0IGZ1bmN0aW9uc19qc18xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvZnVuY3Rpb25zLmpzXCIpO1xuY29uc3QgcHJvbWlzZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VzLmpzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi90eXBlcy5qc1wiKTtcbmNvbnN0IHZlcnNpb25fanNfMSA9IHJlcXVpcmUoXCIuLi8uLi92ZXJzaW9uLmpzXCIpO1xuY29uc3QgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMSA9IHJlcXVpcmUoXCIuLi9Jbm5nZXN0TWlkZGxld2FyZS5qc1wiKTtcbmNvbnN0IElubmdlc3RTdGVwVG9vbHNfanNfMSA9IHJlcXVpcmUoXCIuLi9Jbm5nZXN0U3RlcFRvb2xzLmpzXCIpO1xuY29uc3QgTm9uUmV0cmlhYmxlRXJyb3JfanNfMSA9IHJlcXVpcmUoXCIuLi9Ob25SZXRyaWFibGVFcnJvci5qc1wiKTtcbmNvbnN0IFJldHJ5QWZ0ZXJFcnJvcl9qc18xID0gcmVxdWlyZShcIi4uL1JldHJ5QWZ0ZXJFcnJvci5qc1wiKTtcbmNvbnN0IFN0ZXBFcnJvcl9qc18xID0gcmVxdWlyZShcIi4uL1N0ZXBFcnJvci5qc1wiKTtcbmNvbnN0IElubmdlc3RFeGVjdXRpb25fanNfMSA9IHJlcXVpcmUoXCIuL0lubmdlc3RFeGVjdXRpb24uanNcIik7XG5jb25zdCBhbHNfanNfMSA9IHJlcXVpcmUoXCIuL2Fscy5qc1wiKTtcbmNvbnN0IGFjY2Vzc19qc18xID0gcmVxdWlyZShcIi4vb3RlbC9hY2Nlc3MuanNcIik7XG5jb25zdCBjcmVhdGVWMUlubmdlc3RFeGVjdXRpb24gPSAob3B0aW9ucykgPT4ge1xuICAgIHJldHVybiBuZXcgVjFJbm5nZXN0RXhlY3V0aW9uKG9wdGlvbnMpO1xufTtcbmV4cG9ydHMuY3JlYXRlVjFJbm5nZXN0RXhlY3V0aW9uID0gY3JlYXRlVjFJbm5nZXN0RXhlY3V0aW9uO1xuY2xhc3MgVjFJbm5nZXN0RXhlY3V0aW9uIGV4dGVuZHMgSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLklubmdlc3RFeGVjdXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgICAgIHRoaXMudGltZW91dER1cmF0aW9uID0gMTAwMCAqIDEwO1xuICAgICAgICB0aGlzLnVzZXJGblRvUnVuID0gdGhpcy5nZXRVc2VyRm5Ub1J1bigpO1xuICAgICAgICB0aGlzLnN0YXRlID0gdGhpcy5jcmVhdGVFeGVjdXRpb25TdGF0ZSgpO1xuICAgICAgICB0aGlzLmZuQXJnID0gdGhpcy5jcmVhdGVGbkFyZygpO1xuICAgICAgICB0aGlzLmNoZWNrcG9pbnRIYW5kbGVycyA9IHRoaXMuY3JlYXRlQ2hlY2twb2ludEhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVRpbWVyKHRoaXMuc3RhdGUpO1xuICAgICAgICB0aGlzLmRlYnVnKFwiY3JlYXRlZCBuZXcgVjEgZXhlY3V0aW9uIGZvciBydW47XCIsIHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwXG4gICAgICAgICAgICA/IGB3YW50aW5nIHRvIHJ1biBzdGVwIFwiJHt0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcH1cImBcbiAgICAgICAgICAgIDogXCJkaXNjb3ZlcmluZyBzdGVwc1wiKTtcbiAgICAgICAgdGhpcy5kZWJ1ZyhcImV4aXN0aW5nIHN0YXRlIGtleXM6XCIsIE9iamVjdC5rZXlzKHRoaXMuc3RhdGUuc3RlcFN0YXRlKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElkZW1wb3RlbnRseSBzdGFydCB0aGUgZXhlY3V0aW9uIG9mIHRoZSB1c2VyJ3MgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5leGVjdXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuZGVidWcoXCJzdGFydGluZyBWMSBleGVjdXRpb25cIik7XG4gICAgICAgICAgICBjb25zdCB0cmFjZXIgPSBhcGlfMS50cmFjZS5nZXRUcmFjZXIoXCJpbm5nZXN0XCIsIHZlcnNpb25fanNfMS52ZXJzaW9uKTtcbiAgICAgICAgICAgIHRoaXMuZXhlY3V0aW9uID0gKDAsIGFsc19qc18xLmdldEFzeW5jTG9jYWxTdG9yYWdlKSgpLnRoZW4oKGFscykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHMucnVuKHsgYXBwOiB0aGlzLm9wdGlvbnMuY2xpZW50LCBjdHg6IHRoaXMuZm5BcmcgfSwgYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihcImlubmdlc3QuZXhlY3V0aW9uXCIsIChzcGFuKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBhY2Nlc3NfanNfMS5jbGllbnRQcm9jZXNzb3JNYXAuZ2V0KHRoaXMub3B0aW9ucy5jbGllbnQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVjbGFyZVN0YXJ0aW5nU3Bhbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BhbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydW5JZDogdGhpcy5vcHRpb25zLnJ1bklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlcGFyZW50OiB0aGlzLm9wdGlvbnMuaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLlRyYWNlUGFyZW50XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZXN0YXRlOiB0aGlzLm9wdGlvbnMuaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLlRyYWNlU3RhdGVdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fc3RhcnQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwicmVzdWx0OlwiLCByZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5maW5hbGx5KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0aW9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgZXhlY3V0aW9uIG9mIHRoZSB1c2VyJ3MgZnVuY3Rpb24gYW5kIHRoZSBjb3JlIGxvb3AuXG4gICAgICovXG4gICAgYXN5bmMgX3N0YXJ0KCkge1xuICAgICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWxsQ2hlY2twb2ludEhhbmRsZXIgPSB0aGlzLmdldENoZWNrcG9pbnRIYW5kbGVyKFwiXCIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5ob29rcyA9IGF3YWl0IHRoaXMuaW5pdGlhbGl6ZU1pZGRsZXdhcmUoKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc3RhcnRFeGVjdXRpb24oKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXModGhpcy5zdGF0ZS5sb29wKSwgX2g7IF9oID0gYXdhaXQgX2cubmV4dCgpLCBfYSA9IF9oLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jID0gX2gudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrcG9pbnQgPSBfYztcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWxsQ2hlY2twb2ludEhhbmRsZXIoY2hlY2twb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLmdldENoZWNrcG9pbnRIYW5kbGVyKGNoZWNrcG9pbnQudHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGhhbmRsZXIoY2hlY2twb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gX2cucmV0dXJuKSkgYXdhaXQgX2IuY2FsbChfZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGVycm9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdm9pZCB0aGlzLnN0YXRlLmxvb3AucmV0dXJuKCk7XG4gICAgICAgICAgICBhd2FpdCAoKF9lID0gKF9kID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmJlZm9yZVJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuY2FsbChfZCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBoZXJlLCB0aGUgZ2VuZXJhdG9yIHNvbWVob3cgZmluaXNoZWQgd2l0aG91dCByZXR1cm5pbmcgYSB2YWx1ZS5cbiAgICAgICAgICogVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29yZSBsb29wIGZpbmlzaGVkIHdpdGhvdXQgcmV0dXJuaW5nIGEgdmFsdWVcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBoYW5kbGVyIGZvciBldmVyeSBjaGVja3BvaW50IHR5cGUsIGRlZmluaW5nIHdoYXQgdG8gZG8gd2hlbiB3ZVxuICAgICAqIHJlYWNoIHRoYXQgY2hlY2twb2ludCBpbiB0aGUgY29yZSBsb29wLlxuICAgICAqL1xuICAgIGNyZWF0ZUNoZWNrcG9pbnRIYW5kbGVycygpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUnVuIGZvciBhbGwgY2hlY2twb2ludHMuIEJlc3QgdXNlZCBmb3IgbG9nZ2luZyBvciBjb21tb24gYWN0aW9ucy5cbiAgICAgICAgICAgICAqIFVzZSBvdGhlciBoYW5kbGVycyB0byByZXR1cm4gdmFsdWVzIGFuZCBpbnRlcnJ1cHQgdGhlIGNvcmUgbG9vcC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJcIjogKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlYnVnKFwiY2hlY2twb2ludDpcIiwgY2hlY2twb2ludCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdXNlcidzIGZ1bmN0aW9uIGhhcyBjb21wbGV0ZWQgYW5kIHJldHVybmVkIGEgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZnVuY3Rpb24tcmVzb2x2ZWRcIjogYXN5bmMgKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBkYXRhOiBjaGVja3BvaW50LmRhdGEgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgdXNlcidzIGZ1bmN0aW9uIGhhcyB0aHJvd24gYW4gZXJyb3IuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwiZnVuY3Rpb24tcmVqZWN0ZWRcIjogYXN5bmMgKGNoZWNrcG9pbnQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoeyBlcnJvcjogY2hlY2twb2ludC5lcnJvciB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlJ3ZlIGZvdW5kIG9uZSBvciBtb3JlIHN0ZXBzLiBIZXJlIHdlIG1heSB3YW50IHRvIHJ1biBhIHN0ZXAgb3IgcmVwb3J0XG4gICAgICAgICAgICAgKiB0aGVtIGJhY2sgdG8gSW5uZ2VzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJzdGVwcy1mb3VuZFwiOiBhc3luYyAoeyBzdGVwcyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RlcFJlc3VsdCA9IGF3YWl0IHRoaXMudHJ5RXhlY3V0ZVN0ZXAoc3RlcHMpO1xuICAgICAgICAgICAgICAgIGlmIChzdGVwUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVJlc3VsdCA9IGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHN0ZXBSZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVHJhbnNmb3JtaW5nIG91dHB1dCB3aWxsIGFsd2F5cyByZXR1cm4gZWl0aGVyIGZ1bmN0aW9uIHJlamVjdGlvbiBvclxuICAgICAgICAgICAgICAgICAgICAgKiByZXNvbHV0aW9uLiBJbiBtb3N0IGNhc2VzLCB0aGlzIGNhbiBiZSBpbW1lZGlhdGVseSByZXR1cm5lZCwgYnV0IGluXG4gICAgICAgICAgICAgICAgICAgICAqIHRoaXMgcGFydGljdWxhciBjYXNlIHdlIHdhbnQgdG8gaGFuZGxlIGl0IGRpZmZlcmVudGx5LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYW5zZm9ybVJlc3VsdC50eXBlID09PSBcImZ1bmN0aW9uLXJlc29sdmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdGVwLXJhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN0eDogdHJhbnNmb3JtUmVzdWx0LmN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHM6IHRyYW5zZm9ybVJlc3VsdC5vcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcDogZXhwb3J0cy5faW50ZXJuYWxzLmhhc2hPcChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXBSZXN1bHQpLCB7IGRhdGE6IHRyYW5zZm9ybVJlc3VsdC5kYXRhIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodHJhbnNmb3JtUmVzdWx0LnR5cGUgPT09IFwiZnVuY3Rpb24tcmVqZWN0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtcmFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4OiB0cmFuc2Zvcm1SZXN1bHQuY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wczogdHJhbnNmb3JtUmVzdWx0Lm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiBleHBvcnRzLl9pbnRlcm5hbHMuaGFzaE9wKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcFJlc3VsdCksIHsgZXJyb3I6IHRyYW5zZm9ybVJlc3VsdC5lcnJvciB9KSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlhYmxlOiB0cmFuc2Zvcm1SZXN1bHQucmV0cmlhYmxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtUmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTdGVwcyA9IGF3YWl0IHRoaXMuZmlsdGVyTmV3U3RlcHMoQXJyYXkuZnJvbSh0aGlzLnN0YXRlLnN0ZXBzLnZhbHVlcygpKSk7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1N0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXBzLWZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RlcHM6IG5ld1N0ZXBzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoaWxlIHRyeWluZyB0byBmaW5kIGEgc3RlcCB0aGF0IElubmdlc3QgaGFzIHRvbGQgdXMgdG8gcnVuLCB3ZSd2ZVxuICAgICAgICAgICAgICogdGltZWQgb3V0IG9yIGhhdmUgb3RoZXJ3aXNlIGRlY2lkZWQgdGhhdCBpdCBkb2Vzbid0IGV4aXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInN0ZXAtbm90LWZvdW5kXCI6ICh7IHN0ZXAgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwic3RlcC1ub3QtZm91bmRcIiwgY3R4OiB0aGlzLmZuQXJnLCBvcHM6IHRoaXMub3BzLCBzdGVwIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRDaGVja3BvaW50SGFuZGxlcih0eXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNoZWNrcG9pbnRIYW5kbGVyc1t0eXBlXTtcbiAgICB9XG4gICAgYXN5bmMgdHJ5RXhlY3V0ZVN0ZXAoc3RlcHMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBoYXNoZWRTdGVwSWRUb1J1biA9IHRoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwIHx8IHRoaXMuZ2V0RWFybHlFeGVjUnVuU3RlcChzdGVwcyk7XG4gICAgICAgIGlmICghaGFzaGVkU3RlcElkVG9SdW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGVwID0gc3RlcHMuZmluZCgoc3RlcCkgPT4gc3RlcC5oYXNoZWRJZCA9PT0gaGFzaGVkU3RlcElkVG9SdW4gJiYgc3RlcC5mbik7XG4gICAgICAgIGlmIChzdGVwKSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5leGVjdXRlU3RlcChzdGVwKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRW5zdXJlIHdlIHJlc2V0IHRoZSB0aW1lb3V0IGlmIHdlIGhhdmUgYSByZXF1ZXN0ZWQgcnVuIHN0ZXAgYnV0IGNvdWxkbid0XG4gICAgICAgICAqIGZpbmQgaXQsIGJ1dCBhbHNvIHRoYXQgd2UgZG9uJ3QgcmVzZXQgaWYgd2UgZm91bmQgYW5kIGV4ZWN1dGVkIGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgdm9pZCAoKF9hID0gdGhpcy50aW1lb3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzZXQoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdpdmVuIGEgbGlzdCBvZiBvdXRnb2luZyBvcHMsIGRlY2lkZSBpZiB3ZSBjYW4gZXhlY3V0ZSBhbiBvcCBlYXJseSBhbmRcbiAgICAgKiByZXR1cm4gdGhlIElEIG9mIHRoZSBzdGVwIHRvIGV4ZWN1dGUgaWYgd2UgY2FuLlxuICAgICAqL1xuICAgIGdldEVhcmx5RXhlY1J1blN0ZXAoc3RlcHMpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIG1heSBoYXZlIGJlZW4gZGlzYWJsZWQgZHVlIHRvIHBhcmFsbGVsaXNtLCBpbiB3aGljaCBjYXNlIHdlIGNhbid0XG4gICAgICAgICAqIGltbWVkaWF0ZWx5IGV4ZWN1dGUgdW5sZXNzIGV4cGxpY2l0bHkgcmVxdWVzdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlSW1tZWRpYXRlRXhlY3V0aW9uKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB1bmZ1bGZpbGxlZFN0ZXBzID0gc3RlcHMuZmlsdGVyKChzdGVwKSA9PiAhc3RlcC5mdWxmaWxsZWQpO1xuICAgICAgICBpZiAodW5mdWxmaWxsZWRTdGVwcy5sZW5ndGggIT09IDEpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9wID0gdW5mdWxmaWxsZWRTdGVwc1swXTtcbiAgICAgICAgaWYgKG9wICYmXG4gICAgICAgICAgICBvcC5vcCA9PT0gdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBQbGFubmVkXG4gICAgICAgIC8vIFRPRE8gV2UgbXVzdCBpbmRpdmlkdWFsbHkgY2hlY2sgcHJvcGVydGllcyBoZXJlIHRoYXQgd2UgZG8gbm90IHdhbnQgdG9cbiAgICAgICAgLy8gZXhlY3V0ZSBvbiwgc3VjaCBhcyByZXRyeSBjb3VudHMuIE5vdGhpbmcgZXhpc3RzIGhlcmUgdGhhdCBmYWxscyBpbiB0b1xuICAgICAgICAvLyB0aGlzIGNhc2UsIGJ1dCBzaG91bGQgYmUgYWNjb3VudGVkIGZvciB3aGVuIHdlIGFkZCB0aGVtLlxuICAgICAgICAvLyAmJiB0eXBlb2Ygb3Aub3B0cyA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICApIHtcbiAgICAgICAgICAgIHJldHVybiBvcC5oYXNoZWRJZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBmaWx0ZXJOZXdTdGVwcyhmb3VuZFN0ZXBzKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2F0aGVyIGFueSBzdGVwcyB0aGF0IGFyZW4ndCBtZW1vaXplZCBhbmQgcmVwb3J0IHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBuZXdTdGVwcyA9IGZvdW5kU3RlcHMuZmlsdGVyKChzdGVwKSA9PiAhc3RlcC5mdWxmaWxsZWQpO1xuICAgICAgICBpZiAoIW5ld1N0ZXBzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXYXJuIGlmIHdlJ3ZlIGZvdW5kIG5ldyBzdGVwcyBidXQgaGF2ZW4ndCB5ZXQgc2VlbiBhbGwgcHJldmlvdXNcbiAgICAgICAgICogc3RlcHMuIFRoaXMgbWF5IGluZGljYXRlIHRoYXQgc3RlcCBwcmVzZW5jZSBpc24ndCBkZXRlcm1pbmF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBrbm93blN0ZXBzID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBzdGVwIG9mIGZvdW5kU3RlcHMpIHtcbiAgICAgICAgICAgIGlmIChzdGVwLmZ1bGZpbGxlZCkge1xuICAgICAgICAgICAgICAgIGtub3duU3RlcHMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3VuZEFsbENvbXBsZXRlZFN0ZXBzID0gdGhpcy5zdGF0ZS5zdGVwc1RvRnVsZmlsbCA9PT0ga25vd25TdGVwcztcbiAgICAgICAgaWYgKCFmb3VuZEFsbENvbXBsZXRlZFN0ZXBzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIFRhZ1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwid2FyblwiLFxuICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCJGdW5jdGlvbiBtYXkgYmUgaW5kZXRlcm1pbmF0ZVwiLFxuICAgICAgICAgICAgICAgIHdoeTogXCJXZSBmb3VuZCBuZXcgc3RlcHMgYmVmb3JlIHNlZWluZyBhbGwgcHJldmlvdXMgc3RlcHMsIHdoaWNoIG1heSBpbmRpY2F0ZSB0aGF0IHRoZSBmdW5jdGlvbiBpcyBub24tZGV0ZXJtaW5pc3RpYy5cIixcbiAgICAgICAgICAgICAgICBjb25zZXF1ZW5jZXM6IFwiVGhpcyBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvdXIgYXMgSW5uZ2VzdCBleGVjdXRlcyB5b3VyIGZ1bmN0aW9uLlwiLFxuICAgICAgICAgICAgICAgIHJlYXNzdXJhbmNlOiBcIlRoaXMgaXMgZXhwZWN0ZWQgaWYgYSBmdW5jdGlvbiBpcyB1cGRhdGVkIGluIHRoZSBtaWRkbGUgb2YgYSBydW4sIGJ1dCBtYXkgaW5kaWNhdGUgYSBidWcgaWYgbm90LlwiLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSdyZSBmaW5pc2hpbmcgdXA7IGxldCdzIHRyaWdnZXIgdGhlIGxhc3Qgb2YgdGhlIGhvb2tzLlxuICAgICAgICAgKi9cbiAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICBhd2FpdCAoKF9kID0gKF9jID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpKTtcbiAgICAgICAgYXdhaXQgKChfZiA9IChfZSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5hZnRlckV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpKTtcbiAgICAgICAgY29uc3Qgc3RlcExpc3QgPSBuZXdTdGVwcy5tYXAoKHN0ZXApID0+ICh7XG4gICAgICAgICAgICBkaXNwbGF5TmFtZTogc3RlcC5kaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIG9wOiBzdGVwLm9wLFxuICAgICAgICAgICAgaWQ6IHN0ZXAuaGFzaGVkSWQsXG4gICAgICAgICAgICBuYW1lOiBzdGVwLm5hbWUsXG4gICAgICAgICAgICBvcHRzOiBzdGVwLm9wdHMsXG4gICAgICAgIH0pKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIGFsc28gcnVuIGBvblNlbmRFdmVudGAgbWlkZGxld2FyZSBob29rcyBhZ2FpbnN0IGBzdGVwLmludm9rZSgpYCBzdGVwc1xuICAgICAgICAgKiB0byBlbnN1cmUgdGhhdCB0aGVpciBgZGF0YWAgaXMgdHJhbnNmb3JtZWQgY29ycmVjdGx5LlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtTmV3U3RlcHMoc3RlcExpc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2luZyBtaWRkbGV3YXJlLCB0cmFuc2Zvcm0gYW55IG5ld2x5LWZvdW5kIHN0ZXBzIGJlZm9yZSByZXR1cm5pbmcgdGhlbSB0b1xuICAgICAqIGFuIElubmdlc3QgU2VydmVyLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybU5ld1N0ZXBzKHN0ZXBzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChzdGVwcy5tYXAoYXN5bmMgKHN0ZXApID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgICAgIGlmIChzdGVwLm9wICE9PSB0eXBlc19qc18xLlN0ZXBPcENvZGUuSW52b2tlRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9uU2VuZEV2ZW50SG9va3MgPSBhd2FpdCAoMCwgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5nZXRIb29rU3RhY2spKHRoaXMub3B0aW9ucy5mbltcIm1pZGRsZXdhcmVcIl0sIFwib25TZW5kRXZlbnRcIiwgdW5kZWZpbmVkLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtSW5wdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldiksIG91dHB1dCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PdXRwdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2LnJlc3VsdCksIG91dHB1dCA9PT0gbnVsbCB8fCBvdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG91dHB1dC5yZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yIGVhY2ggZXZlbnQgYmVpbmcgc2VudCwgY3JlYXRlIGEgbmV3IGBvblNlbmRFdmVudGAgaG9vayBzdGFjayB0b1xuICAgICAgICAgICAgICogcHJvY2VzcyBpdC4gV2UgZG8gdGhpcyBhcyBtaWRkbGV3YXJlIGhvb2tzIGFyZSBpbnRlbmRlZCB0byBydW4gb25jZVxuICAgICAgICAgICAgICogZHVyaW5nIGVhY2ggbGlmZWN5Y2xlIChvbkZ1bmN0aW9uUnVuIG9yIG9uU2VuZEV2ZW50KSBhbmQgaGVyZSwgYSBob29rXG4gICAgICAgICAgICAgKiBpcyBydW4gZm9yIGV2ZXJ5IHNpbmdsZSBldmVudC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGlzIGlzIGRvbmUgYmVjYXVzZSBhIGRldmVsb3BlciBjYW4gdXNlIHRoaXMgaG9vayB0byBmaWx0ZXIgb3V0XG4gICAgICAgICAgICAgKiBldmVudHMgZW50aXJlbHk7IGlmIHdlIGJhdGNoIGFsbCBvZiB0aGUgZXZlbnRzIHRvZ2V0aGVyLCB3ZSBjYW4ndFxuICAgICAgICAgICAgICogdGVsbCB3aGljaCBvbmVzIHdlcmUgZmlsdGVyZWQgb3V0IGlmIHdlJ3JlIHByb2Nlc3NpbmcgPjEgaW52b2NhdGlvblxuICAgICAgICAgICAgICogaGVyZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXlsb2FkID0gYXdhaXQgKChfYSA9IG9uU2VuZEV2ZW50SG9va3MudHJhbnNmb3JtSW5wdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9uU2VuZEV2ZW50SG9va3MsIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkczogW1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgoX2MgPSAoX2IgPSBzdGVwLm9wdHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB7fSkpLCB7IG5hbWU6IGNvbnN0c19qc18xLmludGVybmFsRXZlbnRzLkZ1bmN0aW9uSW52b2tlZCB9KSxcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3QgbmV3UGF5bG9hZCA9IElubmdlc3RTdGVwVG9vbHNfanNfMS5pbnZva2VQYXlsb2FkU2NoZW1hLnBhcnNlKChfZSA9IChfZCA9IHRyYW5zZm9ybWVkUGF5bG9hZCA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1lZFBheWxvYWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybWVkUGF5bG9hZC5wYXlsb2FkcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kWzBdKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiB7fSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGVwKSwgeyBvcHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXAub3B0cyksIHsgcGF5bG9hZDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoKF9nID0gKF9mID0gc3RlcC5vcHRzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YucGF5bG9hZCkgIT09IG51bGwgJiYgX2cgIT09IHZvaWQgMCA/IF9nIDoge30pKSwgbmV3UGF5bG9hZCkgfSkgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgZXhlY3V0ZVN0ZXAoeyBpZCwgbmFtZSwgb3B0cywgZm4sIGRpc3BsYXlOYW1lLCB9KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAgIChfYSA9IHRoaXMudGltZW91dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsZWFyKCk7XG4gICAgICAgIGF3YWl0ICgoX2MgPSAoX2IgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpKTtcbiAgICAgICAgYXdhaXQgKChfZSA9IChfZCA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKSk7XG4gICAgICAgIGNvbnN0IG91dGdvaW5nT3AgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcFJ1bixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBvcHRzLFxuICAgICAgICAgICAgZGlzcGxheU5hbWUsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCA9IG91dGdvaW5nT3A7XG4gICAgICAgIGNvbnN0IHN0b3JlID0gYXdhaXQgKDAsIGFsc19qc18xLmdldEFzeW5jQ3R4KSgpO1xuICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgIHN0b3JlLmV4ZWN1dGluZ1N0ZXAgPSB7XG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgbmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVidWcoYGV4ZWN1dGluZyBzdGVwIFwiJHtpZH1cImApO1xuICAgICAgICByZXR1cm4gKCgwLCBwcm9taXNlc19qc18xLnJ1bkFzUHJvbWlzZSkoZm4pXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICAgICAgICAgIC5maW5hbGx5KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoc3RvcmUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc3RvcmUuZXhlY3V0aW5nU3RlcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0Z29pbmdPcCksIHsgZGF0YSB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dGdvaW5nT3ApLCB7IG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcEVycm9yLCBcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgZXJyb3IgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnRzIGV4ZWN1dGlvbiBvZiB0aGUgdXNlcidzIGZ1bmN0aW9uLCBpbmNsdWRpbmcgdHJpZ2dlcmluZyBjaGVja3BvaW50c1xuICAgICAqIGFuZCBtaWRkbGV3YXJlIGhvb2tzIHdoZXJlIGFwcHJvcHJpYXRlLlxuICAgICAqL1xuICAgIGFzeW5jIHN0YXJ0RXhlY3V0aW9uKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNdXRhdGUgaW5wdXQgYXMgbmVjY2Vzc2FyeSBiYXNlZCBvbiBtaWRkbGV3YXJlLlxuICAgICAgICAgKi9cbiAgICAgICAgYXdhaXQgdGhpcy50cmFuc2Zvcm1JbnB1dCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3RhcnQgdGhlIHRpbWVyIHRvIHRpbWUgb3V0IHRoZSBydW4gaWYgbmVlZGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdm9pZCAoKF9hID0gdGhpcy50aW1lb3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnQoKSk7XG4gICAgICAgIGF3YWl0ICgoX2MgPSAoX2IgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYmVmb3JlTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSBoYWQgbm8gc3RhdGUgdG8gYmVnaW4gd2l0aCwgaW1tZWRpYXRlbHkgZW5kIHRoZSBtZW1vaXphdGlvbiBwaGFzZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmFsbFN0YXRlVXNlZCgpKSB7XG4gICAgICAgICAgICBhd2FpdCAoKF9lID0gKF9kID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9nID0gKF9mID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9nLmNhbGwoX2YpKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVHJpZ2dlciB0aGUgdXNlcidzIGZ1bmN0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgKDAsIHByb21pc2VzX2pzXzEucnVuQXNQcm9taXNlKSgoKSA9PiB0aGlzLnVzZXJGblRvUnVuKHRoaXMuZm5BcmcpKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1taXN1c2VkLXByb21pc2VzXG4gICAgICAgICAgICAuZmluYWxseShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYykpO1xuICAgICAgICAgICAgYXdhaXQgKChfZiA9IChfZSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5hZnRlckV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoeyB0eXBlOiBcImZ1bmN0aW9uLXJlc29sdmVkXCIsIGRhdGEgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNldENoZWNrcG9pbnQoeyB0eXBlOiBcImZ1bmN0aW9uLXJlamVjdGVkXCIsIGVycm9yIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIGlucHV0IGJlZm9yZSBydW5uaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybUlucHV0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBpbnB1dE11dGF0aW9ucyA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNmb3JtSW5wdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICAgICAgICBjdHg6IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZm5BcmcpLFxuICAgICAgICAgICAgc3RlcHM6IE9iamVjdC52YWx1ZXModGhpcy5zdGF0ZS5zdGVwU3RhdGUpLFxuICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgIHJlcUFyZ3M6IHRoaXMub3B0aW9ucy5yZXFBcmdzLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmIChpbnB1dE11dGF0aW9ucyA9PT0gbnVsbCB8fCBpbnB1dE11dGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRNdXRhdGlvbnMuY3R4KSB7XG4gICAgICAgICAgICB0aGlzLmZuQXJnID0gaW5wdXRNdXRhdGlvbnMuY3R4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dE11dGF0aW9ucyA9PT0gbnVsbCB8fCBpbnB1dE11dGF0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5wdXRNdXRhdGlvbnMuc3RlcHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RlcFN0YXRlID0gT2JqZWN0LmZyb21FbnRyaWVzKGlucHV0TXV0YXRpb25zLnN0ZXBzLm1hcCgoc3RlcCkgPT4gW3N0ZXAuaWQsIHN0ZXBdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXNpbmcgbWlkZGxld2FyZSwgdHJhbnNmb3JtIG91dHB1dCBiZWZvcmUgcmV0dXJuaW5nLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYW5zZm9ybU91dHB1dChkYXRhT3JFcnJvcikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IE9iamVjdC5hc3NpZ24oe30sIGRhdGFPckVycm9yKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3ZlIGJlZW4gZ2l2ZW4gYW4gZXJyb3IgYW5kIGl0J3Mgb25lIHRoYXQgd2UganVzdCB0aHJldyBmcm9tIGEgc3RlcCxcbiAgICAgICAgICogd2Ugc2hvdWxkIHJldHVybiBhIGBOb25SZXRyaWFibGVFcnJvcmAgdG8gc3RvcCBleGVjdXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHlwZW9mIG91dHB1dC5lcnJvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgb3V0cHV0LmRhdGEgPSAoMCwgZXJyb3JzX2pzXzEuc2VyaWFsaXplRXJyb3IpKG91dHB1dC5lcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNTdGVwRXhlY3V0aW9uID0gQm9vbGVhbih0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXApO1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZE91dHB1dCA9IGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHJhbnNmb3JtT3V0cHV0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKHt9LCBvdXRwdXQpLFxuICAgICAgICAgICAgc3RlcDogdGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHsgZGF0YSwgZXJyb3IgfSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0cHV0KSwgdHJhbnNmb3JtZWRPdXRwdXQgPT09IG51bGwgfHwgdHJhbnNmb3JtZWRPdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybWVkT3V0cHV0LnJlc3VsdCk7XG4gICAgICAgIGlmICghaXNTdGVwRXhlY3V0aW9uKSB7XG4gICAgICAgICAgICBhd2FpdCAoKF9kID0gKF9jID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmZpbmlzaGVkKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYywge1xuICAgICAgICAgICAgICAgIHJlc3VsdDogT2JqZWN0LmFzc2lnbih7fSwgKHR5cGVvZiBlcnJvciAhPT0gXCJ1bmRlZmluZWRcIiA/IHsgZXJyb3IgfSA6IHsgZGF0YSB9KSksXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlcnJvciAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbnN1cmUgd2UgZ2l2ZSBtaWRkbGV3YXJlIHRoZSBjaGFuY2UgdG8gZGVjaWRlIG9uIHJldHJpYWJsZSBiZWhhdmlvdXJcbiAgICAgICAgICAgICAqIGJ5IGxvb2tpbmcgYXQgdGhlIGVycm9yIHJldHVybmVkIGZyb20gb3V0cHV0IHRyYW5zZm9ybWF0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgcmV0cmlhYmxlID0gIShlcnJvciBpbnN0YW5jZW9mIE5vblJldHJpYWJsZUVycm9yX2pzXzEuTm9uUmV0cmlhYmxlRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBTdGVwRXJyb3JfanNfMS5TdGVwRXJyb3IpO1xuICAgICAgICAgICAgaWYgKHJldHJpYWJsZSAmJiBlcnJvciBpbnN0YW5jZW9mIFJldHJ5QWZ0ZXJFcnJvcl9qc18xLlJldHJ5QWZ0ZXJFcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHJpYWJsZSA9IGVycm9yLnJldHJ5QWZ0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkRXJyb3IgPSAoMCwgZXJyb3JzX2pzXzEubWluaWZ5UHJldHR5RXJyb3IpKCgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikoZXJyb3IpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvbi1yZWplY3RlZFwiLFxuICAgICAgICAgICAgICAgIGN0eDogdGhpcy5mbkFyZyxcbiAgICAgICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgICAgIGVycm9yOiBzZXJpYWxpemVkRXJyb3IsXG4gICAgICAgICAgICAgICAgcmV0cmlhYmxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvbi1yZXNvbHZlZFwiLFxuICAgICAgICAgICAgY3R4OiB0aGlzLmZuQXJnLFxuICAgICAgICAgICAgb3BzOiB0aGlzLm9wcyxcbiAgICAgICAgICAgIGRhdGE6ICgwLCBmdW5jdGlvbnNfanNfMS51bmRlZmluZWRUb051bGwpKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVFeGVjdXRpb25TdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgZCA9ICgwLCBwcm9taXNlc19qc18xLmNyZWF0ZURlZmVycmVkUHJvbWlzZVdpdGhTdGFjaykoKTtcbiAgICAgICAgbGV0IGNoZWNrcG9pbnRSZXNvbHZlID0gZC5kZWZlcnJlZC5yZXNvbHZlO1xuICAgICAgICBjb25zdCBjaGVja3BvaW50UmVzdWx0cyA9IGQucmVzdWx0cztcbiAgICAgICAgY29uc3QgbG9vcCA9IChmdW5jdGlvbiAoY2xlYW5VcCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3IodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSAoeWllbGQgX19hd2FpdChjaGVja3BvaW50UmVzdWx0cy5uZXh0KCkpKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFuVXAgPT09IG51bGwgfHwgY2xlYW5VcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xlYW5VcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSgoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnRpbWVvdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGVhcigpO1xuICAgICAgICAgICAgdm9pZCBjaGVja3BvaW50UmVzdWx0cy5yZXR1cm4oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN0ZXBzVG9GdWxmaWxsID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSkubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgICAgIHN0ZXBTdGF0ZTogdGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSxcbiAgICAgICAgICAgIHN0ZXBzVG9GdWxmaWxsLFxuICAgICAgICAgICAgc3RlcHM6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGxvb3AsXG4gICAgICAgICAgICBoYXNTdGVwczogQm9vbGVhbihzdGVwc1RvRnVsZmlsbCksXG4gICAgICAgICAgICBzdGVwQ29tcGxldGlvbk9yZGVyOiBbLi4udGhpcy5vcHRpb25zLnN0ZXBDb21wbGV0aW9uT3JkZXJdLFxuICAgICAgICAgICAgcmVtYWluaW5nU3RlcHNUb0JlU2VlbjogbmV3IFNldCh0aGlzLm9wdGlvbnMuc3RlcENvbXBsZXRpb25PcmRlciksXG4gICAgICAgICAgICBzZXRDaGVja3BvaW50OiAoY2hlY2twb2ludCkgPT4ge1xuICAgICAgICAgICAgICAgICh7IHJlc29sdmU6IGNoZWNrcG9pbnRSZXNvbHZlIH0gPSBjaGVja3BvaW50UmVzb2x2ZShjaGVja3BvaW50KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWxsU3RhdGVVc2VkOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUucmVtYWluaW5nU3RlcHNUb0JlU2Vlbi5zaXplID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH1cbiAgICBnZXQgb3BzKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuc3RhdGUuc3RlcHMpO1xuICAgIH1cbiAgICBjcmVhdGVGbkFyZygpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBjb25zdCBzdGVwID0gdGhpcy5jcmVhdGVTdGVwVG9vbHMoKTtcbiAgICAgICAgbGV0IGZuQXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMuZGF0YSksIHsgc3RlcCB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZSB1c2Ugb2YgdGhlIGBvbkZhaWx1cmVgIG9wdGlvbiBieSBkZXNlcmlhbGl6aW5nIHRoZSBlcnJvci5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNGYWlsdXJlSGFuZGxlcikge1xuICAgICAgICAgICAgY29uc3QgZXZlbnREYXRhID0gem9kXzEuelxuICAgICAgICAgICAgICAgIC5vYmplY3QoeyBlcnJvcjogdHlwZXNfanNfMS5qc29uRXJyb3JTY2hlbWEgfSlcbiAgICAgICAgICAgICAgICAucGFyc2UoKF9hID0gZm5BcmcuZXZlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhKTtcbiAgICAgICAgICAgIGZuQXJnID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBmbkFyZyksIHsgZXJyb3I6ICgwLCBlcnJvcnNfanNfMS5kZXNlcmlhbGl6ZUVycm9yKShldmVudERhdGEuZXJyb3IpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoX2QgPSAoX2MgPSAoX2IgPSB0aGlzLm9wdGlvbnMpLnRyYW5zZm9ybUN0eCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGZuQXJnKSkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZm5Bcmc7XG4gICAgfVxuICAgIGNyZWF0ZVN0ZXBUb29scygpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBzdGVwcyB0aGF0IGhhdmUgYmVlbiBmb3VuZCBhbmQgYXJlIGJlaW5nIHJvbGxlZCB1cCBiZWZvcmUgYmVpbmdcbiAgICAgICAgICogcmVwb3J0ZWQgdG8gdGhlIGNvcmUgbG9vcC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGZvdW5kU3RlcHNUb1JlcG9ydCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHRoZSBzdWJzZXQgb2YgZm91bmQgc3RlcHMgdG8gcmVwb3J0IHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAgICAgICogaGFuZGxlZC4gVXNlZCBmb3IgZmFzdCBhY2Nlc3MgdG8gc3RlcHMgdGhhdCBuZWVkIHRvIGJlIGhhbmRsZWQgaW4gb3JkZXIuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiB0aGUgbGF0ZXN0IHNlcXVlbnRpYWwgc3RlcCBpbmRleGVzIGZvdW5kIGZvciBlYWNoIHN0ZXAgSUQuIFVzZWRcbiAgICAgICAgICogdG8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgaW5kZXggc3RlcHMgaW4gcGFyYWxsZWwuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5vdGUgdGhhdCB0aGVzZSBtdXN0IGJlIHNlcXVlbnRpYWw7IGlmIHdlJ3ZlIHNlZW4gb3IgYXNzaWduZWQgYGE6MWAsXG4gICAgICAgICAqIGBhOjJgIGFuZCBgYTo0YCwgdGhlIGxhdGVzdCBzZXF1ZW50aWFsIHN0ZXAgaW5kZXggaXMgYDJgLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZXhwZWN0ZWROZXh0U3RlcEluZGV4ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvcmRlcmVkIGxpc3Qgb2Ygc3RlcCBJRHMgdGhhdCBoYXZlIHlldCB0byBiZSBoYW5kbGVkIGluIHRoaXNcbiAgICAgICAgICogZXhlY3V0aW9uLiBVc2VkIHRvIGVuc3VyZSB0aGF0IHdlIGhhbmRsZSBzdGVwcyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlXG4gICAgICAgICAqIGZvdW5kIGFuZCBiYXNlZCBvbiB0aGUgYHN0ZXBDb21wbGV0aW9uT3JkZXJgIGluIHRoaXMgZXhlY3V0aW9uJ3Mgc3RhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZW1haW5pbmdTdGVwQ29tcGxldGlvbk9yZGVyID0gdGhpcy5zdGF0ZS5zdGVwQ29tcGxldGlvbk9yZGVyLnNsaWNlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHByb21pc2UgdGhhdCdzIHVzZWQgdG8gZW5zdXJlIHRoYXQgc3RlcCByZXBvcnRpbmcgY2Fubm90IGJlIHJ1biBtb3JlIHRoYW5cbiAgICAgICAgICogb25jZSBpbiBhIGdpdmVuIGFzeW5jaHJvbm91cyB0aW1lIHNwYW4uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgZm91bmRTdGVwc1JlcG9ydFByb21pc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHByb21pc2UgdGhhdCdzIHVzZWQgdG8gcmVwcmVzZW50IG1pZGRsZXdhcmUgaG9va3MgcnVubmluZyBiZWZvcmVcbiAgICAgICAgICogZXhlY3V0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGJlZm9yZUV4ZWNIb29rc1Byb21pc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGZsYWcgdXNlZCB0byBlbnN1cmUgdGhhdCB3ZSBvbmx5IHdhcm4gYWJvdXQgcGFyYWxsZWwgaW5kZXhpbmcgb25jZSBwZXJcbiAgICAgICAgICogZXhlY3V0aW9uIHRvIGF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHdhcm5PZlBhcmFsbGVsSW5kZXhpbmcgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvdW50cyB0aGUgbnVtYmVyIG9mIHRpbWVzIHdlJ3ZlIGV4dGVuZGVkIHRoaXMgdGljay5cbiAgICAgICAgICovXG4gICAgICAgIGxldCB0aWNrRXh0ZW5zaW9uQ291bnQgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogR2l2ZW4gYSBjb2xsaWRpbmcgc3RlcCBJRCwgbWF5YmUgd2FybiB0aGUgdXNlciBhYm91dCBwYXJhbGxlbCBpbmRleGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG1heWJlV2Fybk9mUGFyYWxsZWxJbmRleGluZyA9IChjb2xsaXNpb25JZCkgPT4ge1xuICAgICAgICAgICAgaWYgKHdhcm5PZlBhcmFsbGVsSW5kZXhpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGVwRXhpc3RzID0gdGhpcy5zdGF0ZS5zdGVwcy5oYXMoY29sbGlzaW9uSWQpO1xuICAgICAgICAgICAgaWYgKHN0ZXBFeGlzdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwRm91bmRUaGlzVGljayA9IGZvdW5kU3RlcHNUb1JlcG9ydC5oYXMoY29sbGlzaW9uSWQpO1xuICAgICAgICAgICAgICAgIGlmICghc3RlcEZvdW5kVGhpc1RpY2spIHtcbiAgICAgICAgICAgICAgICAgICAgd2Fybk9mUGFyYWxsZWxJbmRleGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwid2FyblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2hhdEhhcHBlbmVkOiBcIldlIGRldGVjdGVkIHRoYXQgeW91IGhhdmUgbXVsdGlwbGUgc3RlcHMgd2l0aCB0aGUgc2FtZSBJRC5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yc19qc18xLkVyckNvZGUuQVVUT01BVElDX1BBUkFMTEVMX0lOREVYSU5HLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2h5OiBgVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSdyZSB1c2luZyB0aGUgc2FtZSBJRCBmb3IgbXVsdGlwbGUgc3RlcHMgYWNyb3NzIGRpZmZlcmVudCBjaGFpbnMgb2YgcGFyYWxsZWwgd29yay4gV2UgZm91bmQgdGhlIGlzc3VlIHdpdGggc3RlcCBcIiR7Y29sbGlzaW9uSWR9XCIuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNzdXJhbmNlOiBcIllvdXIgZnVuY3Rpb24gaXMgc3RpbGwgcnVubmluZywgdGhvdWdoIGl0IG1heSBleGhpYml0IHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIlVzaW5nIHRoZSBzYW1lIElEcyBhY3Jvc3MgcGFyYWxsZWwgY2hhaW5zIG9mIHdvcmsgY2FuIGNhdXNlIHVuZXhwZWN0ZWQgYmVoYXZpb3VyLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9GaXhOb3c6IFwiV2UgcmVjb21tZW5kIHVzaW5nIGEgdW5pcXVlIElEIGZvciBlYWNoIHN0ZXAsIGVzcGVjaWFsbHkgdGhvc2UgaGFwcGVuaW5nIGluIHBhcmFsbGVsLlwiLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBoZWxwZXIgdXNlZCB0byByZXBvcnQgc3RlcHMgdG8gdGhlIGNvcmUgbG9vcC4gVXNlZCBhZnRlciBhZGRpbmcgYW4gaXRlbVxuICAgICAgICAgKiB0byBgZm91bmRTdGVwc1RvUmVwb3J0YC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHJlcG9ydE5leHRUaWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gQmVpbmcgZXhwbGljaXQgaW5zdGVhZCBvZiB1c2luZyBgPz89YCB0byBhcHBlYXNlIFR5cGVTY3JpcHQuXG4gICAgICAgICAgICBpZiAoZm91bmRTdGVwc1JlcG9ydFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZXh0ZW5zaW9uUHJvbWlzZTtcbiAgICAgICAgICAgIGlmICgrK3RpY2tFeHRlbnNpb25Db3VudCA+PSAxMCkge1xuICAgICAgICAgICAgICAgIHRpY2tFeHRlbnNpb25Db3VudCA9IDA7XG4gICAgICAgICAgICAgICAgZXh0ZW5zaW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4dGVuc2lvblByb21pc2UgPSAoMCwgcHJvbWlzZXNfanNfMS5yZXNvbHZlQWZ0ZXJQZW5kaW5nKSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmRTdGVwc1JlcG9ydFByb21pc2UgPSBleHRlbnNpb25Qcm9taXNlXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRW5zdXJlIHRoYXQgd2Ugd2FpdCBmb3IgdGhpcyBwcm9taXNlIHRvIHJlc29sdmUgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBUaGUgZ3JvdXBzIGluIHdoaWNoIHN0ZXBzIGFyZSByZXBvcnRlZCBjYW4gYWZmZWN0IGhvdyB3ZSBkZXRlY3Qgc29tZVxuICAgICAgICAgICAgICAgICAqIG1vcmUgY29tcGxleCBkZXRlcm1pbmlzbSBpc3N1ZXMgbGlrZSBwYXJhbGxlbCBpbmRleGluZy4gVGhpcyBwcm9taXNlXG4gICAgICAgICAgICAgICAgICogY2FuIHJlcHJlc2VudCBtaWRkbGV3YXJlIGhvb2tzIGJlaW5nIHJ1biBlYXJseSwgaW4gdGhlIG1pZGRsZSBvZlxuICAgICAgICAgICAgICAgICAqIGluZ2VzdGluZyBzdGVwcyB0byByZXBvcnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBCZWNhdXNlIG9mIHRoaXMsIGl0J3MgaW1wb3J0YW50IHdlIHdhaXQgZm9yIHRoaXMgbWlkZGxld2FyZSB0byByZXNvbHZlXG4gICAgICAgICAgICAgICAgICogYmVmb3JlIGNvbnRpbnVpbmcgdG8gcmVwb3J0IHN0ZXBzIHRvIGVuc3VyZSB0aGF0IGFsbCBzdGVwcyBoYXZlIGFcbiAgICAgICAgICAgICAgICAgKiBjaGFuY2UgdG8gYmUgcmVwb3J0ZWQgdGhyb3VnaG91dCB0aGlzIGFzeW5jaHJvbm91cyBhY3Rpb24uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4gYmVmb3JlRXhlY0hvb2tzUHJvbWlzZSlcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtYWluaW5nU3RlcENvbXBsZXRpb25PcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0U3RlcElkID0gcmVtYWluaW5nU3RlcENvbXBsZXRpb25PcmRlcltpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFuZXh0U3RlcElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTdHJhbmdlIC0gc2tpcCB0aGlzIGVtcHR5IGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVkID0gKF9hID0gdW5oYW5kbGVkRm91bmRTdGVwc1RvUmVwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0KG5leHRTdGVwSWQpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGFuZGxlKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW1haW5pbmdTdGVwQ29tcGxldGlvbk9yZGVyLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaGFuZGxlZEZvdW5kU3RlcHNUb1JlcG9ydC5kZWxldGUobmV4dFN0ZXBJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdm9pZCByZXBvcnROZXh0VGljaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGhhbmRsZWQgbm8gc3RlcHMgaW4gdGhpcyBcInRpY2ssXCIgcm9sbCB1cCBldmVyeXRoaW5nIHdlJ3ZlXG4gICAgICAgICAgICAgICAgLy8gZm91bmQgYW5kIHJlcG9ydCBpdC5cbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwcyA9IFsuLi5mb3VuZFN0ZXBzVG9SZXBvcnQudmFsdWVzKCldO1xuICAgICAgICAgICAgICAgIGZvdW5kU3RlcHNUb1JlcG9ydC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHVuaGFuZGxlZEZvdW5kU3RlcHNUb1JlcG9ydC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIHRoaXMuc3RhdGUuc2V0Q2hlY2twb2ludCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcHMtZm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgc3RlcHM6IHN0ZXBzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIGhlbHBlciB1c2VkIHRvIHB1c2ggYSBzdGVwIHRvIHRoZSBsaXN0IG9mIHN0ZXBzIHRvIHJlcG9ydC5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHB1c2hTdGVwVG9SZXBvcnQgPSAoc3RlcCkgPT4ge1xuICAgICAgICAgICAgZm91bmRTdGVwc1RvUmVwb3J0LnNldChzdGVwLmlkLCBzdGVwKTtcbiAgICAgICAgICAgIHVuaGFuZGxlZEZvdW5kU3RlcHNUb1JlcG9ydC5zZXQoc3RlcC5oYXNoZWRJZCwgc3RlcCk7XG4gICAgICAgICAgICByZXBvcnROZXh0VGljaygpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdGVwSGFuZGxlciA9IGFzeW5jICh7IGFyZ3MsIG1hdGNoT3AsIG9wdHMsIH0pID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICAgIGF3YWl0IGJlZm9yZUV4ZWNIb29rc1Byb21pc2U7XG4gICAgICAgICAgICBjb25zdCBzdGVwT3B0aW9ucyA9ICgwLCBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuZ2V0U3RlcE9wdGlvbnMpKGFyZ3NbMF0pO1xuICAgICAgICAgICAgY29uc3Qgb3BJZCA9IG1hdGNoT3Aoc3RlcE9wdGlvbnMsIC4uLmFyZ3Muc2xpY2UoMSkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIGEgc3RlcCBpcyBmb3VuZCBhZnRlciBhc3luY2hyb25vdXMgYWN0aW9ucyBkdXJpbmcgYW5vdGhlciBzdGVwJ3NcbiAgICAgICAgICAgICAgICAgKiBleGVjdXRpb24sIGV2ZXJ5dGhpbmcgaXMgZmluZS4gVGhlIHByb2JsZW0gaGVyZSBpcyBpZiB3ZSd2ZSBmb3VuZFxuICAgICAgICAgICAgICAgICAqIHRoYXQgYSBzdGVwIG5lc3RlZCBpbnNpZGUgYW5vdGhlciBhIHN0ZXAsIHdoaWNoIGlzIHNvbWV0aGluZyB3ZSBkb24ndFxuICAgICAgICAgICAgICAgICAqIHN1cHBvcnQgYXQgdGhlIHRpbWUgb2Ygd3JpdGluZy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEluIHRoaXMgY2FzZSwgd2UgY291bGQgdXNlIHNvbWV0aGluZyBsaWtlIEFzeW5jIEhvb2tzIHRvIHVuZGVyc3RhbmRcbiAgICAgICAgICAgICAgICAgKiBob3cgdGhlIHN0ZXAgaXMgYmVpbmcgdHJpZ2dlcmVkLCB0aG91Z2ggdGhpcyBpc24ndCBhdmFpbGFibGUgaW4gYWxsXG4gICAgICAgICAgICAgICAgICogZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogVGhlcmVmb3JlLCB3ZSdsbCBvbmx5IHNob3cgYSB3YXJuaW5nIGhlcmUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIGlzXG4gICAgICAgICAgICAgICAgICogcG90ZW50aWFsbHkgYW4gaXNzdWUuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICAgICAgICAgICAgICB3aGF0SGFwcGVuZWQ6IGBXZSBkZXRlY3RlZCB0aGF0IHlvdSBoYXZlIG5lc3RlZCBcXGBzdGVwLipcXGAgdG9vbGluZyBpbiBcXGAkeyhfYSA9IG9wSWQuZGlzcGxheU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG9wSWQuaWR9XFxgYCxcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcIk5lc3RpbmcgYHN0ZXAuKmAgdG9vbGluZyBpcyBub3Qgc3VwcG9ydGVkLlwiLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIndhcm5cIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc3N1cmFuY2U6IFwiSXQncyBwb3NzaWJsZSB0byBzZWUgdGhpcyB3YXJuaW5nIGlmIHN0ZXBzIGFyZSBzZXBhcmF0ZWQgYnkgcmVndWxhciBhc3luY2hyb25vdXMgY2FsbHMsIHdoaWNoIGlzIGZpbmUuXCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0b0ZpeE5vdzogXCJNYWtlIHN1cmUgeW91J3JlIG5vdCB1c2luZyBgc3RlcC4qYCB0b29saW5nIGluc2lkZSBvZiBvdGhlciBgc3RlcC4qYCB0b29saW5nLiBJZiB5b3UgbmVlZCB0byBjb21wb3NlIHN0ZXBzIHRvZ2V0aGVyLCB5b3UgY2FuIGNyZWF0ZSBhIG5ldyBhc3luYyBmdW5jdGlvbiBhbmQgY2FsbCBpdCBmcm9tIHdpdGhpbiB5b3VyIHN0ZXAgZnVuY3Rpb24sIG9yIHVzZSBwcm9taXNlIGNoYWluaW5nLlwiLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvcnNfanNfMS5FcnJDb2RlLk5FU1RJTkdfU1RFUFMsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RlcHMuaGFzKG9wSWQuaWQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxJZCA9IG9wSWQuaWQ7XG4gICAgICAgICAgICAgICAgbWF5YmVXYXJuT2ZQYXJhbGxlbEluZGV4aW5nKG9yaWdpbmFsSWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkTmV4dEluZGV4ID0gKF9iID0gZXhwZWN0ZWROZXh0U3RlcEluZGV4ZXMuZ2V0KG9yaWdpbmFsSWQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBleHBlY3RlZE5leHRJbmRleDs7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJZCA9IG9yaWdpbmFsSWQgKyBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuU1RFUF9JTkRFWElOR19TVUZGSVggKyBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuc3RlcHMuaGFzKG5ld0lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWROZXh0U3RlcEluZGV4ZXMuc2V0KG9yaWdpbmFsSWQsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWQuaWQgPSBuZXdJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9ICgwLCBwcm9taXNlc19qc18xLmNyZWF0ZURlZmVycmVkUHJvbWlzZSkoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hlZElkID0gZXhwb3J0cy5faW50ZXJuYWxzLmhhc2hJZChvcElkLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBTdGF0ZSA9IHRoaXMuc3RhdGUuc3RlcFN0YXRlW2hhc2hlZElkXTtcbiAgICAgICAgICAgIGxldCBpc0Z1bGZpbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0ZXBTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0ZXBTdGF0ZS5zZWVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlbWFpbmluZ1N0ZXBzVG9CZVNlZW4uZGVsZXRlKGhhc2hlZElkKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0ZXBTdGF0ZS5pbnB1dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpc0Z1bGZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4dHJhT3B0cztcbiAgICAgICAgICAgIGxldCBmbkFyZ3MgPSBbLi4uYXJnc107XG4gICAgICAgICAgICBpZiAodHlwZW9mIChzdGVwU3RhdGUgPT09IG51bGwgfHwgc3RlcFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGVwU3RhdGUuaW5wdXQpICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShzdGVwU3RhdGUuaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcElkLm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBzdGVwLnJ1bigpYCBoYXMgaXRzIGZ1bmN0aW9uIGlucHV0IGFmZmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBQbGFubmVkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBmbkFyZ3MgPSBbLi4uYXJncy5zbGljZSgwLCAyKSwgLi4uc3RlcFN0YXRlLmlucHV0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhT3B0cyA9IHsgaW5wdXQ6IFsuLi5zdGVwU3RhdGUuaW5wdXRdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBgc3RlcC5haS5pbmZlcigpYCBoYXMgaXRzIGJvZHkgYWZmZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc19qc18xLlN0ZXBPcENvZGUuQWlHYXRld2F5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYU9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAodHlwZW9mICgoX2MgPSBvcElkLm9wdHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5ib2R5KSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oe30sIG9wSWQub3B0cy5ib2R5KSA6IHt9KSksIHN0ZXBTdGF0ZS5pbnB1dFswXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGVwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcElkKSwgeyBvcHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wSWQub3B0cyksIGV4dHJhT3B0cyksIHJhd0FyZ3M6IGZuQXJncywgLy8gVE9ETyBXaGF0IGlzIHRoZSByaWdodCB2YWx1ZSBoZXJlPyBTaG91bGQgdGhpcyBiZSByYXcgYXJncyB3aXRob3V0IGFmZmVjdGVkIGlucHV0P1xuICAgICAgICAgICAgICAgIGhhc2hlZElkLCBpbnB1dDogc3RlcFN0YXRlID09PSBudWxsIHx8IHN0ZXBTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RlcFN0YXRlLmlucHV0LCBcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgICAgIGZuOiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmZuKSA/ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gb3B0cy5mbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0cywgLi4uZm5BcmdzKTsgfSA6IHVuZGVmaW5lZCwgcHJvbWlzZSwgZnVsZmlsbGVkOiBpc0Z1bGZpbGxlZCwgaGFzU3RlcFN0YXRlOiBCb29sZWFuKHN0ZXBTdGF0ZSksIGRpc3BsYXlOYW1lOiAoX2QgPSBvcElkLmRpc3BsYXlOYW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBvcElkLmlkLCBoYW5kbGVkOiBmYWxzZSwgaGFuZGxlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwLmhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGVwLmhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdWxmaWxsZWQgJiYgc3RlcFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwU3RhdGUuZnVsZmlsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBzb21lIGV4ZWN1dGlvbiBzY2VuYXJpb3Mgc3VjaCBhcyB0ZXN0aW5nLCBgZGF0YWAsIGBlcnJvcmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYGlucHV0YCBtYXkgYmUgYFByb21pc2VzYC4gVGhpcyBjb3VsZCBhbHNvIGJlIHRoZSBjYXNlIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnV0dXJlIG1pZGRsZXdhcmUgYXBwbGljYXRpb25zLiBGb3IgdGhpcyByZWFzb24sIHdlJ2xsIG1ha2Ugc3VyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlcyBhcmUgZnVsbHkgcmVzb2x2ZWQgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwU3RhdGUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwU3RhdGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGVwU3RhdGUuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0ZXBTdGF0ZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucmVjZW50bHlSZWplY3RlZFN0ZXBFcnJvciA9IG5ldyBTdGVwRXJyb3JfanNfMS5TdGVwRXJyb3Iob3BJZC5pZCwgc3RlcFN0YXRlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuc3RhdGUucmVjZW50bHlSZWplY3RlZFN0ZXBFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RlcHMuc2V0KG9wSWQuaWQsIHN0ZXApO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5oYXNTdGVwcyA9IHRydWU7XG4gICAgICAgICAgICBwdXNoU3RlcFRvUmVwb3J0KHN0ZXApO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIHRoZSBsYXN0IHBpZWNlIG9mIHN0YXRlIHdlIGhhZCwgd2UndmUgbm93IGZpbmlzaGVkXG4gICAgICAgICAgICAgKiBtZW1vaXppbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghYmVmb3JlRXhlY0hvb2tzUHJvbWlzZSAmJiB0aGlzLnN0YXRlLmFsbFN0YXRlVXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKGJlZm9yZUV4ZWNIb29rc1Byb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKSk7XG4gICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICgwLCBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuY3JlYXRlU3RlcFRvb2xzKSh0aGlzLm9wdGlvbnMuY2xpZW50LCB0aGlzLCBzdGVwSGFuZGxlcik7XG4gICAgfVxuICAgIGdldFVzZXJGblRvUnVuKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0ZhaWx1cmVIYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZuW1wiZm5cIl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZm5bXCJvbkZhaWx1cmVGblwiXSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTb21laG93LCB3ZSd2ZSBlbmRlZCB1cCBkZXRlY3RpbmcgdGhhdCB0aGlzIGlzIGEgZmFpbHVyZSBoYW5kbGVyIGJ1dFxuICAgICAgICAgICAgICogZG9lc24ndCBoYXZlIGFuIGBvbkZhaWx1cmVgIGZ1bmN0aW9uLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZ1bmN0aW9uIGBvbkZhaWx1cmVgIGhhbmRsZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mbltcIm9uRmFpbHVyZUZuXCJdO1xuICAgIH1cbiAgICBpbml0aWFsaXplVGltZXIoc3RhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZW91dCA9ICgwLCBwcm9taXNlc19qc18xLmNyZWF0ZVRpbWVvdXRQcm9taXNlKSh0aGlzLnRpbWVvdXREdXJhdGlvbik7XG4gICAgICAgIHZvaWQgdGhpcy50aW1lb3V0LnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9kID0gKF9jID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2YgPSAoX2UgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSk7XG4gICAgICAgICAgICBzdGF0ZS5zZXRDaGVja3BvaW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtbm90LWZvdW5kXCIsXG4gICAgICAgICAgICAgICAgc3RlcDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcE5vdEZvdW5kLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVNaWRkbGV3YXJlKCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLm9wdGlvbnMuZGF0YTtcbiAgICAgICAgY29uc3QgaG9va3MgPSBhd2FpdCAoMCwgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5nZXRIb29rU3RhY2spKHRoaXMub3B0aW9ucy5mbltcIm1pZGRsZXdhcmVcIl0sIFwib25GdW5jdGlvblJ1blwiLCB7XG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICBmbjogdGhpcy5vcHRpb25zLmZuLFxuICAgICAgICAgICAgc3RlcHM6IE9iamVjdC52YWx1ZXModGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSksXG4gICAgICAgICAgICByZXFBcmdzOiB0aGlzLm9wdGlvbnMucmVxQXJncyxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdHJhbnNmb3JtSW5wdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjdHg6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldi5jdHgpLCBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQuY3R4KSxcbiAgICAgICAgICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgICAgICAgICAgc3RlcHM6IHByZXYuc3RlcHMubWFwKChzdGVwLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcCksIChfYSA9IG91dHB1dCA9PT0gbnVsbCB8fCBvdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG91dHB1dC5zdGVwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICByZXFBcmdzOiBwcmV2LnJlcUFyZ3MsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2Zvcm1PdXRwdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldi5yZXN1bHQpLCBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQucmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogcHJldi5zdGVwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhvb2tzO1xuICAgIH1cbn1cbmNvbnN0IGhhc2hJZCA9IChpZCkgPT4ge1xuICAgIHJldHVybiAoMCwgaGFzaF9qc18xLnNoYTEpKCkudXBkYXRlKGlkKS5kaWdlc3QoXCJoZXhcIik7XG59O1xuY29uc3QgaGFzaE9wID0gKG9wKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ApLCB7IGlkOiBoYXNoSWQob3AuaWQpIH0pO1xufTtcbi8qKlxuICogRXhwb3J0ZWQgZm9yIHRlc3RpbmcuXG4gKi9cbmV4cG9ydHMuX2ludGVybmFscyA9IHsgaGFzaE9wLCBoYXNoSWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXYxLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v1.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/components/execution/v2.js":
/*!*********************************************************!*\
  !*** ./node_modules/inngest/components/execution/v2.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __asyncValues = (this && this.__asyncValues) || function (o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n};\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports._internals = exports.createV2InngestExecution = void 0;\nconst api_1 = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/@opentelemetry/api/build/esm/index.js\");\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst consts_js_1 = __webpack_require__(/*! ../../helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst errors_js_1 = __webpack_require__(/*! ../../helpers/errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\nconst functions_js_1 = __webpack_require__(/*! ../../helpers/functions.js */ \"(rsc)/./node_modules/inngest/helpers/functions.js\");\nconst promises_js_1 = __webpack_require__(/*! ../../helpers/promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\nconst types_js_1 = __webpack_require__(/*! ../../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst version_js_1 = __webpack_require__(/*! ../../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nconst InngestStepTools_js_1 = __webpack_require__(/*! ../InngestStepTools.js */ \"(rsc)/./node_modules/inngest/components/InngestStepTools.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst RetryAfterError_js_1 = __webpack_require__(/*! ../RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nconst StepError_js_1 = __webpack_require__(/*! ../StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ./InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst als_js_1 = __webpack_require__(/*! ./als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nconst access_js_1 = __webpack_require__(/*! ./otel/access.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/access.js\");\nconst createV2InngestExecution = (options) => {\n    return new V2InngestExecution(options);\n};\nexports.createV2InngestExecution = createV2InngestExecution;\nclass V2InngestExecution extends InngestExecution_js_1.InngestExecution {\n    constructor(options) {\n        super(options);\n        this.timeoutDuration = 1000 * 10;\n        this.userFnToRun = this.getUserFnToRun();\n        this.state = this.createExecutionState();\n        this.fnArg = this.createFnArg();\n        this.checkpointHandlers = this.createCheckpointHandlers();\n        this.initializeTimer(this.state);\n        this.debug(\"created new V2 execution for run;\", this.options.requestedRunStep\n            ? `wanting to run step \"${this.options.requestedRunStep}\"`\n            : \"discovering steps\");\n        this.debug(\"existing state keys:\", Object.keys(this.state.stepState));\n    }\n    /**\n     * Idempotently start the execution of the user's function.\n     */\n    start() {\n        if (!this.execution) {\n            this.debug(\"starting V2 execution\");\n            const tracer = api_1.trace.getTracer(\"inngest\", version_js_1.version);\n            this.execution = (0, als_js_1.getAsyncLocalStorage)().then((als) => {\n                return als.run({ app: this.options.client, ctx: this.fnArg }, async () => {\n                    return tracer.startActiveSpan(\"inngest.execution\", (span) => {\n                        var _a;\n                        (_a = access_js_1.clientProcessorMap.get(this.options.client)) === null || _a === void 0 ? void 0 : _a.declareStartingSpan({\n                            span,\n                            runId: this.options.runId,\n                            traceparent: this.options.headers[consts_js_1.headerKeys.TraceParent],\n                            tracestate: this.options.headers[consts_js_1.headerKeys.TraceState],\n                        });\n                        return this._start()\n                            .then((result) => {\n                            this.debug(\"result:\", result);\n                            return result;\n                        })\n                            .finally(() => {\n                            span.end();\n                        });\n                    });\n                });\n            });\n        }\n        return this.execution;\n    }\n    /**\n     * Starts execution of the user's function and the core loop.\n     */\n    async _start() {\n        var _a, e_1, _b, _c;\n        var _d, _e;\n        try {\n            const allCheckpointHandler = this.getCheckpointHandler(\"\");\n            this.state.hooks = await this.initializeMiddleware();\n            await this.startExecution();\n            try {\n                for (var _f = true, _g = __asyncValues(this.state.loop), _h; _h = await _g.next(), _a = _h.done, !_a; _f = true) {\n                    _c = _h.value;\n                    _f = false;\n                    const checkpoint = _c;\n                    await allCheckpointHandler(checkpoint);\n                    const handler = this.getCheckpointHandler(checkpoint.type);\n                    const result = await handler(checkpoint);\n                    if (result) {\n                        return result;\n                    }\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (!_f && !_a && (_b = _g.return)) await _b.call(_g);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n        }\n        catch (error) {\n            return await this.transformOutput({ error });\n        }\n        finally {\n            void this.state.loop.return();\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeResponse) === null || _e === void 0 ? void 0 : _e.call(_d));\n        }\n        /**\n         * If we're here, the generator somehow finished without returning a value.\n         * This should never happen.\n         */\n        throw new Error(\"Core loop finished without returning a value\");\n    }\n    /**\n     * Creates a handler for every checkpoint type, defining what to do when we\n     * reach that checkpoint in the core loop.\n     */\n    createCheckpointHandlers() {\n        return {\n            /**\n             * Run for all checkpoints. Best used for logging or common actions.\n             * Use other handlers to return values and interrupt the core loop.\n             */\n            \"\": (checkpoint) => {\n                this.debug(\"checkpoint:\", checkpoint);\n            },\n            /**\n             * The user's function has completed and returned a value.\n             */\n            \"function-resolved\": async (checkpoint) => {\n                return await this.transformOutput({ data: checkpoint.data });\n            },\n            /**\n             * The user's function has thrown an error.\n             */\n            \"function-rejected\": async (checkpoint) => {\n                return await this.transformOutput({ error: checkpoint.error });\n            },\n            /**\n             * We've found one or more steps. Here we may want to run a step or report\n             * them back to Inngest.\n             */\n            \"steps-found\": async ({ steps }) => {\n                const stepResult = await this.tryExecuteStep(steps);\n                if (stepResult) {\n                    const transformResult = await this.transformOutput(stepResult);\n                    /**\n                     * Transforming output will always return either function rejection or\n                     * resolution. In most cases, this can be immediately returned, but in\n                     * this particular case we want to handle it differently.\n                     */\n                    if (transformResult.type === \"function-resolved\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { data: transformResult.data })),\n                        };\n                    }\n                    else if (transformResult.type === \"function-rejected\") {\n                        return {\n                            type: \"step-ran\",\n                            ctx: transformResult.ctx,\n                            ops: transformResult.ops,\n                            step: exports._internals.hashOp(Object.assign(Object.assign({}, stepResult), { error: transformResult.error })),\n                            retriable: transformResult.retriable,\n                        };\n                    }\n                    return transformResult;\n                }\n                const newSteps = await this.filterNewSteps(Array.from(this.state.steps.values()));\n                if (newSteps) {\n                    return {\n                        type: \"steps-found\",\n                        ctx: this.fnArg,\n                        ops: this.ops,\n                        steps: newSteps,\n                    };\n                }\n            },\n            /**\n             * While trying to find a step that Inngest has told us to run, we've\n             * timed out or have otherwise decided that it doesn't exist.\n             */\n            \"step-not-found\": ({ step }) => {\n                return { type: \"step-not-found\", ctx: this.fnArg, ops: this.ops, step };\n            },\n        };\n    }\n    getCheckpointHandler(type) {\n        return this.checkpointHandlers[type];\n    }\n    async tryExecuteStep(steps) {\n        var _a;\n        const hashedStepIdToRun = this.options.requestedRunStep || this.getEarlyExecRunStep(steps);\n        if (!hashedStepIdToRun) {\n            return;\n        }\n        const step = steps.find((step) => step.hashedId === hashedStepIdToRun && step.fn);\n        if (step) {\n            return await this.executeStep(step);\n        }\n        /**\n         * Ensure we reset the timeout if we have a requested run step but couldn't\n         * find it, but also that we don't reset if we found and executed it.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.reset());\n    }\n    /**\n     * Given a list of outgoing ops, decide if we can execute an op early and\n     * return the ID of the step to execute if we can.\n     */\n    getEarlyExecRunStep(steps) {\n        /**\n         * We may have been disabled due to parallelism, in which case we can't\n         * immediately execute unless explicitly requested.\n         */\n        if (this.options.disableImmediateExecution)\n            return;\n        const unfulfilledSteps = steps.filter((step) => !step.fulfilled);\n        if (unfulfilledSteps.length !== 1)\n            return;\n        const op = unfulfilledSteps[0];\n        if (op &&\n            op.op === types_js_1.StepOpCode.StepPlanned\n        // TODO We must individually check properties here that we do not want to\n        // execute on, such as retry counts. Nothing exists here that falls in to\n        // this case, but should be accounted for when we add them.\n        // && typeof op.opts === \"undefined\"\n        ) {\n            return op.hashedId;\n        }\n    }\n    async filterNewSteps(foundSteps) {\n        var _a, _b, _c, _d, _e, _f;\n        if (this.options.requestedRunStep) {\n            return;\n        }\n        /**\n         * Gather any steps that aren't memoized and report them.\n         */\n        const newSteps = foundSteps.filter((step) => !step.fulfilled);\n        if (!newSteps.length) {\n            return;\n        }\n        /**\n         * Warn if we've found new steps but haven't yet seen all previous\n         * steps. This may indicate that step presence isn't determinate.\n         */\n        let knownSteps = 0;\n        for (const step of foundSteps) {\n            if (step.fulfilled) {\n                knownSteps++;\n            }\n        }\n        const foundAllCompletedSteps = this.state.stepsToFulfill === knownSteps;\n        if (!foundAllCompletedSteps) {\n            // TODO Tag\n            console.warn((0, errors_js_1.prettyError)({\n                type: \"warn\",\n                whatHappened: \"Function may be indeterminate\",\n                why: \"We found new steps before seeing all previous steps, which may indicate that the function is non-deterministic.\",\n                consequences: \"This may cause unexpected behaviour as Inngest executes your function.\",\n                reassurance: \"This is expected if a function is updated in the middle of a run, but may indicate a bug if not.\",\n            }));\n        }\n        /**\n         * We're finishing up; let's trigger the last of the hooks.\n         */\n        await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n        await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n        await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        const stepList = newSteps.map((step) => ({\n            displayName: step.displayName,\n            op: step.op,\n            id: step.hashedId,\n            name: step.name,\n            opts: step.opts,\n        }));\n        /**\n         * We also run `onSendEvent` middleware hooks against `step.invoke()` steps\n         * to ensure that their `data` is transformed correctly.\n         */\n        return await this.transformNewSteps(stepList);\n    }\n    /**\n     * Using middleware, transform any newly-found steps before returning them to\n     * an Inngest Server.\n     */\n    async transformNewSteps(steps) {\n        return Promise.all(steps.map(async (step) => {\n            var _a, _b, _c, _d, _e, _f, _g;\n            if (step.op !== types_js_1.StepOpCode.InvokeFunction) {\n                return step;\n            }\n            const onSendEventHooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onSendEvent\", undefined, {\n                transformInput: (prev, output) => {\n                    return Object.assign(Object.assign({}, prev), output);\n                },\n                transformOutput: (prev, output) => {\n                    return {\n                        result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    };\n                },\n            });\n            /**\n             * For each event being sent, create a new `onSendEvent` hook stack to\n             * process it. We do this as middleware hooks are intended to run once\n             * during each lifecycle (onFunctionRun or onSendEvent) and here, a hook\n             * is run for every single event.\n             *\n             * This is done because a developer can use this hook to filter out\n             * events entirely; if we batch all of the events together, we can't\n             * tell which ones were filtered out if we're processing >1 invocation\n             * here.\n             */\n            const transformedPayload = await ((_a = onSendEventHooks.transformInput) === null || _a === void 0 ? void 0 : _a.call(onSendEventHooks, {\n                payloads: [\n                    Object.assign(Object.assign({}, ((_c = (_b = step.opts) === null || _b === void 0 ? void 0 : _b.payload) !== null && _c !== void 0 ? _c : {})), { name: consts_js_1.internalEvents.FunctionInvoked }),\n                ],\n            }));\n            const newPayload = InngestStepTools_js_1.invokePayloadSchema.parse((_e = (_d = transformedPayload === null || transformedPayload === void 0 ? void 0 : transformedPayload.payloads) === null || _d === void 0 ? void 0 : _d[0]) !== null && _e !== void 0 ? _e : {});\n            return Object.assign(Object.assign({}, step), { opts: Object.assign(Object.assign({}, step.opts), { payload: Object.assign(Object.assign({}, ((_g = (_f = step.opts) === null || _f === void 0 ? void 0 : _f.payload) !== null && _g !== void 0 ? _g : {})), newPayload) }) });\n        }));\n    }\n    async executeStep({ id, name, opts, fn, displayName, }) {\n        var _a, _b, _c, _d, _e;\n        (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.afterMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.beforeExecution) === null || _e === void 0 ? void 0 : _e.call(_d));\n        const outgoingOp = {\n            id,\n            op: types_js_1.StepOpCode.StepRun,\n            name,\n            opts,\n            displayName,\n        };\n        this.state.executingStep = outgoingOp;\n        const store = await (0, als_js_1.getAsyncCtx)();\n        if (store) {\n            store.executingStep = {\n                id,\n                name: displayName,\n            };\n        }\n        this.debug(`executing step \"${id}\"`);\n        return ((0, promises_js_1.runAsPromise)(fn)\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b;\n            if (store) {\n                delete store.executingStep;\n            }\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterExecution) === null || _b === void 0 ? void 0 : _b.call(_a));\n        })\n            .then((data) => {\n            return Object.assign(Object.assign({}, outgoingOp), { data });\n        })\n            .catch((error) => {\n            return Object.assign(Object.assign({}, outgoingOp), { op: types_js_1.StepOpCode.StepError, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                error });\n        }));\n    }\n    /**\n     * Starts execution of the user's function, including triggering checkpoints\n     * and middleware hooks where appropriate.\n     */\n    async startExecution() {\n        var _a, _b, _c, _d, _e, _f, _g;\n        /**\n         * Mutate input as neccessary based on middleware.\n         */\n        await this.transformInput();\n        /**\n         * Start the timer to time out the run if needed.\n         */\n        void ((_a = this.timeout) === null || _a === void 0 ? void 0 : _a.start());\n        await ((_c = (_b = this.state.hooks) === null || _b === void 0 ? void 0 : _b.beforeMemoization) === null || _c === void 0 ? void 0 : _c.call(_b));\n        /**\n         * If we had no state to begin with, immediately end the memoization phase.\n         */\n        if (this.state.allStateUsed()) {\n            await ((_e = (_d = this.state.hooks) === null || _d === void 0 ? void 0 : _d.afterMemoization) === null || _e === void 0 ? void 0 : _e.call(_d));\n            await ((_g = (_f = this.state.hooks) === null || _f === void 0 ? void 0 : _f.beforeExecution) === null || _g === void 0 ? void 0 : _g.call(_f));\n        }\n        /**\n         * Trigger the user's function.\n         */\n        (0, promises_js_1.runAsPromise)(() => this.userFnToRun(this.fnArg))\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            .finally(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n        })\n            .then((data) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-resolved\", data });\n        })\n            .catch((error) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            this.state.setCheckpoint({ type: \"function-rejected\", error });\n        });\n    }\n    /**\n     * Using middleware, transform input before running.\n     */\n    async transformInput() {\n        var _a, _b;\n        const inputMutations = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformInput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            ctx: Object.assign({}, this.fnArg),\n            steps: Object.values(this.state.stepState),\n            fn: this.options.fn,\n            reqArgs: this.options.reqArgs,\n        }));\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.ctx) {\n            this.fnArg = inputMutations.ctx;\n        }\n        if (inputMutations === null || inputMutations === void 0 ? void 0 : inputMutations.steps) {\n            this.state.stepState = Object.fromEntries(inputMutations.steps.map((step) => [step.id, step]));\n        }\n    }\n    /**\n     * Using middleware, transform output before returning.\n     */\n    async transformOutput(dataOrError) {\n        var _a, _b, _c, _d;\n        const output = Object.assign({}, dataOrError);\n        /**\n         * If we've been given an error and it's one that we just threw from a step,\n         * we should return a `NonRetriableError` to stop execution.\n         */\n        if (typeof output.error !== \"undefined\") {\n            output.data = (0, errors_js_1.serializeError)(output.error);\n        }\n        const isStepExecution = Boolean(this.state.executingStep);\n        const transformedOutput = await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.transformOutput) === null || _b === void 0 ? void 0 : _b.call(_a, {\n            result: Object.assign({}, output),\n            step: this.state.executingStep,\n        }));\n        const { data, error } = Object.assign(Object.assign({}, output), transformedOutput === null || transformedOutput === void 0 ? void 0 : transformedOutput.result);\n        if (!isStepExecution) {\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.finished) === null || _d === void 0 ? void 0 : _d.call(_c, {\n                result: Object.assign({}, (typeof error !== \"undefined\" ? { error } : { data })),\n            }));\n        }\n        if (typeof error !== \"undefined\") {\n            /**\n             * Ensure we give middleware the chance to decide on retriable behaviour\n             * by looking at the error returned from output transformation.\n             */\n            let retriable = !(error instanceof NonRetriableError_js_1.NonRetriableError || error instanceof StepError_js_1.StepError);\n            if (retriable && error instanceof RetryAfterError_js_1.RetryAfterError) {\n                retriable = error.retryAfter;\n            }\n            const serializedError = (0, errors_js_1.minifyPrettyError)((0, errors_js_1.serializeError)(error));\n            return {\n                type: \"function-rejected\",\n                ctx: this.fnArg,\n                ops: this.ops,\n                error: serializedError,\n                retriable,\n            };\n        }\n        return {\n            type: \"function-resolved\",\n            ctx: this.fnArg,\n            ops: this.ops,\n            data: (0, functions_js_1.undefinedToNull)(data),\n        };\n    }\n    createExecutionState() {\n        const d = (0, promises_js_1.createDeferredPromiseWithStack)();\n        let checkpointResolve = d.deferred.resolve;\n        const checkpointResults = d.results;\n        const loop = (function (cleanUp) {\n            return __asyncGenerator(this, arguments, function* () {\n                try {\n                    while (true) {\n                        const res = (yield __await(checkpointResults.next())).value;\n                        if (res) {\n                            yield yield __await(res);\n                        }\n                    }\n                }\n                finally {\n                    cleanUp === null || cleanUp === void 0 ? void 0 : cleanUp();\n                }\n            });\n        })(() => {\n            var _a;\n            (_a = this.timeout) === null || _a === void 0 ? void 0 : _a.clear();\n            void checkpointResults.return();\n        });\n        const stepsToFulfill = Object.keys(this.options.stepState).length;\n        const state = {\n            stepState: this.options.stepState,\n            stepsToFulfill,\n            steps: new Map(),\n            loop,\n            hasSteps: Boolean(stepsToFulfill),\n            stepCompletionOrder: [...this.options.stepCompletionOrder],\n            remainingStepsToBeSeen: new Set(this.options.stepCompletionOrder),\n            setCheckpoint: (checkpoint) => {\n                ({ resolve: checkpointResolve } = checkpointResolve(checkpoint));\n            },\n            allStateUsed: () => {\n                return this.state.remainingStepsToBeSeen.size === 0;\n            },\n        };\n        return state;\n    }\n    get ops() {\n        return Object.fromEntries(this.state.steps);\n    }\n    createFnArg() {\n        var _a, _b, _c, _d;\n        const step = this.createStepTools();\n        let fnArg = Object.assign(Object.assign({}, this.options.data), { step });\n        /**\n         * Handle use of the `onFailure` option by deserializing the error.\n         */\n        if (this.options.isFailureHandler) {\n            const eventData = zod_1.z\n                .object({ error: types_js_1.jsonErrorSchema })\n                .parse((_a = fnArg.event) === null || _a === void 0 ? void 0 : _a.data);\n            fnArg = Object.assign(Object.assign({}, fnArg), { error: (0, errors_js_1.deserializeError)(eventData.error) });\n        }\n        return (_d = (_c = (_b = this.options).transformCtx) === null || _c === void 0 ? void 0 : _c.call(_b, fnArg)) !== null && _d !== void 0 ? _d : fnArg;\n    }\n    createStepTools() {\n        /**\n         * A list of steps that have been found and are being rolled up before being\n         * reported to the core loop.\n         */\n        const foundStepsToReport = new Map();\n        /**\n         * A map of the subset of found steps to report that have not yet been\n         * handled. Used for fast access to steps that need to be handled in order.\n         */\n        const unhandledFoundStepsToReport = new Map();\n        /**\n         * A map of the latest sequential step indexes found for each step ID. Used\n         * to ensure that we don't index steps in parallel.\n         *\n         * Note that these must be sequential; if we've seen or assigned `a:1`,\n         * `a:2` and `a:4`, the latest sequential step index is `2`.\n         *\n         */\n        const expectedNextStepIndexes = new Map();\n        /**\n         * A promise that's used to ensure that step reporting cannot be run more than\n         * once in a given asynchronous time span.\n         */\n        let foundStepsReportPromise;\n        /**\n         * A promise that's used to represent middleware hooks running before\n         * execution.\n         */\n        let beforeExecHooksPromise;\n        /**\n         * A helper used to report steps to the core loop. Used after adding an item\n         * to `foundStepsToReport`.\n         */\n        const reportNextTick = () => {\n            // Being explicit instead of using `??=` to appease TypeScript.\n            if (foundStepsReportPromise) {\n                return;\n            }\n            foundStepsReportPromise = new Promise((resolve) => setImmediate(resolve))\n                /**\n                 * Ensure that we wait for this promise to resolve before continuing.\n                 *\n                 * The groups in which steps are reported can affect how we detect some\n                 * more complex determinism issues like parallel indexing. This promise\n                 * can represent middleware hooks being run early, in the middle of\n                 * ingesting steps to report.\n                 *\n                 * Because of this, it's important we wait for this middleware to resolve\n                 * before continuing to report steps to ensure that all steps have a\n                 * chance to be reported throughout this asynchronous action.\n                 */\n                .then(() => beforeExecHooksPromise)\n                .then(() => {\n                foundStepsReportPromise = undefined;\n                for (const [hashedId, step] of unhandledFoundStepsToReport) {\n                    if (step.handle()) {\n                        unhandledFoundStepsToReport.delete(hashedId);\n                        if (step.fulfilled) {\n                            foundStepsToReport.delete(step.id);\n                        }\n                    }\n                }\n                if (foundStepsToReport.size) {\n                    const steps = [...foundStepsToReport.values()];\n                    foundStepsToReport.clear();\n                    return void this.state.setCheckpoint({\n                        type: \"steps-found\",\n                        steps: steps,\n                    });\n                }\n            });\n        };\n        /**\n         * A helper used to push a step to the list of steps to report.\n         */\n        const pushStepToReport = (step) => {\n            foundStepsToReport.set(step.id, step);\n            unhandledFoundStepsToReport.set(step.hashedId, step);\n            reportNextTick();\n        };\n        const stepHandler = async ({ args, matchOp, opts, }) => {\n            var _a, _b, _c, _d;\n            await beforeExecHooksPromise;\n            const stepOptions = (0, InngestStepTools_js_1.getStepOptions)(args[0]);\n            const opId = matchOp(stepOptions, ...args.slice(1));\n            if (this.state.executingStep) {\n                /**\n                 * If a step is found after asynchronous actions during another step's\n                 * execution, everything is fine. The problem here is if we've found\n                 * that a step nested inside another a step, which is something we don't\n                 * support at the time of writing.\n                 *\n                 * In this case, we could use something like Async Hooks to understand\n                 * how the step is being triggered, though this isn't available in all\n                 * environments.\n                 *\n                 * Therefore, we'll only show a warning here to indicate that this is\n                 * potentially an issue.\n                 */\n                console.warn((0, errors_js_1.prettyError)({\n                    whatHappened: `We detected that you have nested \\`step.*\\` tooling in \\`${(_a = opId.displayName) !== null && _a !== void 0 ? _a : opId.id}\\``,\n                    consequences: \"Nesting `step.*` tooling is not supported.\",\n                    type: \"warn\",\n                    reassurance: \"It's possible to see this warning if steps are separated by regular asynchronous calls, which is fine.\",\n                    stack: true,\n                    toFixNow: \"Make sure you're not using `step.*` tooling inside of other `step.*` tooling. If you need to compose steps together, you can create a new async function and call it from within your step function, or use promise chaining.\",\n                    code: errors_js_1.ErrCode.NESTING_STEPS,\n                }));\n            }\n            if (this.state.steps.has(opId.id)) {\n                const originalId = opId.id;\n                const expectedNextIndex = (_b = expectedNextStepIndexes.get(originalId)) !== null && _b !== void 0 ? _b : 1;\n                for (let i = expectedNextIndex;; i++) {\n                    const newId = originalId + InngestStepTools_js_1.STEP_INDEXING_SUFFIX + i;\n                    if (!this.state.steps.has(newId)) {\n                        expectedNextStepIndexes.set(originalId, i + 1);\n                        opId.id = newId;\n                        break;\n                    }\n                }\n            }\n            const { promise, resolve, reject } = (0, promises_js_1.createDeferredPromise)();\n            const hashedId = exports._internals.hashId(opId.id);\n            const stepState = this.state.stepState[hashedId];\n            let isFulfilled = false;\n            if (stepState) {\n                stepState.seen = true;\n                this.state.remainingStepsToBeSeen.delete(hashedId);\n                if (typeof stepState.input === \"undefined\") {\n                    isFulfilled = true;\n                }\n            }\n            let extraOpts;\n            let fnArgs = [...args];\n            if (typeof (stepState === null || stepState === void 0 ? void 0 : stepState.input) !== \"undefined\" &&\n                Array.isArray(stepState.input)) {\n                switch (opId.op) {\n                    // `step.run()` has its function input affected\n                    case types_js_1.StepOpCode.StepPlanned: {\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        fnArgs = [...args.slice(0, 2), ...stepState.input];\n                        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                        extraOpts = { input: [...stepState.input] };\n                        break;\n                    }\n                    // `step.ai.infer()` has its body affected\n                    case types_js_1.StepOpCode.AiGateway: {\n                        extraOpts = {\n                            body: Object.assign(Object.assign({}, (typeof ((_c = opId.opts) === null || _c === void 0 ? void 0 : _c.body) === \"object\"\n                                ? Object.assign({}, opId.opts.body) : {})), stepState.input[0]),\n                        };\n                        break;\n                    }\n                }\n            }\n            const step = Object.assign(Object.assign({}, opId), { opts: Object.assign(Object.assign({}, opId.opts), extraOpts), rawArgs: fnArgs, // TODO What is the right value here? Should this be raw args without affected input?\n                hashedId, input: stepState === null || stepState === void 0 ? void 0 : stepState.input, \n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n                fn: (opts === null || opts === void 0 ? void 0 : opts.fn) ? () => { var _a; return (_a = opts.fn) === null || _a === void 0 ? void 0 : _a.call(opts, ...fnArgs); } : undefined, promise, fulfilled: isFulfilled, hasStepState: Boolean(stepState), displayName: (_d = opId.displayName) !== null && _d !== void 0 ? _d : opId.id, handled: false, handle: () => {\n                    if (step.handled) {\n                        return false;\n                    }\n                    step.handled = true;\n                    if (isFulfilled && stepState) {\n                        stepState.fulfilled = true;\n                        // For some execution scenarios such as testing, `data`, `error`,\n                        // and `input` may be `Promises`. This could also be the case for\n                        // future middleware applications. For this reason, we'll make sure\n                        // the values are fully resolved before continuing.\n                        void Promise.all([\n                            stepState.data,\n                            stepState.error,\n                            stepState.input,\n                        ]).then(() => {\n                            if (typeof stepState.data !== \"undefined\") {\n                                resolve(stepState.data);\n                            }\n                            else {\n                                this.state.recentlyRejectedStepError = new StepError_js_1.StepError(opId.id, stepState.error);\n                                reject(this.state.recentlyRejectedStepError);\n                            }\n                        });\n                    }\n                    return true;\n                } });\n            this.state.steps.set(opId.id, step);\n            this.state.hasSteps = true;\n            pushStepToReport(step);\n            /**\n             * If this is the last piece of state we had, we've now finished\n             * memoizing.\n             */\n            if (!beforeExecHooksPromise && this.state.allStateUsed()) {\n                await (beforeExecHooksPromise = (async () => {\n                    var _a, _b, _c, _d;\n                    await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n                    await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n                })());\n            }\n            return promise;\n        };\n        return (0, InngestStepTools_js_1.createStepTools)(this.options.client, this, stepHandler);\n    }\n    getUserFnToRun() {\n        if (!this.options.isFailureHandler) {\n            return this.options.fn[\"fn\"];\n        }\n        if (!this.options.fn[\"onFailureFn\"]) {\n            /**\n             * Somehow, we've ended up detecting that this is a failure handler but\n             * doesn't have an `onFailure` function. This should never happen.\n             */\n            throw new Error(\"Cannot find function `onFailure` handler\");\n        }\n        return this.options.fn[\"onFailureFn\"];\n    }\n    initializeTimer(state) {\n        if (!this.options.requestedRunStep) {\n            return;\n        }\n        this.timeout = (0, promises_js_1.createTimeoutPromise)(this.timeoutDuration);\n        void this.timeout.then(async () => {\n            var _a, _b, _c, _d, _e, _f;\n            await ((_b = (_a = this.state.hooks) === null || _a === void 0 ? void 0 : _a.afterMemoization) === null || _b === void 0 ? void 0 : _b.call(_a));\n            await ((_d = (_c = this.state.hooks) === null || _c === void 0 ? void 0 : _c.beforeExecution) === null || _d === void 0 ? void 0 : _d.call(_c));\n            await ((_f = (_e = this.state.hooks) === null || _e === void 0 ? void 0 : _e.afterExecution) === null || _f === void 0 ? void 0 : _f.call(_e));\n            state.setCheckpoint({\n                type: \"step-not-found\",\n                step: {\n                    id: this.options.requestedRunStep,\n                    op: types_js_1.StepOpCode.StepNotFound,\n                },\n            });\n        });\n    }\n    async initializeMiddleware() {\n        const ctx = this.options.data;\n        const hooks = await (0, InngestMiddleware_js_1.getHookStack)(this.options.fn[\"middleware\"], \"onFunctionRun\", {\n            ctx,\n            fn: this.options.fn,\n            steps: Object.values(this.options.stepState),\n            reqArgs: this.options.reqArgs,\n        }, {\n            transformInput: (prev, output) => {\n                return {\n                    ctx: Object.assign(Object.assign({}, prev.ctx), output === null || output === void 0 ? void 0 : output.ctx),\n                    fn: this.options.fn,\n                    steps: prev.steps.map((step, i) => {\n                        var _a;\n                        return (Object.assign(Object.assign({}, step), (_a = output === null || output === void 0 ? void 0 : output.steps) === null || _a === void 0 ? void 0 : _a[i]));\n                    }),\n                    reqArgs: prev.reqArgs,\n                };\n            },\n            transformOutput: (prev, output) => {\n                return {\n                    result: Object.assign(Object.assign({}, prev.result), output === null || output === void 0 ? void 0 : output.result),\n                    step: prev.step,\n                };\n            },\n        });\n        return hooks;\n    }\n}\nconst hashId = (id) => {\n    return (0, hash_js_1.sha1)().update(id).digest(\"hex\");\n};\nconst hashOp = (op) => {\n    return Object.assign(Object.assign({}, op), { id: hashId(op.id) });\n};\n/**\n * Exported for testing.\n */\nexports._internals = { hashOp, hashId };\n//# sourceMappingURL=v2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9jb21wb25lbnRzL2V4ZWN1dGlvbi92Mi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsZ0NBQWdDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxzRkFBb0I7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMseURBQVM7QUFDbkMsY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLCtFQUF5QjtBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQywrRUFBeUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMscUZBQTRCO0FBQzNELHNCQUFzQixtQkFBTyxDQUFDLG1GQUEyQjtBQUN6RCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBZ0I7QUFDM0MscUJBQXFCLG1CQUFPLENBQUMsaUVBQWtCO0FBQy9DLCtCQUErQixtQkFBTyxDQUFDLDZGQUF5QjtBQUNoRSw4QkFBOEIsbUJBQU8sQ0FBQywyRkFBd0I7QUFDOUQsK0JBQStCLG1CQUFPLENBQUMsNkZBQXlCO0FBQ2hFLDZCQUE2QixtQkFBTyxDQUFDLHlGQUF1QjtBQUM1RCx1QkFBdUIsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDaEQsOEJBQThCLG1CQUFPLENBQUMsb0dBQXVCO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLDBFQUFVO0FBQ25DLG9CQUFvQixtQkFBTyxDQUFDLDBGQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHNDQUFzQyw4QkFBOEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQywyQ0FBMkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLHlDQUF5QztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx1QkFBdUI7QUFDM0UsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHlCQUF5QjtBQUM3RSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixpQkFBaUIsNEJBQTRCO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLGlCQUFpQiw4QkFBOEI7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxNQUFNO0FBQ3ZDLHlCQUF5QjtBQUN6QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCw4R0FBOEcsTUFBTSxrREFBa0Q7QUFDeE47QUFDQSxhQUFhO0FBQ2IsK1FBQStRO0FBQy9RLGlEQUFpRCxXQUFXLG9DQUFvQyxnQkFBZ0IsdUNBQXVDLDhHQUE4RyxpQkFBaUIsR0FBRztBQUN6UixTQUFTO0FBQ1Q7QUFDQSx3QkFBd0Isa0NBQWtDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGlEQUFpRCxpQkFBaUIsTUFBTTtBQUN4RSxTQUFTO0FBQ1Q7QUFDQSxpREFBaUQsaUJBQWlCO0FBQ2xFO0FBQ0EsdUJBQXVCO0FBQ3ZCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVDQUF1QyxpQ0FBaUM7QUFDeEUsU0FBUztBQUNUO0FBQ0E7QUFDQSx1Q0FBdUMsa0NBQWtDO0FBQ3pFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsY0FBYyxnQ0FBZ0M7QUFDOUQ7QUFDQTtBQUNBLHdDQUF3QyxvQ0FBb0MsUUFBUSxJQUFJLE1BQU07QUFDOUYsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNkJBQTZCO0FBQ2hELGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCx3QkFBd0IsTUFBTTtBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBLGtEQUFrRCxZQUFZLDJEQUEyRDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsc0JBQXNCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLGlFQUFpRTtBQUMvSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiwyQkFBMkI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLGtEQUFrRCxzQkFBc0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxXQUFXLG9DQUFvQztBQUN0RztBQUNBO0FBQ0Esb0ZBQW9GLFFBQVEsdUZBQXVGO0FBQ25MO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTLG1CQUFtQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixLQUFLO0FBQ3ZCIiwic291cmNlcyI6WyIvVXNlcnMvaGFyc2hzaHJpdmFzdGF2L0Rlc2t0b3AvQ29kaW5nIFByb2plY3RzL0pvYi1Bc3Npc3RhbnQtQWdlbnQvbm9kZV9tb2R1bGVzL2lubmdlc3QvY29tcG9uZW50cy9leGVjdXRpb24vdjIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hc3luY1ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX19hc3luY1ZhbHVlcykgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XG59O1xudmFyIF9fYXdhaXQgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXQpIHx8IGZ1bmN0aW9uICh2KSB7IHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpOyB9XG52YXIgX19hc3luY0dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19hc3luY0dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICAgIGZ1bmN0aW9uIGF3YWl0UmV0dXJuKGYpIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUodikudGhlbihmLCByZWplY3QpOyB9OyB9XG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlmIChnW25dKSB7IGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IGlmIChmKSBpW25dID0gZihpW25dKTsgfSB9XG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuX2ludGVybmFscyA9IGV4cG9ydHMuY3JlYXRlVjJJbm5nZXN0RXhlY3V0aW9uID0gdm9pZCAwO1xuY29uc3QgYXBpXzEgPSByZXF1aXJlKFwiQG9wZW50ZWxlbWV0cnkvYXBpXCIpO1xuY29uc3QgaGFzaF9qc18xID0gcmVxdWlyZShcImhhc2guanNcIik7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9oZWxwZXJzL2NvbnN0cy5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvZXJyb3JzLmpzXCIpO1xuY29uc3QgZnVuY3Rpb25zX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vaGVscGVycy9mdW5jdGlvbnMuanNcIik7XG5jb25zdCBwcm9taXNlc19qc18xID0gcmVxdWlyZShcIi4uLy4uL2hlbHBlcnMvcHJvbWlzZXMuanNcIik7XG5jb25zdCB0eXBlc19qc18xID0gcmVxdWlyZShcIi4uLy4uL3R5cGVzLmpzXCIpO1xuY29uc3QgdmVyc2lvbl9qc18xID0gcmVxdWlyZShcIi4uLy4uL3ZlcnNpb24uanNcIik7XG5jb25zdCBJbm5nZXN0TWlkZGxld2FyZV9qc18xID0gcmVxdWlyZShcIi4uL0lubmdlc3RNaWRkbGV3YXJlLmpzXCIpO1xuY29uc3QgSW5uZ2VzdFN0ZXBUb29sc19qc18xID0gcmVxdWlyZShcIi4uL0lubmdlc3RTdGVwVG9vbHMuanNcIik7XG5jb25zdCBOb25SZXRyaWFibGVFcnJvcl9qc18xID0gcmVxdWlyZShcIi4uL05vblJldHJpYWJsZUVycm9yLmpzXCIpO1xuY29uc3QgUmV0cnlBZnRlckVycm9yX2pzXzEgPSByZXF1aXJlKFwiLi4vUmV0cnlBZnRlckVycm9yLmpzXCIpO1xuY29uc3QgU3RlcEVycm9yX2pzXzEgPSByZXF1aXJlKFwiLi4vU3RlcEVycm9yLmpzXCIpO1xuY29uc3QgSW5uZ2VzdEV4ZWN1dGlvbl9qc18xID0gcmVxdWlyZShcIi4vSW5uZ2VzdEV4ZWN1dGlvbi5qc1wiKTtcbmNvbnN0IGFsc19qc18xID0gcmVxdWlyZShcIi4vYWxzLmpzXCIpO1xuY29uc3QgYWNjZXNzX2pzXzEgPSByZXF1aXJlKFwiLi9vdGVsL2FjY2Vzcy5qc1wiKTtcbmNvbnN0IGNyZWF0ZVYySW5uZ2VzdEV4ZWN1dGlvbiA9IChvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBWMklubmdlc3RFeGVjdXRpb24ob3B0aW9ucyk7XG59O1xuZXhwb3J0cy5jcmVhdGVWMklubmdlc3RFeGVjdXRpb24gPSBjcmVhdGVWMklubmdlc3RFeGVjdXRpb247XG5jbGFzcyBWMklubmdlc3RFeGVjdXRpb24gZXh0ZW5kcyBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuSW5uZ2VzdEV4ZWN1dGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgdGhpcy50aW1lb3V0RHVyYXRpb24gPSAxMDAwICogMTA7XG4gICAgICAgIHRoaXMudXNlckZuVG9SdW4gPSB0aGlzLmdldFVzZXJGblRvUnVuKCk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmNyZWF0ZUV4ZWN1dGlvblN0YXRlKCk7XG4gICAgICAgIHRoaXMuZm5BcmcgPSB0aGlzLmNyZWF0ZUZuQXJnKCk7XG4gICAgICAgIHRoaXMuY2hlY2twb2ludEhhbmRsZXJzID0gdGhpcy5jcmVhdGVDaGVja3BvaW50SGFuZGxlcnMoKTtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplVGltZXIodGhpcy5zdGF0ZSk7XG4gICAgICAgIHRoaXMuZGVidWcoXCJjcmVhdGVkIG5ldyBWMiBleGVjdXRpb24gZm9yIHJ1bjtcIiwgdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXBcbiAgICAgICAgICAgID8gYHdhbnRpbmcgdG8gcnVuIHN0ZXAgXCIke3RoaXMub3B0aW9ucy5yZXF1ZXN0ZWRSdW5TdGVwfVwiYFxuICAgICAgICAgICAgOiBcImRpc2NvdmVyaW5nIHN0ZXBzXCIpO1xuICAgICAgICB0aGlzLmRlYnVnKFwiZXhpc3Rpbmcgc3RhdGUga2V5czpcIiwgT2JqZWN0LmtleXModGhpcy5zdGF0ZS5zdGVwU3RhdGUpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWRlbXBvdGVudGx5IHN0YXJ0IHRoZSBleGVjdXRpb24gb2YgdGhlIHVzZXIncyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmV4ZWN1dGlvbikge1xuICAgICAgICAgICAgdGhpcy5kZWJ1ZyhcInN0YXJ0aW5nIFYyIGV4ZWN1dGlvblwiKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNlciA9IGFwaV8xLnRyYWNlLmdldFRyYWNlcihcImlubmdlc3RcIiwgdmVyc2lvbl9qc18xLnZlcnNpb24pO1xuICAgICAgICAgICAgdGhpcy5leGVjdXRpb24gPSAoMCwgYWxzX2pzXzEuZ2V0QXN5bmNMb2NhbFN0b3JhZ2UpKCkudGhlbigoYWxzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFscy5ydW4oeyBhcHA6IHRoaXMub3B0aW9ucy5jbGllbnQsIGN0eDogdGhpcy5mbkFyZyB9LCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFjZXIuc3RhcnRBY3RpdmVTcGFuKFwiaW5uZ2VzdC5leGVjdXRpb25cIiwgKHNwYW4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGFjY2Vzc19qc18xLmNsaWVudFByb2Nlc3Nvck1hcC5nZXQodGhpcy5vcHRpb25zLmNsaWVudCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZWNsYXJlU3RhcnRpbmdTcGFuKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bklkOiB0aGlzLm9wdGlvbnMucnVuSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2VwYXJlbnQ6IHRoaXMub3B0aW9ucy5oZWFkZXJzW2NvbnN0c19qc18xLmhlYWRlcktleXMuVHJhY2VQYXJlbnRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlc3RhdGU6IHRoaXMub3B0aW9ucy5oZWFkZXJzW2NvbnN0c19qc18xLmhlYWRlcktleXMuVHJhY2VTdGF0ZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFydCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJyZXN1bHQ6XCIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5leGVjdXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0cyBleGVjdXRpb24gb2YgdGhlIHVzZXIncyBmdW5jdGlvbiBhbmQgdGhlIGNvcmUgbG9vcC5cbiAgICAgKi9cbiAgICBhc3luYyBfc3RhcnQoKSB7XG4gICAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICAgIHZhciBfZCwgX2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBhbGxDaGVja3BvaW50SGFuZGxlciA9IHRoaXMuZ2V0Q2hlY2twb2ludEhhbmRsZXIoXCJcIik7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLmhvb2tzID0gYXdhaXQgdGhpcy5pbml0aWFsaXplTWlkZGxld2FyZSgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zdGFydEV4ZWN1dGlvbigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBfZiA9IHRydWUsIF9nID0gX19hc3luY1ZhbHVlcyh0aGlzLnN0YXRlLmxvb3ApLCBfaDsgX2ggPSBhd2FpdCBfZy5uZXh0KCksIF9hID0gX2guZG9uZSwgIV9hOyBfZiA9IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgX2MgPSBfaC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hlY2twb2ludCA9IF9jO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCBhbGxDaGVja3BvaW50SGFuZGxlcihjaGVja3BvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuZ2V0Q2hlY2twb2ludEhhbmRsZXIoY2hlY2twb2ludC50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgaGFuZGxlcihjaGVja3BvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9mICYmICFfYSAmJiAoX2IgPSBfZy5yZXR1cm4pKSBhd2FpdCBfYi5jYWxsKF9nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMudHJhbnNmb3JtT3V0cHV0KHsgZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB2b2lkIHRoaXMuc3RhdGUubG9vcC5yZXR1cm4oKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2UgPSAoX2QgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYmVmb3JlUmVzcG9uc2UpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5jYWxsKF9kKSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIGhlcmUsIHRoZSBnZW5lcmF0b3Igc29tZWhvdyBmaW5pc2hlZCB3aXRob3V0IHJldHVybmluZyBhIHZhbHVlLlxuICAgICAgICAgKiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb3JlIGxvb3AgZmluaXNoZWQgd2l0aG91dCByZXR1cm5pbmcgYSB2YWx1ZVwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhbmRsZXIgZm9yIGV2ZXJ5IGNoZWNrcG9pbnQgdHlwZSwgZGVmaW5pbmcgd2hhdCB0byBkbyB3aGVuIHdlXG4gICAgICogcmVhY2ggdGhhdCBjaGVja3BvaW50IGluIHRoZSBjb3JlIGxvb3AuXG4gICAgICovXG4gICAgY3JlYXRlQ2hlY2twb2ludEhhbmRsZXJzKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSdW4gZm9yIGFsbCBjaGVja3BvaW50cy4gQmVzdCB1c2VkIGZvciBsb2dnaW5nIG9yIGNvbW1vbiBhY3Rpb25zLlxuICAgICAgICAgICAgICogVXNlIG90aGVyIGhhbmRsZXJzIHRvIHJldHVybiB2YWx1ZXMgYW5kIGludGVycnVwdCB0aGUgY29yZSBsb29wLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcIlwiOiAoY2hlY2twb2ludCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVidWcoXCJjaGVja3BvaW50OlwiLCBjaGVja3BvaW50KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB1c2VyJ3MgZnVuY3Rpb24gaGFzIGNvbXBsZXRlZCBhbmQgcmV0dXJuZWQgYSB2YWx1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmdW5jdGlvbi1yZXNvbHZlZFwiOiBhc3luYyAoY2hlY2twb2ludCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGRhdGE6IGNoZWNrcG9pbnQuZGF0YSB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoZSB1c2VyJ3MgZnVuY3Rpb24gaGFzIHRocm93biBhbiBlcnJvci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgXCJmdW5jdGlvbi1yZWplY3RlZFwiOiBhc3luYyAoY2hlY2twb2ludCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnRyYW5zZm9ybU91dHB1dCh7IGVycm9yOiBjaGVja3BvaW50LmVycm9yIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2UndmUgZm91bmQgb25lIG9yIG1vcmUgc3RlcHMuIEhlcmUgd2UgbWF5IHdhbnQgdG8gcnVuIGEgc3RlcCBvciByZXBvcnRcbiAgICAgICAgICAgICAqIHRoZW0gYmFjayB0byBJbm5nZXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBcInN0ZXBzLWZvdW5kXCI6IGFzeW5jICh7IHN0ZXBzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGVwUmVzdWx0ID0gYXdhaXQgdGhpcy50cnlFeGVjdXRlU3RlcChzdGVwcyk7XG4gICAgICAgICAgICAgICAgaWYgKHN0ZXBSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtUmVzdWx0ID0gYXdhaXQgdGhpcy50cmFuc2Zvcm1PdXRwdXQoc3RlcFJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUcmFuc2Zvcm1pbmcgb3V0cHV0IHdpbGwgYWx3YXlzIHJldHVybiBlaXRoZXIgZnVuY3Rpb24gcmVqZWN0aW9uIG9yXG4gICAgICAgICAgICAgICAgICAgICAqIHJlc29sdXRpb24uIEluIG1vc3QgY2FzZXMsIHRoaXMgY2FuIGJlIGltbWVkaWF0ZWx5IHJldHVybmVkLCBidXQgaW5cbiAgICAgICAgICAgICAgICAgICAgICogdGhpcyBwYXJ0aWN1bGFyIGNhc2Ugd2Ugd2FudCB0byBoYW5kbGUgaXQgZGlmZmVyZW50bHkuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtUmVzdWx0LnR5cGUgPT09IFwiZnVuY3Rpb24tcmVzb2x2ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtcmFuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4OiB0cmFuc2Zvcm1SZXN1bHQuY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wczogdHJhbnNmb3JtUmVzdWx0Lm9wcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwOiBleHBvcnRzLl9pbnRlcm5hbHMuaGFzaE9wKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcFJlc3VsdCksIHsgZGF0YTogdHJhbnNmb3JtUmVzdWx0LmRhdGEgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0cmFuc2Zvcm1SZXN1bHQudHlwZSA9PT0gXCJmdW5jdGlvbi1yZWplY3RlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcC1yYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdHg6IHRyYW5zZm9ybVJlc3VsdC5jdHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BzOiB0cmFuc2Zvcm1SZXN1bHQub3BzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0ZXA6IGV4cG9ydHMuX2ludGVybmFscy5oYXNoT3AoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdGVwUmVzdWx0KSwgeyBlcnJvcjogdHJhbnNmb3JtUmVzdWx0LmVycm9yIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXRyaWFibGU6IHRyYW5zZm9ybVJlc3VsdC5yZXRyaWFibGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1SZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0ZXBzID0gYXdhaXQgdGhpcy5maWx0ZXJOZXdTdGVwcyhBcnJheS5mcm9tKHRoaXMuc3RhdGUuc3RlcHMudmFsdWVzKCkpKTtcbiAgICAgICAgICAgICAgICBpZiAobmV3U3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RlcHMtZm91bmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eDogdGhpcy5mbkFyZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wczogdGhpcy5vcHMsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwczogbmV3U3RlcHMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hpbGUgdHJ5aW5nIHRvIGZpbmQgYSBzdGVwIHRoYXQgSW5uZ2VzdCBoYXMgdG9sZCB1cyB0byBydW4sIHdlJ3ZlXG4gICAgICAgICAgICAgKiB0aW1lZCBvdXQgb3IgaGF2ZSBvdGhlcndpc2UgZGVjaWRlZCB0aGF0IGl0IGRvZXNuJ3QgZXhpc3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIFwic3RlcC1ub3QtZm91bmRcIjogKHsgc3RlcCB9KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJzdGVwLW5vdC1mb3VuZFwiLCBjdHg6IHRoaXMuZm5BcmcsIG9wczogdGhpcy5vcHMsIHN0ZXAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldENoZWNrcG9pbnRIYW5kbGVyKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hlY2twb2ludEhhbmRsZXJzW3R5cGVdO1xuICAgIH1cbiAgICBhc3luYyB0cnlFeGVjdXRlU3RlcChzdGVwcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGhhc2hlZFN0ZXBJZFRvUnVuID0gdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXAgfHwgdGhpcy5nZXRFYXJseUV4ZWNSdW5TdGVwKHN0ZXBzKTtcbiAgICAgICAgaWYgKCFoYXNoZWRTdGVwSWRUb1J1bikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwcy5maW5kKChzdGVwKSA9PiBzdGVwLmhhc2hlZElkID09PSBoYXNoZWRTdGVwSWRUb1J1biAmJiBzdGVwLmZuKTtcbiAgICAgICAgaWYgKHN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmV4ZWN1dGVTdGVwKHN0ZXApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbnN1cmUgd2UgcmVzZXQgdGhlIHRpbWVvdXQgaWYgd2UgaGF2ZSBhIHJlcXVlc3RlZCBydW4gc3RlcCBidXQgY291bGRuJ3RcbiAgICAgICAgICogZmluZCBpdCwgYnV0IGFsc28gdGhhdCB3ZSBkb24ndCByZXNldCBpZiB3ZSBmb3VuZCBhbmQgZXhlY3V0ZWQgaXQuXG4gICAgICAgICAqL1xuICAgICAgICB2b2lkICgoX2EgPSB0aGlzLnRpbWVvdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNldCgpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBsaXN0IG9mIG91dGdvaW5nIG9wcywgZGVjaWRlIGlmIHdlIGNhbiBleGVjdXRlIGFuIG9wIGVhcmx5IGFuZFxuICAgICAqIHJldHVybiB0aGUgSUQgb2YgdGhlIHN0ZXAgdG8gZXhlY3V0ZSBpZiB3ZSBjYW4uXG4gICAgICovXG4gICAgZ2V0RWFybHlFeGVjUnVuU3RlcChzdGVwcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogV2UgbWF5IGhhdmUgYmVlbiBkaXNhYmxlZCBkdWUgdG8gcGFyYWxsZWxpc20sIGluIHdoaWNoIGNhc2Ugd2UgY2FuJ3RcbiAgICAgICAgICogaW1tZWRpYXRlbHkgZXhlY3V0ZSB1bmxlc3MgZXhwbGljaXRseSByZXF1ZXN0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVJbW1lZGlhdGVFeGVjdXRpb24pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHVuZnVsZmlsbGVkU3RlcHMgPSBzdGVwcy5maWx0ZXIoKHN0ZXApID0+ICFzdGVwLmZ1bGZpbGxlZCk7XG4gICAgICAgIGlmICh1bmZ1bGZpbGxlZFN0ZXBzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3AgPSB1bmZ1bGZpbGxlZFN0ZXBzWzBdO1xuICAgICAgICBpZiAob3AgJiZcbiAgICAgICAgICAgIG9wLm9wID09PSB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcFBsYW5uZWRcbiAgICAgICAgLy8gVE9ETyBXZSBtdXN0IGluZGl2aWR1YWxseSBjaGVjayBwcm9wZXJ0aWVzIGhlcmUgdGhhdCB3ZSBkbyBub3Qgd2FudCB0b1xuICAgICAgICAvLyBleGVjdXRlIG9uLCBzdWNoIGFzIHJldHJ5IGNvdW50cy4gTm90aGluZyBleGlzdHMgaGVyZSB0aGF0IGZhbGxzIGluIHRvXG4gICAgICAgIC8vIHRoaXMgY2FzZSwgYnV0IHNob3VsZCBiZSBhY2NvdW50ZWQgZm9yIHdoZW4gd2UgYWRkIHRoZW0uXG4gICAgICAgIC8vICYmIHR5cGVvZiBvcC5vcHRzID09PSBcInVuZGVmaW5lZFwiXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIG9wLmhhc2hlZElkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZpbHRlck5ld1N0ZXBzKGZvdW5kU3RlcHMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHYXRoZXIgYW55IHN0ZXBzIHRoYXQgYXJlbid0IG1lbW9pemVkIGFuZCByZXBvcnQgdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IG5ld1N0ZXBzID0gZm91bmRTdGVwcy5maWx0ZXIoKHN0ZXApID0+ICFzdGVwLmZ1bGZpbGxlZCk7XG4gICAgICAgIGlmICghbmV3U3RlcHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdhcm4gaWYgd2UndmUgZm91bmQgbmV3IHN0ZXBzIGJ1dCBoYXZlbid0IHlldCBzZWVuIGFsbCBwcmV2aW91c1xuICAgICAgICAgKiBzdGVwcy4gVGhpcyBtYXkgaW5kaWNhdGUgdGhhdCBzdGVwIHByZXNlbmNlIGlzbid0IGRldGVybWluYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGtub3duU3RlcHMgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHN0ZXAgb2YgZm91bmRTdGVwcykge1xuICAgICAgICAgICAgaWYgKHN0ZXAuZnVsZmlsbGVkKSB7XG4gICAgICAgICAgICAgICAga25vd25TdGVwcysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvdW5kQWxsQ29tcGxldGVkU3RlcHMgPSB0aGlzLnN0YXRlLnN0ZXBzVG9GdWxmaWxsID09PSBrbm93blN0ZXBzO1xuICAgICAgICBpZiAoIWZvdW5kQWxsQ29tcGxldGVkU3RlcHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gVGFnXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ3YXJuXCIsXG4gICAgICAgICAgICAgICAgd2hhdEhhcHBlbmVkOiBcIkZ1bmN0aW9uIG1heSBiZSBpbmRldGVybWluYXRlXCIsXG4gICAgICAgICAgICAgICAgd2h5OiBcIldlIGZvdW5kIG5ldyBzdGVwcyBiZWZvcmUgc2VlaW5nIGFsbCBwcmV2aW91cyBzdGVwcywgd2hpY2ggbWF5IGluZGljYXRlIHRoYXQgdGhlIGZ1bmN0aW9uIGlzIG5vbi1kZXRlcm1pbmlzdGljLlwiLFxuICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJUaGlzIG1heSBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ciBhcyBJbm5nZXN0IGV4ZWN1dGVzIHlvdXIgZnVuY3Rpb24uXCIsXG4gICAgICAgICAgICAgICAgcmVhc3N1cmFuY2U6IFwiVGhpcyBpcyBleHBlY3RlZCBpZiBhIGZ1bmN0aW9uIGlzIHVwZGF0ZWQgaW4gdGhlIG1pZGRsZSBvZiBhIHJ1biwgYnV0IG1heSBpbmRpY2F0ZSBhIGJ1ZyBpZiBub3QuXCIsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlJ3JlIGZpbmlzaGluZyB1cDsgbGV0J3MgdHJpZ2dlciB0aGUgbGFzdCBvZiB0aGUgaG9va3MuXG4gICAgICAgICAqL1xuICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYykpO1xuICAgICAgICBhd2FpdCAoKF9mID0gKF9lID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmFmdGVyRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSkpO1xuICAgICAgICBjb25zdCBzdGVwTGlzdCA9IG5ld1N0ZXBzLm1hcCgoc3RlcCkgPT4gKHtcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBzdGVwLmRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgb3A6IHN0ZXAub3AsXG4gICAgICAgICAgICBpZDogc3RlcC5oYXNoZWRJZCxcbiAgICAgICAgICAgIG5hbWU6IHN0ZXAubmFtZSxcbiAgICAgICAgICAgIG9wdHM6IHN0ZXAub3B0cyxcbiAgICAgICAgfSkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2UgYWxzbyBydW4gYG9uU2VuZEV2ZW50YCBtaWRkbGV3YXJlIGhvb2tzIGFnYWluc3QgYHN0ZXAuaW52b2tlKClgIHN0ZXBzXG4gICAgICAgICAqIHRvIGVuc3VyZSB0aGF0IHRoZWlyIGBkYXRhYCBpcyB0cmFuc2Zvcm1lZCBjb3JyZWN0bHkuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy50cmFuc2Zvcm1OZXdTdGVwcyhzdGVwTGlzdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzaW5nIG1pZGRsZXdhcmUsIHRyYW5zZm9ybSBhbnkgbmV3bHktZm91bmQgc3RlcHMgYmVmb3JlIHJldHVybmluZyB0aGVtIHRvXG4gICAgICogYW4gSW5uZ2VzdCBTZXJ2ZXIuXG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNmb3JtTmV3U3RlcHMoc3RlcHMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHN0ZXBzLm1hcChhc3luYyAoc3RlcCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgICAgaWYgKHN0ZXAub3AgIT09IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5JbnZva2VGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb25TZW5kRXZlbnRIb29rcyA9IGF3YWl0ICgwLCBJbm5nZXN0TWlkZGxld2FyZV9qc18xLmdldEhvb2tTdGFjaykodGhpcy5vcHRpb25zLmZuW1wibWlkZGxld2FyZVwiXSwgXCJvblNlbmRFdmVudFwiLCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1JbnB1dDogKHByZXYsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2KSwgb3V0cHV0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU91dHB1dDogKHByZXYsIG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHByZXYucmVzdWx0KSwgb3V0cHV0ID09PSBudWxsIHx8IG91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3V0cHV0LnJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGb3IgZWFjaCBldmVudCBiZWluZyBzZW50LCBjcmVhdGUgYSBuZXcgYG9uU2VuZEV2ZW50YCBob29rIHN0YWNrIHRvXG4gICAgICAgICAgICAgKiBwcm9jZXNzIGl0LiBXZSBkbyB0aGlzIGFzIG1pZGRsZXdhcmUgaG9va3MgYXJlIGludGVuZGVkIHRvIHJ1biBvbmNlXG4gICAgICAgICAgICAgKiBkdXJpbmcgZWFjaCBsaWZlY3ljbGUgKG9uRnVuY3Rpb25SdW4gb3Igb25TZW5kRXZlbnQpIGFuZCBoZXJlLCBhIGhvb2tcbiAgICAgICAgICAgICAqIGlzIHJ1biBmb3IgZXZlcnkgc2luZ2xlIGV2ZW50LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoaXMgaXMgZG9uZSBiZWNhdXNlIGEgZGV2ZWxvcGVyIGNhbiB1c2UgdGhpcyBob29rIHRvIGZpbHRlciBvdXRcbiAgICAgICAgICAgICAqIGV2ZW50cyBlbnRpcmVseTsgaWYgd2UgYmF0Y2ggYWxsIG9mIHRoZSBldmVudHMgdG9nZXRoZXIsIHdlIGNhbid0XG4gICAgICAgICAgICAgKiB0ZWxsIHdoaWNoIG9uZXMgd2VyZSBmaWx0ZXJlZCBvdXQgaWYgd2UncmUgcHJvY2Vzc2luZyA+MSBpbnZvY2F0aW9uXG4gICAgICAgICAgICAgKiBoZXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZFBheWxvYWQgPSBhd2FpdCAoKF9hID0gb25TZW5kRXZlbnRIb29rcy50cmFuc2Zvcm1JbnB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob25TZW5kRXZlbnRIb29rcywge1xuICAgICAgICAgICAgICAgIHBheWxvYWRzOiBbXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKChfYyA9IChfYiA9IHN0ZXAub3B0cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnBheWxvYWQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHt9KSksIHsgbmFtZTogY29uc3RzX2pzXzEuaW50ZXJuYWxFdmVudHMuRnVuY3Rpb25JbnZva2VkIH0pLFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjb25zdCBuZXdQYXlsb2FkID0gSW5uZ2VzdFN0ZXBUb29sc19qc18xLmludm9rZVBheWxvYWRTY2hlbWEucGFyc2UoKF9lID0gKF9kID0gdHJhbnNmb3JtZWRQYXlsb2FkID09PSBudWxsIHx8IHRyYW5zZm9ybWVkUGF5bG9hZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtZWRQYXlsb2FkLnBheWxvYWRzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RbMF0pICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IHt9KTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0ZXApLCB7IG9wdHM6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcC5vcHRzKSwgeyBwYXlsb2FkOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgoX2cgPSAoX2YgPSBzdGVwLm9wdHMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5wYXlsb2FkKSAhPT0gbnVsbCAmJiBfZyAhPT0gdm9pZCAwID8gX2cgOiB7fSkpLCBuZXdQYXlsb2FkKSB9KSB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBhc3luYyBleGVjdXRlU3RlcCh7IGlkLCBuYW1lLCBvcHRzLCBmbiwgZGlzcGxheU5hbWUsIH0pIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgKF9hID0gdGhpcy50aW1lb3V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xlYXIoKTtcbiAgICAgICAgYXdhaXQgKChfYyA9IChfYiA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYikpO1xuICAgICAgICBhd2FpdCAoKF9lID0gKF9kID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QpKTtcbiAgICAgICAgY29uc3Qgb3V0Z29pbmdPcCA9IHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwUnVuLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG9wdHMsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5zdGF0ZS5leGVjdXRpbmdTdGVwID0gb3V0Z29pbmdPcDtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSBhd2FpdCAoMCwgYWxzX2pzXzEuZ2V0QXN5bmNDdHgpKCk7XG4gICAgICAgIGlmIChzdG9yZSkge1xuICAgICAgICAgICAgc3RvcmUuZXhlY3V0aW5nU3RlcCA9IHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBkaXNwbGF5TmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZWJ1ZyhgZXhlY3V0aW5nIHN0ZXAgXCIke2lkfVwiYCk7XG4gICAgICAgIHJldHVybiAoKDAsIHByb21pc2VzX2pzXzEucnVuQXNQcm9taXNlKShmbilcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgICAgICAgICAgLmZpbmFsbHkoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGlmIChzdG9yZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdG9yZS5leGVjdXRpbmdTdGVwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZnRlckV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdXRnb2luZ09wKSwgeyBkYXRhIH0pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3V0Z29pbmdPcCksIHsgb3A6IHR5cGVzX2pzXzEuU3RlcE9wQ29kZS5TdGVwRXJyb3IsIFxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICBlcnJvciB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydHMgZXhlY3V0aW9uIG9mIHRoZSB1c2VyJ3MgZnVuY3Rpb24sIGluY2x1ZGluZyB0cmlnZ2VyaW5nIGNoZWNrcG9pbnRzXG4gICAgICogYW5kIG1pZGRsZXdhcmUgaG9va3Mgd2hlcmUgYXBwcm9wcmlhdGUuXG4gICAgICovXG4gICAgYXN5bmMgc3RhcnRFeGVjdXRpb24oKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE11dGF0ZSBpbnB1dCBhcyBuZWNjZXNzYXJ5IGJhc2VkIG9uIG1pZGRsZXdhcmUuXG4gICAgICAgICAqL1xuICAgICAgICBhd2FpdCB0aGlzLnRyYW5zZm9ybUlucHV0KCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTdGFydCB0aGUgdGltZXIgdG8gdGltZSBvdXQgdGhlIHJ1biBpZiBuZWVkZWQuXG4gICAgICAgICAqL1xuICAgICAgICB2b2lkICgoX2EgPSB0aGlzLnRpbWVvdXQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydCgpKTtcbiAgICAgICAgYXdhaXQgKChfYyA9IChfYiA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5iZWZvcmVNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlIGhhZCBubyBzdGF0ZSB0byBiZWdpbiB3aXRoLCBpbW1lZGlhdGVseSBlbmQgdGhlIG1lbW9pemF0aW9uIHBoYXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuYWxsU3RhdGVVc2VkKCkpIHtcbiAgICAgICAgICAgIGF3YWl0ICgoX2UgPSAoX2QgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QpKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2cgPSAoX2YgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuYmVmb3JlRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2cuY2FsbChfZikpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmlnZ2VyIHRoZSB1c2VyJ3MgZnVuY3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICAoMCwgcHJvbWlzZXNfanNfMS5ydW5Bc1Byb21pc2UpKCgpID0+IHRoaXMudXNlckZuVG9SdW4odGhpcy5mbkFyZykpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXNcbiAgICAgICAgICAgIC5maW5hbGx5KGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hZnRlck1lbW9pemF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9mID0gKF9lID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmFmdGVyRXhlY3V0aW9uKSA9PT0gbnVsbCB8fCBfZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2YuY2FsbChfZSkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2hlY2twb2ludCh7IHR5cGU6IFwiZnVuY3Rpb24tcmVzb2x2ZWRcIiwgZGF0YSB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2V0Q2hlY2twb2ludCh7IHR5cGU6IFwiZnVuY3Rpb24tcmVqZWN0ZWRcIiwgZXJyb3IgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2luZyBtaWRkbGV3YXJlLCB0cmFuc2Zvcm0gaW5wdXQgYmVmb3JlIHJ1bm5pbmcuXG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNmb3JtSW5wdXQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IGlucHV0TXV0YXRpb25zID0gYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmFuc2Zvcm1JbnB1dCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHtcbiAgICAgICAgICAgIGN0eDogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbkFyZyksXG4gICAgICAgICAgICBzdGVwczogT2JqZWN0LnZhbHVlcyh0aGlzLnN0YXRlLnN0ZXBTdGF0ZSksXG4gICAgICAgICAgICBmbjogdGhpcy5vcHRpb25zLmZuLFxuICAgICAgICAgICAgcmVxQXJnczogdGhpcy5vcHRpb25zLnJlcUFyZ3MsXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKGlucHV0TXV0YXRpb25zID09PSBudWxsIHx8IGlucHV0TXV0YXRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dE11dGF0aW9ucy5jdHgpIHtcbiAgICAgICAgICAgIHRoaXMuZm5BcmcgPSBpbnB1dE11dGF0aW9ucy5jdHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0TXV0YXRpb25zID09PSBudWxsIHx8IGlucHV0TXV0YXRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dE11dGF0aW9ucy5zdGVwcykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zdGVwU3RhdGUgPSBPYmplY3QuZnJvbUVudHJpZXMoaW5wdXRNdXRhdGlvbnMuc3RlcHMubWFwKChzdGVwKSA9PiBbc3RlcC5pZCwgc3RlcF0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2luZyBtaWRkbGV3YXJlLCB0cmFuc2Zvcm0gb3V0cHV0IGJlZm9yZSByZXR1cm5pbmcuXG4gICAgICovXG4gICAgYXN5bmMgdHJhbnNmb3JtT3V0cHV0KGRhdGFPckVycm9yKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbih7fSwgZGF0YU9yRXJyb3IpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UndmUgYmVlbiBnaXZlbiBhbiBlcnJvciBhbmQgaXQncyBvbmUgdGhhdCB3ZSBqdXN0IHRocmV3IGZyb20gYSBzdGVwLFxuICAgICAgICAgKiB3ZSBzaG91bGQgcmV0dXJuIGEgYE5vblJldHJpYWJsZUVycm9yYCB0byBzdG9wIGV4ZWN1dGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0LmVycm9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBvdXRwdXQuZGF0YSA9ICgwLCBlcnJvcnNfanNfMS5zZXJpYWxpemVFcnJvcikob3V0cHV0LmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1N0ZXBFeGVjdXRpb24gPSBCb29sZWFuKHRoaXMuc3RhdGUuZXhlY3V0aW5nU3RlcCk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkT3V0cHV0ID0gYXdhaXQgKChfYiA9IChfYSA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmFuc2Zvcm1PdXRwdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB7XG4gICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oe30sIG91dHB1dCksXG4gICAgICAgICAgICBzdGVwOiB0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXAsXG4gICAgICAgIH0pKTtcbiAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdXRwdXQpLCB0cmFuc2Zvcm1lZE91dHB1dCA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1lZE91dHB1dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtZWRPdXRwdXQucmVzdWx0KTtcbiAgICAgICAgaWYgKCFpc1N0ZXBFeGVjdXRpb24pIHtcbiAgICAgICAgICAgIGF3YWl0ICgoX2QgPSAoX2MgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZmluaXNoZWQpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jLCB7XG4gICAgICAgICAgICAgICAgcmVzdWx0OiBPYmplY3QuYXNzaWduKHt9LCAodHlwZW9mIGVycm9yICE9PSBcInVuZGVmaW5lZFwiID8geyBlcnJvciB9IDogeyBkYXRhIH0pKSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVycm9yICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuc3VyZSB3ZSBnaXZlIG1pZGRsZXdhcmUgdGhlIGNoYW5jZSB0byBkZWNpZGUgb24gcmV0cmlhYmxlIGJlaGF2aW91clxuICAgICAgICAgICAgICogYnkgbG9va2luZyBhdCB0aGUgZXJyb3IgcmV0dXJuZWQgZnJvbSBvdXRwdXQgdHJhbnNmb3JtYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCByZXRyaWFibGUgPSAhKGVycm9yIGluc3RhbmNlb2YgTm9uUmV0cmlhYmxlRXJyb3JfanNfMS5Ob25SZXRyaWFibGVFcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIFN0ZXBFcnJvcl9qc18xLlN0ZXBFcnJvcik7XG4gICAgICAgICAgICBpZiAocmV0cmlhYmxlICYmIGVycm9yIGluc3RhbmNlb2YgUmV0cnlBZnRlckVycm9yX2pzXzEuUmV0cnlBZnRlckVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0cmlhYmxlID0gZXJyb3IucmV0cnlBZnRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRFcnJvciA9ICgwLCBlcnJvcnNfanNfMS5taW5pZnlQcmV0dHlFcnJvcikoKDAsIGVycm9yc19qc18xLnNlcmlhbGl6ZUVycm9yKShlcnJvcikpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uLXJlamVjdGVkXCIsXG4gICAgICAgICAgICAgICAgY3R4OiB0aGlzLmZuQXJnLFxuICAgICAgICAgICAgICAgIG9wczogdGhpcy5vcHMsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHNlcmlhbGl6ZWRFcnJvcixcbiAgICAgICAgICAgICAgICByZXRyaWFibGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uLXJlc29sdmVkXCIsXG4gICAgICAgICAgICBjdHg6IHRoaXMuZm5BcmcsXG4gICAgICAgICAgICBvcHM6IHRoaXMub3BzLFxuICAgICAgICAgICAgZGF0YTogKDAsIGZ1bmN0aW9uc19qc18xLnVuZGVmaW5lZFRvTnVsbCkoZGF0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZUV4ZWN1dGlvblN0YXRlKCkge1xuICAgICAgICBjb25zdCBkID0gKDAsIHByb21pc2VzX2pzXzEuY3JlYXRlRGVmZXJyZWRQcm9taXNlV2l0aFN0YWNrKSgpO1xuICAgICAgICBsZXQgY2hlY2twb2ludFJlc29sdmUgPSBkLmRlZmVycmVkLnJlc29sdmU7XG4gICAgICAgIGNvbnN0IGNoZWNrcG9pbnRSZXN1bHRzID0gZC5yZXN1bHRzO1xuICAgICAgICBjb25zdCBsb29wID0gKGZ1bmN0aW9uIChjbGVhblVwKSB7XG4gICAgICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9ICh5aWVsZCBfX2F3YWl0KGNoZWNrcG9pbnRSZXN1bHRzLm5leHQoKSkpLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHlpZWxkIF9fYXdhaXQocmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW5VcCA9PT0gbnVsbCB8fCBjbGVhblVwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjbGVhblVwKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKCgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudGltZW91dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsZWFyKCk7XG4gICAgICAgICAgICB2b2lkIGNoZWNrcG9pbnRSZXN1bHRzLnJldHVybigpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgc3RlcHNUb0Z1bGZpbGwgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMuc3RlcFN0YXRlKS5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgc3RlcFN0YXRlOiB0aGlzLm9wdGlvbnMuc3RlcFN0YXRlLFxuICAgICAgICAgICAgc3RlcHNUb0Z1bGZpbGwsXG4gICAgICAgICAgICBzdGVwczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgbG9vcCxcbiAgICAgICAgICAgIGhhc1N0ZXBzOiBCb29sZWFuKHN0ZXBzVG9GdWxmaWxsKSxcbiAgICAgICAgICAgIHN0ZXBDb21wbGV0aW9uT3JkZXI6IFsuLi50aGlzLm9wdGlvbnMuc3RlcENvbXBsZXRpb25PcmRlcl0sXG4gICAgICAgICAgICByZW1haW5pbmdTdGVwc1RvQmVTZWVuOiBuZXcgU2V0KHRoaXMub3B0aW9ucy5zdGVwQ29tcGxldGlvbk9yZGVyKSxcbiAgICAgICAgICAgIHNldENoZWNrcG9pbnQ6IChjaGVja3BvaW50KSA9PiB7XG4gICAgICAgICAgICAgICAgKHsgcmVzb2x2ZTogY2hlY2twb2ludFJlc29sdmUgfSA9IGNoZWNrcG9pbnRSZXNvbHZlKGNoZWNrcG9pbnQpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhbGxTdGF0ZVVzZWQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yZW1haW5pbmdTdGVwc1RvQmVTZWVuLnNpemUgPT09IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIGdldCBvcHMoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJvbUVudHJpZXModGhpcy5zdGF0ZS5zdGVwcyk7XG4gICAgfVxuICAgIGNyZWF0ZUZuQXJnKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSB0aGlzLmNyZWF0ZVN0ZXBUb29scygpO1xuICAgICAgICBsZXQgZm5BcmcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucy5kYXRhKSwgeyBzdGVwIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlIHVzZSBvZiB0aGUgYG9uRmFpbHVyZWAgb3B0aW9uIGJ5IGRlc2VyaWFsaXppbmcgdGhlIGVycm9yLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5pc0ZhaWx1cmVIYW5kbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudERhdGEgPSB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7IGVycm9yOiB0eXBlc19qc18xLmpzb25FcnJvclNjaGVtYSB9KVxuICAgICAgICAgICAgICAgIC5wYXJzZSgoX2EgPSBmbkFyZy5ldmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEpO1xuICAgICAgICAgICAgZm5BcmcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZuQXJnKSwgeyBlcnJvcjogKDAsIGVycm9yc19qc18xLmRlc2VyaWFsaXplRXJyb3IpKGV2ZW50RGF0YS5lcnJvcikgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChfZCA9IChfYyA9IChfYiA9IHRoaXMub3B0aW9ucykudHJhbnNmb3JtQ3R4KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FsbChfYiwgZm5BcmcpKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBmbkFyZztcbiAgICB9XG4gICAgY3JlYXRlU3RlcFRvb2xzKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBsaXN0IG9mIHN0ZXBzIHRoYXQgaGF2ZSBiZWVuIGZvdW5kIGFuZCBhcmUgYmVpbmcgcm9sbGVkIHVwIGJlZm9yZSBiZWluZ1xuICAgICAgICAgKiByZXBvcnRlZCB0byB0aGUgY29yZSBsb29wLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgZm91bmRTdGVwc1RvUmVwb3J0ID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgdGhlIHN1YnNldCBvZiBmb3VuZCBzdGVwcyB0byByZXBvcnQgdGhhdCBoYXZlIG5vdCB5ZXQgYmVlblxuICAgICAgICAgKiBoYW5kbGVkLiBVc2VkIGZvciBmYXN0IGFjY2VzcyB0byBzdGVwcyB0aGF0IG5lZWQgdG8gYmUgaGFuZGxlZCBpbiBvcmRlci5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHVuaGFuZGxlZEZvdW5kU3RlcHNUb1JlcG9ydCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbWFwIG9mIHRoZSBsYXRlc3Qgc2VxdWVudGlhbCBzdGVwIGluZGV4ZXMgZm91bmQgZm9yIGVhY2ggc3RlcCBJRC4gVXNlZFxuICAgICAgICAgKiB0byBlbnN1cmUgdGhhdCB3ZSBkb24ndCBpbmRleCBzdGVwcyBpbiBwYXJhbGxlbC5cbiAgICAgICAgICpcbiAgICAgICAgICogTm90ZSB0aGF0IHRoZXNlIG11c3QgYmUgc2VxdWVudGlhbDsgaWYgd2UndmUgc2VlbiBvciBhc3NpZ25lZCBgYToxYCxcbiAgICAgICAgICogYGE6MmAgYW5kIGBhOjRgLCB0aGUgbGF0ZXN0IHNlcXVlbnRpYWwgc3RlcCBpbmRleCBpcyBgMmAuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBleHBlY3RlZE5leHRTdGVwSW5kZXhlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcHJvbWlzZSB0aGF0J3MgdXNlZCB0byBlbnN1cmUgdGhhdCBzdGVwIHJlcG9ydGluZyBjYW5ub3QgYmUgcnVuIG1vcmUgdGhhblxuICAgICAgICAgKiBvbmNlIGluIGEgZ2l2ZW4gYXN5bmNocm9ub3VzIHRpbWUgc3Bhbi5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBmb3VuZFN0ZXBzUmVwb3J0UHJvbWlzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcHJvbWlzZSB0aGF0J3MgdXNlZCB0byByZXByZXNlbnQgbWlkZGxld2FyZSBob29rcyBydW5uaW5nIGJlZm9yZVxuICAgICAgICAgKiBleGVjdXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgYmVmb3JlRXhlY0hvb2tzUHJvbWlzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgaGVscGVyIHVzZWQgdG8gcmVwb3J0IHN0ZXBzIHRvIHRoZSBjb3JlIGxvb3AuIFVzZWQgYWZ0ZXIgYWRkaW5nIGFuIGl0ZW1cbiAgICAgICAgICogdG8gYGZvdW5kU3RlcHNUb1JlcG9ydGAuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZXBvcnROZXh0VGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIC8vIEJlaW5nIGV4cGxpY2l0IGluc3RlYWQgb2YgdXNpbmcgYD8/PWAgdG8gYXBwZWFzZSBUeXBlU2NyaXB0LlxuICAgICAgICAgICAgaWYgKGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm91bmRTdGVwc1JlcG9ydFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0SW1tZWRpYXRlKHJlc29sdmUpKVxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEVuc3VyZSB0aGF0IHdlIHdhaXQgZm9yIHRoaXMgcHJvbWlzZSB0byByZXNvbHZlIGJlZm9yZSBjb250aW51aW5nLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogVGhlIGdyb3VwcyBpbiB3aGljaCBzdGVwcyBhcmUgcmVwb3J0ZWQgY2FuIGFmZmVjdCBob3cgd2UgZGV0ZWN0IHNvbWVcbiAgICAgICAgICAgICAgICAgKiBtb3JlIGNvbXBsZXggZGV0ZXJtaW5pc20gaXNzdWVzIGxpa2UgcGFyYWxsZWwgaW5kZXhpbmcuIFRoaXMgcHJvbWlzZVxuICAgICAgICAgICAgICAgICAqIGNhbiByZXByZXNlbnQgbWlkZGxld2FyZSBob29rcyBiZWluZyBydW4gZWFybHksIGluIHRoZSBtaWRkbGUgb2ZcbiAgICAgICAgICAgICAgICAgKiBpbmdlc3Rpbmcgc3RlcHMgdG8gcmVwb3J0LlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogQmVjYXVzZSBvZiB0aGlzLCBpdCdzIGltcG9ydGFudCB3ZSB3YWl0IGZvciB0aGlzIG1pZGRsZXdhcmUgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgICAgICAqIGJlZm9yZSBjb250aW51aW5nIHRvIHJlcG9ydCBzdGVwcyB0byBlbnN1cmUgdGhhdCBhbGwgc3RlcHMgaGF2ZSBhXG4gICAgICAgICAgICAgICAgICogY2hhbmNlIHRvIGJlIHJlcG9ydGVkIHRocm91Z2hvdXQgdGhpcyBhc3luY2hyb25vdXMgYWN0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IGJlZm9yZUV4ZWNIb29rc1Byb21pc2UpXG4gICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvdW5kU3RlcHNSZXBvcnRQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2hhc2hlZElkLCBzdGVwXSBvZiB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXAuaGFuZGxlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVuaGFuZGxlZEZvdW5kU3RlcHNUb1JlcG9ydC5kZWxldGUoaGFzaGVkSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0ZXAuZnVsZmlsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRTdGVwc1RvUmVwb3J0LmRlbGV0ZShzdGVwLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZm91bmRTdGVwc1RvUmVwb3J0LnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RlcHMgPSBbLi4uZm91bmRTdGVwc1RvUmVwb3J0LnZhbHVlcygpXTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmRTdGVwc1RvUmVwb3J0LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2b2lkIHRoaXMuc3RhdGUuc2V0Q2hlY2twb2ludCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXBzLWZvdW5kXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwczogc3RlcHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBoZWxwZXIgdXNlZCB0byBwdXNoIGEgc3RlcCB0byB0aGUgbGlzdCBvZiBzdGVwcyB0byByZXBvcnQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBwdXNoU3RlcFRvUmVwb3J0ID0gKHN0ZXApID0+IHtcbiAgICAgICAgICAgIGZvdW5kU3RlcHNUb1JlcG9ydC5zZXQoc3RlcC5pZCwgc3RlcCk7XG4gICAgICAgICAgICB1bmhhbmRsZWRGb3VuZFN0ZXBzVG9SZXBvcnQuc2V0KHN0ZXAuaGFzaGVkSWQsIHN0ZXApO1xuICAgICAgICAgICAgcmVwb3J0TmV4dFRpY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RlcEhhbmRsZXIgPSBhc3luYyAoeyBhcmdzLCBtYXRjaE9wLCBvcHRzLCB9KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBhd2FpdCBiZWZvcmVFeGVjSG9va3NQcm9taXNlO1xuICAgICAgICAgICAgY29uc3Qgc3RlcE9wdGlvbnMgPSAoMCwgSW5uZ2VzdFN0ZXBUb29sc19qc18xLmdldFN0ZXBPcHRpb25zKShhcmdzWzBdKTtcbiAgICAgICAgICAgIGNvbnN0IG9wSWQgPSBtYXRjaE9wKHN0ZXBPcHRpb25zLCAuLi5hcmdzLnNsaWNlKDEpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmV4ZWN1dGluZ1N0ZXApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiBhIHN0ZXAgaXMgZm91bmQgYWZ0ZXIgYXN5bmNocm9ub3VzIGFjdGlvbnMgZHVyaW5nIGFub3RoZXIgc3RlcCdzXG4gICAgICAgICAgICAgICAgICogZXhlY3V0aW9uLCBldmVyeXRoaW5nIGlzIGZpbmUuIFRoZSBwcm9ibGVtIGhlcmUgaXMgaWYgd2UndmUgZm91bmRcbiAgICAgICAgICAgICAgICAgKiB0aGF0IGEgc3RlcCBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgYSBzdGVwLCB3aGljaCBpcyBzb21ldGhpbmcgd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAgKiBzdXBwb3J0IGF0IHRoZSB0aW1lIG9mIHdyaXRpbmcuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBJbiB0aGlzIGNhc2UsIHdlIGNvdWxkIHVzZSBzb21ldGhpbmcgbGlrZSBBc3luYyBIb29rcyB0byB1bmRlcnN0YW5kXG4gICAgICAgICAgICAgICAgICogaG93IHRoZSBzdGVwIGlzIGJlaW5nIHRyaWdnZXJlZCwgdGhvdWdoIHRoaXMgaXNuJ3QgYXZhaWxhYmxlIGluIGFsbFxuICAgICAgICAgICAgICAgICAqIGVudmlyb25tZW50cy5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIFRoZXJlZm9yZSwgd2UnbGwgb25seSBzaG93IGEgd2FybmluZyBoZXJlIHRvIGluZGljYXRlIHRoYXQgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAqIHBvdGVudGlhbGx5IGFuIGlzc3VlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICAgICAgd2hhdEhhcHBlbmVkOiBgV2UgZGV0ZWN0ZWQgdGhhdCB5b3UgaGF2ZSBuZXN0ZWQgXFxgc3RlcC4qXFxgIHRvb2xpbmcgaW4gXFxgJHsoX2EgPSBvcElkLmRpc3BsYXlOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBvcElkLmlkfVxcYGAsXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJOZXN0aW5nIGBzdGVwLipgIHRvb2xpbmcgaXMgbm90IHN1cHBvcnRlZC5cIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ3YXJuXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNzdXJhbmNlOiBcIkl0J3MgcG9zc2libGUgdG8gc2VlIHRoaXMgd2FybmluZyBpZiBzdGVwcyBhcmUgc2VwYXJhdGVkIGJ5IHJlZ3VsYXIgYXN5bmNocm9ub3VzIGNhbGxzLCB3aGljaCBpcyBmaW5lLlwiLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdG9GaXhOb3c6IFwiTWFrZSBzdXJlIHlvdSdyZSBub3QgdXNpbmcgYHN0ZXAuKmAgdG9vbGluZyBpbnNpZGUgb2Ygb3RoZXIgYHN0ZXAuKmAgdG9vbGluZy4gSWYgeW91IG5lZWQgdG8gY29tcG9zZSBzdGVwcyB0b2dldGhlciwgeW91IGNhbiBjcmVhdGUgYSBuZXcgYXN5bmMgZnVuY3Rpb24gYW5kIGNhbGwgaXQgZnJvbSB3aXRoaW4geW91ciBzdGVwIGZ1bmN0aW9uLCBvciB1c2UgcHJvbWlzZSBjaGFpbmluZy5cIixcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JzX2pzXzEuRXJyQ29kZS5ORVNUSU5HX1NURVBTLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLnN0ZXBzLmhhcyhvcElkLmlkKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSWQgPSBvcElkLmlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkTmV4dEluZGV4ID0gKF9iID0gZXhwZWN0ZWROZXh0U3RlcEluZGV4ZXMuZ2V0KG9yaWdpbmFsSWQpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBleHBlY3RlZE5leHRJbmRleDs7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJZCA9IG9yaWdpbmFsSWQgKyBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuU1RFUF9JTkRFWElOR19TVUZGSVggKyBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3RhdGUuc3RlcHMuaGFzKG5ld0lkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWROZXh0U3RlcEluZGV4ZXMuc2V0KG9yaWdpbmFsSWQsIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wSWQuaWQgPSBuZXdJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBwcm9taXNlLCByZXNvbHZlLCByZWplY3QgfSA9ICgwLCBwcm9taXNlc19qc18xLmNyZWF0ZURlZmVycmVkUHJvbWlzZSkoKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2hlZElkID0gZXhwb3J0cy5faW50ZXJuYWxzLmhhc2hJZChvcElkLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHN0ZXBTdGF0ZSA9IHRoaXMuc3RhdGUuc3RlcFN0YXRlW2hhc2hlZElkXTtcbiAgICAgICAgICAgIGxldCBpc0Z1bGZpbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHN0ZXBTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0ZXBTdGF0ZS5zZWVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnJlbWFpbmluZ1N0ZXBzVG9CZVNlZW4uZGVsZXRlKGhhc2hlZElkKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0ZXBTdGF0ZS5pbnB1dCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpc0Z1bGZpbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGV4dHJhT3B0cztcbiAgICAgICAgICAgIGxldCBmbkFyZ3MgPSBbLi4uYXJnc107XG4gICAgICAgICAgICBpZiAodHlwZW9mIChzdGVwU3RhdGUgPT09IG51bGwgfHwgc3RlcFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGVwU3RhdGUuaW5wdXQpICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShzdGVwU3RhdGUuaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChvcElkLm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGBzdGVwLnJ1bigpYCBoYXMgaXRzIGZ1bmN0aW9uIGlucHV0IGFmZmVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdHlwZXNfanNfMS5TdGVwT3BDb2RlLlN0ZXBQbGFubmVkOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICBmbkFyZ3MgPSBbLi4uYXJncy5zbGljZSgwLCAyKSwgLi4uc3RlcFN0YXRlLmlucHV0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dHJhT3B0cyA9IHsgaW5wdXQ6IFsuLi5zdGVwU3RhdGUuaW5wdXRdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBgc3RlcC5haS5pbmZlcigpYCBoYXMgaXRzIGJvZHkgYWZmZWN0ZWRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0eXBlc19qc18xLlN0ZXBPcENvZGUuQWlHYXRld2F5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHRyYU9wdHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAodHlwZW9mICgoX2MgPSBvcElkLm9wdHMpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5ib2R5KSA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IE9iamVjdC5hc3NpZ24oe30sIG9wSWQub3B0cy5ib2R5KSA6IHt9KSksIHN0ZXBTdGF0ZS5pbnB1dFswXSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdGVwID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcElkKSwgeyBvcHRzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wSWQub3B0cyksIGV4dHJhT3B0cyksIHJhd0FyZ3M6IGZuQXJncywgLy8gVE9ETyBXaGF0IGlzIHRoZSByaWdodCB2YWx1ZSBoZXJlPyBTaG91bGQgdGhpcyBiZSByYXcgYXJncyB3aXRob3V0IGFmZmVjdGVkIGlucHV0P1xuICAgICAgICAgICAgICAgIGhhc2hlZElkLCBpbnB1dDogc3RlcFN0YXRlID09PSBudWxsIHx8IHN0ZXBTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RlcFN0YXRlLmlucHV0LCBcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgICAgIGZuOiAob3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmZuKSA/ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gb3B0cy5mbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0cywgLi4uZm5BcmdzKTsgfSA6IHVuZGVmaW5lZCwgcHJvbWlzZSwgZnVsZmlsbGVkOiBpc0Z1bGZpbGxlZCwgaGFzU3RlcFN0YXRlOiBCb29sZWFuKHN0ZXBTdGF0ZSksIGRpc3BsYXlOYW1lOiAoX2QgPSBvcElkLmRpc3BsYXlOYW1lKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBvcElkLmlkLCBoYW5kbGVkOiBmYWxzZSwgaGFuZGxlOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwLmhhbmRsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGVwLmhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNGdWxmaWxsZWQgJiYgc3RlcFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwU3RhdGUuZnVsZmlsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBzb21lIGV4ZWN1dGlvbiBzY2VuYXJpb3Mgc3VjaCBhcyB0ZXN0aW5nLCBgZGF0YWAsIGBlcnJvcmAsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgYGlucHV0YCBtYXkgYmUgYFByb21pc2VzYC4gVGhpcyBjb3VsZCBhbHNvIGJlIHRoZSBjYXNlIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnV0dXJlIG1pZGRsZXdhcmUgYXBwbGljYXRpb25zLiBGb3IgdGhpcyByZWFzb24sIHdlJ2xsIG1ha2Ugc3VyZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHZhbHVlcyBhcmUgZnVsbHkgcmVzb2x2ZWQgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwU3RhdGUuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGVwU3RhdGUuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RlcFN0YXRlLmlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgXSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGVwU3RhdGUuZGF0YSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHN0ZXBTdGF0ZS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUucmVjZW50bHlSZWplY3RlZFN0ZXBFcnJvciA9IG5ldyBTdGVwRXJyb3JfanNfMS5TdGVwRXJyb3Iob3BJZC5pZCwgc3RlcFN0YXRlLmVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoaXMuc3RhdGUucmVjZW50bHlSZWplY3RlZFN0ZXBFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RlcHMuc2V0KG9wSWQuaWQsIHN0ZXApO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5oYXNTdGVwcyA9IHRydWU7XG4gICAgICAgICAgICBwdXNoU3RlcFRvUmVwb3J0KHN0ZXApO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIHRoZSBsYXN0IHBpZWNlIG9mIHN0YXRlIHdlIGhhZCwgd2UndmUgbm93IGZpbmlzaGVkXG4gICAgICAgICAgICAgKiBtZW1vaXppbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghYmVmb3JlRXhlY0hvb2tzUHJvbWlzZSAmJiB0aGlzLnN0YXRlLmFsbFN0YXRlVXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgKGJlZm9yZUV4ZWNIb29rc1Byb21pc2UgPSAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0ICgoX2IgPSAoX2EgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWZ0ZXJNZW1vaXphdGlvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgKChfZCA9IChfYyA9IHRoaXMuc3RhdGUuaG9va3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5iZWZvcmVFeGVjdXRpb24pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5jYWxsKF9jKSk7XG4gICAgICAgICAgICAgICAgfSkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICgwLCBJbm5nZXN0U3RlcFRvb2xzX2pzXzEuY3JlYXRlU3RlcFRvb2xzKSh0aGlzLm9wdGlvbnMuY2xpZW50LCB0aGlzLCBzdGVwSGFuZGxlcik7XG4gICAgfVxuICAgIGdldFVzZXJGblRvUnVuKCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5pc0ZhaWx1cmVIYW5kbGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmZuW1wiZm5cIl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZm5bXCJvbkZhaWx1cmVGblwiXSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTb21laG93LCB3ZSd2ZSBlbmRlZCB1cCBkZXRlY3RpbmcgdGhhdCB0aGlzIGlzIGEgZmFpbHVyZSBoYW5kbGVyIGJ1dFxuICAgICAgICAgICAgICogZG9lc24ndCBoYXZlIGFuIGBvbkZhaWx1cmVgIGZ1bmN0aW9uLiBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGZ1bmN0aW9uIGBvbkZhaWx1cmVgIGhhbmRsZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5mbltcIm9uRmFpbHVyZUZuXCJdO1xuICAgIH1cbiAgICBpbml0aWFsaXplVGltZXIoc3RhdGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMucmVxdWVzdGVkUnVuU3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGltZW91dCA9ICgwLCBwcm9taXNlc19qc18xLmNyZWF0ZVRpbWVvdXRQcm9taXNlKSh0aGlzLnRpbWVvdXREdXJhdGlvbik7XG4gICAgICAgIHZvaWQgdGhpcy50aW1lb3V0LnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICBhd2FpdCAoKF9iID0gKF9hID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFmdGVyTWVtb2l6YXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKSk7XG4gICAgICAgICAgICBhd2FpdCAoKF9kID0gKF9jID0gdGhpcy5zdGF0ZS5ob29rcykgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmJlZm9yZUV4ZWN1dGlvbikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmNhbGwoX2MpKTtcbiAgICAgICAgICAgIGF3YWl0ICgoX2YgPSAoX2UgPSB0aGlzLnN0YXRlLmhvb2tzKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UuYWZ0ZXJFeGVjdXRpb24pID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYWxsKF9lKSk7XG4gICAgICAgICAgICBzdGF0ZS5zZXRDaGVja3BvaW50KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtbm90LWZvdW5kXCIsXG4gICAgICAgICAgICAgICAgc3RlcDoge1xuICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5vcHRpb25zLnJlcXVlc3RlZFJ1blN0ZXAsXG4gICAgICAgICAgICAgICAgICAgIG9wOiB0eXBlc19qc18xLlN0ZXBPcENvZGUuU3RlcE5vdEZvdW5kLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVNaWRkbGV3YXJlKCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLm9wdGlvbnMuZGF0YTtcbiAgICAgICAgY29uc3QgaG9va3MgPSBhd2FpdCAoMCwgSW5uZ2VzdE1pZGRsZXdhcmVfanNfMS5nZXRIb29rU3RhY2spKHRoaXMub3B0aW9ucy5mbltcIm1pZGRsZXdhcmVcIl0sIFwib25GdW5jdGlvblJ1blwiLCB7XG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICBmbjogdGhpcy5vcHRpb25zLmZuLFxuICAgICAgICAgICAgc3RlcHM6IE9iamVjdC52YWx1ZXModGhpcy5vcHRpb25zLnN0ZXBTdGF0ZSksXG4gICAgICAgICAgICByZXFBcmdzOiB0aGlzLm9wdGlvbnMucmVxQXJncyxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdHJhbnNmb3JtSW5wdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjdHg6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldi5jdHgpLCBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQuY3R4KSxcbiAgICAgICAgICAgICAgICAgICAgZm46IHRoaXMub3B0aW9ucy5mbixcbiAgICAgICAgICAgICAgICAgICAgc3RlcHM6IHByZXYuc3RlcHMubWFwKChzdGVwLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3RlcCksIChfYSA9IG91dHB1dCA9PT0gbnVsbCB8fCBvdXRwdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG91dHB1dC5zdGVwcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2ldKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICByZXFBcmdzOiBwcmV2LnJlcUFyZ3MsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0cmFuc2Zvcm1PdXRwdXQ6IChwcmV2LCBvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldi5yZXN1bHQpLCBvdXRwdXQgPT09IG51bGwgfHwgb3V0cHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRwdXQucmVzdWx0KSxcbiAgICAgICAgICAgICAgICAgICAgc3RlcDogcHJldi5zdGVwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhvb2tzO1xuICAgIH1cbn1cbmNvbnN0IGhhc2hJZCA9IChpZCkgPT4ge1xuICAgIHJldHVybiAoMCwgaGFzaF9qc18xLnNoYTEpKCkudXBkYXRlKGlkKS5kaWdlc3QoXCJoZXhcIik7XG59O1xuY29uc3QgaGFzaE9wID0gKG9wKSA9PiB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ApLCB7IGlkOiBoYXNoSWQob3AuaWQpIH0pO1xufTtcbi8qKlxuICogRXhwb3J0ZWQgZm9yIHRlc3RpbmcuXG4gKi9cbmV4cG9ydHMuX2ludGVybmFscyA9IHsgaGFzaE9wLCBoYXNoSWQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXYyLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/components/execution/v2.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/experimental.js":
/*!**********************************************!*\
  !*** ./node_modules/inngest/experimental.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InngestSpanProcessor = exports.otelMiddleware = exports.getAsyncCtx = void 0;\n// AsyncLocalStorage\nvar als_js_1 = __webpack_require__(/*! ./components/execution/als.js */ \"(rsc)/./node_modules/inngest/components/execution/als.js\");\nObject.defineProperty(exports, \"getAsyncCtx\", ({ enumerable: true, get: function () { return als_js_1.getAsyncCtx; } }));\n// OpenTelemetry\nvar middleware_js_1 = __webpack_require__(/*! ./components/execution/otel/middleware.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/middleware.js\");\nObject.defineProperty(exports, \"otelMiddleware\", ({ enumerable: true, get: function () { return middleware_js_1.otelMiddleware; } }));\nvar processor_js_1 = __webpack_require__(/*! ./components/execution/otel/processor.js */ \"(rsc)/./node_modules/inngest/components/execution/otel/processor.js\");\nObject.defineProperty(exports, \"InngestSpanProcessor\", ({ enumerable: true, get: function () { return processor_js_1.PublicInngestSpanProcessor; } }));\n//# sourceMappingURL=experimental.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9leHBlcmltZW50YWwuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsc0JBQXNCLEdBQUcsbUJBQW1CO0FBQzNFO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLCtGQUErQjtBQUN0RCwrQ0FBOEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDdEg7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx1SEFBMkM7QUFDekUsa0RBQWlELEVBQUUscUNBQXFDLDBDQUEwQyxFQUFDO0FBQ25JLHFCQUFxQixtQkFBTyxDQUFDLHFIQUEwQztBQUN2RSx3REFBdUQsRUFBRSxxQ0FBcUMscURBQXFELEVBQUM7QUFDcEoiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9leHBlcmltZW50YWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklubmdlc3RTcGFuUHJvY2Vzc29yID0gZXhwb3J0cy5vdGVsTWlkZGxld2FyZSA9IGV4cG9ydHMuZ2V0QXN5bmNDdHggPSB2b2lkIDA7XG4vLyBBc3luY0xvY2FsU3RvcmFnZVxudmFyIGFsc19qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9leGVjdXRpb24vYWxzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0QXN5bmNDdHhcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFsc19qc18xLmdldEFzeW5jQ3R4OyB9IH0pO1xuLy8gT3BlblRlbGVtZXRyeVxudmFyIG1pZGRsZXdhcmVfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvZXhlY3V0aW9uL290ZWwvbWlkZGxld2FyZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm90ZWxNaWRkbGV3YXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBtaWRkbGV3YXJlX2pzXzEub3RlbE1pZGRsZXdhcmU7IH0gfSk7XG52YXIgcHJvY2Vzc29yX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL2V4ZWN1dGlvbi9vdGVsL3Byb2Nlc3Nvci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubmdlc3RTcGFuUHJvY2Vzc29yXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBwcm9jZXNzb3JfanNfMS5QdWJsaWNJbm5nZXN0U3BhblByb2Nlc3NvcjsgfSB9KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4cGVyaW1lbnRhbC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/experimental.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/ServerTiming.js":
/*!******************************************************!*\
  !*** ./node_modules/inngest/helpers/ServerTiming.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ServerTiming = void 0;\nconst promises_js_1 = __webpack_require__(/*! ./promises.js */ \"(rsc)/./node_modules/inngest/helpers/promises.js\");\n/**\n * A class to manage timing functions and arbitrary periods of time before\n * generating a `Server-Timing` header for use in HTTP responses.\n *\n * This is a very simple implementation that does not support nested timings or\n * fractions of a millisecond.\n */\nclass ServerTiming {\n    constructor() {\n        this.timings = {};\n    }\n    /**\n     * Start a timing. Returns a function that, when called, will stop the timing\n     * and add it to the header.\n     */\n    start(name, description) {\n        if (!this.timings[name]) {\n            this.timings[name] = {\n                description: description !== null && description !== void 0 ? description : \"\",\n                timers: [],\n            };\n        }\n        const index = this.timings[name].timers.push({ start: Date.now() }) - 1;\n        return () => {\n            const target = this.timings[name];\n            if (!target) {\n                return console.warn(`Timing \"${name}\" does not exist`);\n            }\n            const timer = target.timers[index];\n            if (!timer) {\n                return console.warn(`Timer ${index} for timing \"${name}\" does not exist`);\n            }\n            timer.end = Date.now();\n        };\n    }\n    /**\n     * Add a piece of arbitrary, untimed information to the header. Common use\n     * cases would be cache misses.\n     *\n     * @example\n     * ```\n     * timer.append(\"cache\", \"miss\");\n     * ```\n     */\n    append(key, value) {\n        this.timings[key] = {\n            description: value,\n            timers: [],\n        };\n    }\n    /**\n     * Wrap a function in a timing. The timing will be stopped and added to the\n     * header when the function resolves or rejects.\n     *\n     * The return value of the function will be returned from this function.\n     */\n    async wrap(name, fn, description) {\n        const stop = this.start(name, description);\n        try {\n            return (await (0, promises_js_1.runAsPromise)(fn));\n        }\n        finally {\n            stop();\n        }\n    }\n    /**\n     * Generate the `Server-Timing` header.\n     */\n    getHeader() {\n        const entries = Object.entries(this.timings).reduce((acc, [name, { description, timers }]) => {\n            /**\n             * Ignore timers that had no end.\n             */\n            const hasTimersWithEnd = timers.some((timer) => timer.end);\n            if (!hasTimersWithEnd) {\n                return acc;\n            }\n            const dur = timers.reduce((acc, { start, end }) => {\n                if (!start || !end)\n                    return acc;\n                return acc + (end - start);\n            }, 0);\n            const entry = [\n                name,\n                description ? `desc=\"${description}\"` : \"\",\n                dur ? `dur=${dur}` : \"\",\n            ]\n                .filter(Boolean)\n                .join(\";\");\n            return [...acc, entry];\n        }, []);\n        return entries.join(\", \");\n    }\n}\nexports.ServerTiming = ServerTiming;\n//# sourceMappingURL=ServerTiming.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL1NlcnZlclRpbWluZy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIsc0JBQXNCLG1CQUFPLENBQUMsdUVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsbUJBQW1CO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxPQUFPLGNBQWMsS0FBSztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLHFCQUFxQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxZQUFZO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQsNkJBQTZCLElBQUk7QUFDakM7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL1NlcnZlclRpbWluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2VydmVyVGltaW5nID0gdm9pZCAwO1xuY29uc3QgcHJvbWlzZXNfanNfMSA9IHJlcXVpcmUoXCIuL3Byb21pc2VzLmpzXCIpO1xuLyoqXG4gKiBBIGNsYXNzIHRvIG1hbmFnZSB0aW1pbmcgZnVuY3Rpb25zIGFuZCBhcmJpdHJhcnkgcGVyaW9kcyBvZiB0aW1lIGJlZm9yZVxuICogZ2VuZXJhdGluZyBhIGBTZXJ2ZXItVGltaW5nYCBoZWFkZXIgZm9yIHVzZSBpbiBIVFRQIHJlc3BvbnNlcy5cbiAqXG4gKiBUaGlzIGlzIGEgdmVyeSBzaW1wbGUgaW1wbGVtZW50YXRpb24gdGhhdCBkb2VzIG5vdCBzdXBwb3J0IG5lc3RlZCB0aW1pbmdzIG9yXG4gKiBmcmFjdGlvbnMgb2YgYSBtaWxsaXNlY29uZC5cbiAqL1xuY2xhc3MgU2VydmVyVGltaW5nIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50aW1pbmdzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0YXJ0IGEgdGltaW5nLiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgc3RvcCB0aGUgdGltaW5nXG4gICAgICogYW5kIGFkZCBpdCB0byB0aGUgaGVhZGVyLlxuICAgICAqL1xuICAgIHN0YXJ0KG5hbWUsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy50aW1pbmdzW25hbWVdKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWluZ3NbbmFtZV0gPSB7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uICE9PSBudWxsICYmIGRlc2NyaXB0aW9uICE9PSB2b2lkIDAgPyBkZXNjcmlwdGlvbiA6IFwiXCIsXG4gICAgICAgICAgICAgICAgdGltZXJzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLnRpbWluZ3NbbmFtZV0udGltZXJzLnB1c2goeyBzdGFydDogRGF0ZS5ub3coKSB9KSAtIDE7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLnRpbWluZ3NbbmFtZV07XG4gICAgICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25zb2xlLndhcm4oYFRpbWluZyBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGltZXIgPSB0YXJnZXQudGltZXJzW2luZGV4XTtcbiAgICAgICAgICAgIGlmICghdGltZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29uc29sZS53YXJuKGBUaW1lciAke2luZGV4fSBmb3IgdGltaW5nIFwiJHtuYW1lfVwiIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aW1lci5lbmQgPSBEYXRlLm5vdygpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBwaWVjZSBvZiBhcmJpdHJhcnksIHVudGltZWQgaW5mb3JtYXRpb24gdG8gdGhlIGhlYWRlci4gQ29tbW9uIHVzZVxuICAgICAqIGNhc2VzIHdvdWxkIGJlIGNhY2hlIG1pc3Nlcy5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogdGltZXIuYXBwZW5kKFwiY2FjaGVcIiwgXCJtaXNzXCIpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGFwcGVuZChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGltaW5nc1trZXldID0ge1xuICAgICAgICAgICAgZGVzY3JpcHRpb246IHZhbHVlLFxuICAgICAgICAgICAgdGltZXJzOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JhcCBhIGZ1bmN0aW9uIGluIGEgdGltaW5nLiBUaGUgdGltaW5nIHdpbGwgYmUgc3RvcHBlZCBhbmQgYWRkZWQgdG8gdGhlXG4gICAgICogaGVhZGVyIHdoZW4gdGhlIGZ1bmN0aW9uIHJlc29sdmVzIG9yIHJlamVjdHMuXG4gICAgICpcbiAgICAgKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiB3aWxsIGJlIHJldHVybmVkIGZyb20gdGhpcyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyB3cmFwKG5hbWUsIGZuLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBzdG9wID0gdGhpcy5zdGFydChuYW1lLCBkZXNjcmlwdGlvbik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gKGF3YWl0ICgwLCBwcm9taXNlc19qc18xLnJ1bkFzUHJvbWlzZSkoZm4pKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSB0aGUgYFNlcnZlci1UaW1pbmdgIGhlYWRlci5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXIoKSB7XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLnRpbWluZ3MpLnJlZHVjZSgoYWNjLCBbbmFtZSwgeyBkZXNjcmlwdGlvbiwgdGltZXJzIH1dKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElnbm9yZSB0aW1lcnMgdGhhdCBoYWQgbm8gZW5kLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBoYXNUaW1lcnNXaXRoRW5kID0gdGltZXJzLnNvbWUoKHRpbWVyKSA9PiB0aW1lci5lbmQpO1xuICAgICAgICAgICAgaWYgKCFoYXNUaW1lcnNXaXRoRW5kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGR1ciA9IHRpbWVycy5yZWR1Y2UoKGFjYywgeyBzdGFydCwgZW5kIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXJ0IHx8ICFlbmQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYyArIChlbmQgLSBzdGFydCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0gW1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb24gPyBgZGVzYz1cIiR7ZGVzY3JpcHRpb259XCJgIDogXCJcIixcbiAgICAgICAgICAgICAgICBkdXIgPyBgZHVyPSR7ZHVyfWAgOiBcIlwiLFxuICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgICAgICAuam9pbihcIjtcIik7XG4gICAgICAgICAgICByZXR1cm4gWy4uLmFjYywgZW50cnldO1xuICAgICAgICB9LCBbXSk7XG4gICAgICAgIHJldHVybiBlbnRyaWVzLmpvaW4oXCIsIFwiKTtcbiAgICB9XG59XG5leHBvcnRzLlNlcnZlclRpbWluZyA9IFNlcnZlclRpbWluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVNlcnZlclRpbWluZy5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/ServerTiming.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/consts.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/consts.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.syncKind = exports.serverKind = exports.dummyEventKey = exports.debugPrefix = exports.logPrefix = exports.internalEvents = exports.defaultDevServerHost = exports.defaultInngestEventBaseUrl = exports.defaultInngestApiBaseUrl = exports.headerKeys = exports.envKeys = exports.probe = exports.queryKeys = void 0;\nconst chalk_1 = __importDefault(__webpack_require__(/*! chalk */ \"(rsc)/./node_modules/chalk/source/index.js\"));\n/**\n * Keys for accessing query parameters included in requests from Inngest to run\n * functions.\n *\n * Used internally to create handlers using `InngestCommHandler`, but can be\n * imported to be used if creating a custom handler outside of the package.\n *\n * @public\n */\nvar queryKeys;\n(function (queryKeys) {\n    queryKeys[\"DeployId\"] = \"deployId\";\n    queryKeys[\"FnId\"] = \"fnId\";\n    queryKeys[\"Probe\"] = \"probe\";\n    queryKeys[\"StepId\"] = \"stepId\";\n})(queryKeys || (exports.queryKeys = queryKeys = {}));\nvar probe;\n(function (probe) {\n    probe[\"Trust\"] = \"trust\";\n})(probe || (exports.probe = probe = {}));\nvar envKeys;\n(function (envKeys) {\n    envKeys[\"InngestSigningKey\"] = \"INNGEST_SIGNING_KEY\";\n    envKeys[\"InngestSigningKeyFallback\"] = \"INNGEST_SIGNING_KEY_FALLBACK\";\n    envKeys[\"InngestEventKey\"] = \"INNGEST_EVENT_KEY\";\n    /**\n     * @deprecated Removed in v3. Use {@link InngestBaseUrl} instead.\n     */\n    envKeys[\"InngestDevServerUrl\"] = \"INNGEST_DEVSERVER_URL\";\n    envKeys[\"InngestEnvironment\"] = \"INNGEST_ENV\";\n    envKeys[\"InngestBaseUrl\"] = \"INNGEST_BASE_URL\";\n    envKeys[\"InngestEventApiBaseUrl\"] = \"INNGEST_EVENT_API_BASE_URL\";\n    envKeys[\"InngestApiBaseUrl\"] = \"INNGEST_API_BASE_URL\";\n    envKeys[\"InngestServeHost\"] = \"INNGEST_SERVE_HOST\";\n    envKeys[\"InngestServePath\"] = \"INNGEST_SERVE_PATH\";\n    envKeys[\"InngestLogLevel\"] = \"INNGEST_LOG_LEVEL\";\n    envKeys[\"InngestStreaming\"] = \"INNGEST_STREAMING\";\n    envKeys[\"InngestDevMode\"] = \"INNGEST_DEV\";\n    envKeys[\"InngestAllowInBandSync\"] = \"INNGEST_ALLOW_IN_BAND_SYNC\";\n    /**\n     * @deprecated It's unknown what this env var was used for, but we do not\n     * provide explicit support for it. Prefer using `INNGEST_ENV` instead.\n     */\n    envKeys[\"BranchName\"] = \"BRANCH_NAME\";\n    /**\n     * The git branch of the commit the deployment was triggered by. Example:\n     * `improve-about-page`.\n     *\n     * {@link https://vercel.com/docs/concepts/projects/environment-variables/system-environment-variables#system-environment-variables}\n     */\n    envKeys[\"VercelBranch\"] = \"VERCEL_GIT_COMMIT_REF\";\n    /**\n     * Expected to be `\"1\"` if defined.\n     */\n    envKeys[\"IsVercel\"] = \"VERCEL\";\n    /**\n     * The branch name of the current deployment. May only be accessible at build\n     * time, but included here just in case.\n     *\n     * {@link https://developers.cloudflare.com/pages/platform/build-configuration/#environment-variables}\n     */\n    envKeys[\"CloudflarePagesBranch\"] = \"CF_PAGES_BRANCH\";\n    /**\n     * Expected to be `\"1\"` if defined.\n     */\n    envKeys[\"IsCloudflarePages\"] = \"CF_PAGES\";\n    /**\n     * The branch name of the deployment from Git to Netlify, if available.\n     *\n     * {@link https://docs.netlify.com/configure-builds/environment-variables/#git-metadata}\n     */\n    envKeys[\"NetlifyBranch\"] = \"BRANCH\";\n    /**\n     * Expected to be `\"true\"` if defined.\n     */\n    envKeys[\"IsNetlify\"] = \"NETLIFY\";\n    /**\n     * The Git branch for a service or deploy.\n     *\n     * {@link https://render.com/docs/environment-variables#all-services}\n     */\n    envKeys[\"RenderBranch\"] = \"RENDER_GIT_BRANCH\";\n    /**\n     * Expected to be `\"true\"` if defined.\n     */\n    envKeys[\"IsRender\"] = \"RENDER\";\n    /**\n     * The branch that triggered the deployment. Example: `main`\n     *\n     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n     */\n    envKeys[\"RailwayBranch\"] = \"RAILWAY_GIT_BRANCH\";\n    /**\n     * The railway environment for the deployment. Example: `production`\n     *\n     * {@link https://docs.railway.app/develop/variables#railway-provided-variables}\n     */\n    envKeys[\"RailwayEnvironment\"] = \"RAILWAY_ENVIRONMENT\";\n    envKeys[\"VercelEnvKey\"] = \"VERCEL_ENV\";\n    envKeys[\"OpenAiApiKey\"] = \"OPENAI_API_KEY\";\n    envKeys[\"GeminiApiKey\"] = \"GEMINI_API_KEY\";\n    envKeys[\"AnthropicApiKey\"] = \"ANTHROPIC_API_KEY\";\n})(envKeys || (exports.envKeys = envKeys = {}));\n/**\n * Keys for accessing headers included in requests from Inngest to run\n * functions.\n *\n * Used internally to create handlers using `InngestCommHandler`, but can be\n * imported to be used if creating a custom handler outside of the package.\n *\n * @public\n */\nvar headerKeys;\n(function (headerKeys) {\n    headerKeys[\"ContentLength\"] = \"content-length\";\n    headerKeys[\"Signature\"] = \"x-inngest-signature\";\n    headerKeys[\"SdkVersion\"] = \"x-inngest-sdk\";\n    headerKeys[\"Environment\"] = \"x-inngest-env\";\n    headerKeys[\"Platform\"] = \"x-inngest-platform\";\n    headerKeys[\"Framework\"] = \"x-inngest-framework\";\n    headerKeys[\"NoRetry\"] = \"x-inngest-no-retry\";\n    headerKeys[\"RequestVersion\"] = \"x-inngest-req-version\";\n    headerKeys[\"RetryAfter\"] = \"retry-after\";\n    headerKeys[\"InngestServerKind\"] = \"x-inngest-server-kind\";\n    headerKeys[\"InngestExpectedServerKind\"] = \"x-inngest-expected-server-kind\";\n    headerKeys[\"InngestSyncKind\"] = \"x-inngest-sync-kind\";\n    headerKeys[\"EventIdSeed\"] = \"x-inngest-event-id-seed\";\n    headerKeys[\"TraceParent\"] = \"traceparent\";\n    headerKeys[\"TraceState\"] = \"tracestate\";\n})(headerKeys || (exports.headerKeys = headerKeys = {}));\nexports.defaultInngestApiBaseUrl = \"https://api.inngest.com/\";\nexports.defaultInngestEventBaseUrl = \"https://inn.gs/\";\nexports.defaultDevServerHost = \"http://localhost:8288/\";\n/**\n * Events that Inngest may send internally that can be used to trigger\n * functions.\n *\n * @public\n */\nvar internalEvents;\n(function (internalEvents) {\n    /**\n     * A function has failed after exhausting all available retries. This event\n     * will contain the original event and the error that caused the failure.\n     */\n    internalEvents[\"FunctionFailed\"] = \"inngest/function.failed\";\n    internalEvents[\"FunctionInvoked\"] = \"inngest/function.invoked\";\n    internalEvents[\"FunctionFinished\"] = \"inngest/function.finished\";\n    internalEvents[\"FunctionCancelled\"] = \"inngest/function.cancelled\";\n    internalEvents[\"ScheduledTimer\"] = \"inngest/scheduled.timer\";\n})(internalEvents || (exports.internalEvents = internalEvents = {}));\nexports.logPrefix = chalk_1.default.magenta.bold(\"[Inngest]\");\nexports.debugPrefix = \"inngest\";\nexports.dummyEventKey = \"NO_EVENT_KEY_SET\";\nvar serverKind;\n(function (serverKind) {\n    serverKind[\"Dev\"] = \"dev\";\n    serverKind[\"Cloud\"] = \"cloud\";\n})(serverKind || (exports.serverKind = serverKind = {}));\nvar syncKind;\n(function (syncKind) {\n    syncKind[\"InBand\"] = \"in_band\";\n    syncKind[\"OutOfBand\"] = \"out_of_band\";\n})(syncKind || (exports.syncKind = syncKind = {}));\n//# sourceMappingURL=consts.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2NvbnN0cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLHFCQUFxQixHQUFHLG1CQUFtQixHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLDRCQUE0QixHQUFHLGtDQUFrQyxHQUFHLGdDQUFnQyxHQUFHLGtCQUFrQixHQUFHLGVBQWUsR0FBRyxhQUFhLEdBQUcsaUJBQWlCO0FBQ2xULGdDQUFnQyxtQkFBTyxDQUFDLHlEQUFPO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0JBQWdCLGlCQUFpQixpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxZQUFZLGFBQWEsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsc0JBQXNCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsY0FBYyxlQUFlLGVBQWU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsaUJBQWlCLGtCQUFrQixrQkFBa0I7QUFDdEQsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMscUJBQXFCLHNCQUFzQixzQkFBc0I7QUFDbEUsaUJBQWlCO0FBQ2pCLG1CQUFtQjtBQUNuQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQixrQkFBa0Isa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxlQUFlLGdCQUFnQixnQkFBZ0I7QUFDaEQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2NvbnN0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc3luY0tpbmQgPSBleHBvcnRzLnNlcnZlcktpbmQgPSBleHBvcnRzLmR1bW15RXZlbnRLZXkgPSBleHBvcnRzLmRlYnVnUHJlZml4ID0gZXhwb3J0cy5sb2dQcmVmaXggPSBleHBvcnRzLmludGVybmFsRXZlbnRzID0gZXhwb3J0cy5kZWZhdWx0RGV2U2VydmVySG9zdCA9IGV4cG9ydHMuZGVmYXVsdElubmdlc3RFdmVudEJhc2VVcmwgPSBleHBvcnRzLmRlZmF1bHRJbm5nZXN0QXBpQmFzZVVybCA9IGV4cG9ydHMuaGVhZGVyS2V5cyA9IGV4cG9ydHMuZW52S2V5cyA9IGV4cG9ydHMucHJvYmUgPSBleHBvcnRzLnF1ZXJ5S2V5cyA9IHZvaWQgMDtcbmNvbnN0IGNoYWxrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNoYWxrXCIpKTtcbi8qKlxuICogS2V5cyBmb3IgYWNjZXNzaW5nIHF1ZXJ5IHBhcmFtZXRlcnMgaW5jbHVkZWQgaW4gcmVxdWVzdHMgZnJvbSBJbm5nZXN0IHRvIHJ1blxuICogZnVuY3Rpb25zLlxuICpcbiAqIFVzZWQgaW50ZXJuYWxseSB0byBjcmVhdGUgaGFuZGxlcnMgdXNpbmcgYElubmdlc3RDb21tSGFuZGxlcmAsIGJ1dCBjYW4gYmVcbiAqIGltcG9ydGVkIHRvIGJlIHVzZWQgaWYgY3JlYXRpbmcgYSBjdXN0b20gaGFuZGxlciBvdXRzaWRlIG9mIHRoZSBwYWNrYWdlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIHF1ZXJ5S2V5cztcbihmdW5jdGlvbiAocXVlcnlLZXlzKSB7XG4gICAgcXVlcnlLZXlzW1wiRGVwbG95SWRcIl0gPSBcImRlcGxveUlkXCI7XG4gICAgcXVlcnlLZXlzW1wiRm5JZFwiXSA9IFwiZm5JZFwiO1xuICAgIHF1ZXJ5S2V5c1tcIlByb2JlXCJdID0gXCJwcm9iZVwiO1xuICAgIHF1ZXJ5S2V5c1tcIlN0ZXBJZFwiXSA9IFwic3RlcElkXCI7XG59KShxdWVyeUtleXMgfHwgKGV4cG9ydHMucXVlcnlLZXlzID0gcXVlcnlLZXlzID0ge30pKTtcbnZhciBwcm9iZTtcbihmdW5jdGlvbiAocHJvYmUpIHtcbiAgICBwcm9iZVtcIlRydXN0XCJdID0gXCJ0cnVzdFwiO1xufSkocHJvYmUgfHwgKGV4cG9ydHMucHJvYmUgPSBwcm9iZSA9IHt9KSk7XG52YXIgZW52S2V5cztcbihmdW5jdGlvbiAoZW52S2V5cykge1xuICAgIGVudktleXNbXCJJbm5nZXN0U2lnbmluZ0tleVwiXSA9IFwiSU5OR0VTVF9TSUdOSU5HX0tFWVwiO1xuICAgIGVudktleXNbXCJJbm5nZXN0U2lnbmluZ0tleUZhbGxiYWNrXCJdID0gXCJJTk5HRVNUX1NJR05JTkdfS0VZX0ZBTExCQUNLXCI7XG4gICAgZW52S2V5c1tcIklubmdlc3RFdmVudEtleVwiXSA9IFwiSU5OR0VTVF9FVkVOVF9LRVlcIjtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBSZW1vdmVkIGluIHYzLiBVc2Uge0BsaW5rIElubmdlc3RCYXNlVXJsfSBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGVudktleXNbXCJJbm5nZXN0RGV2U2VydmVyVXJsXCJdID0gXCJJTk5HRVNUX0RFVlNFUlZFUl9VUkxcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdEVudmlyb25tZW50XCJdID0gXCJJTk5HRVNUX0VOVlwiO1xuICAgIGVudktleXNbXCJJbm5nZXN0QmFzZVVybFwiXSA9IFwiSU5OR0VTVF9CQVNFX1VSTFwiO1xuICAgIGVudktleXNbXCJJbm5nZXN0RXZlbnRBcGlCYXNlVXJsXCJdID0gXCJJTk5HRVNUX0VWRU5UX0FQSV9CQVNFX1VSTFwiO1xuICAgIGVudktleXNbXCJJbm5nZXN0QXBpQmFzZVVybFwiXSA9IFwiSU5OR0VTVF9BUElfQkFTRV9VUkxcIjtcbiAgICBlbnZLZXlzW1wiSW5uZ2VzdFNlcnZlSG9zdFwiXSA9IFwiSU5OR0VTVF9TRVJWRV9IT1NUXCI7XG4gICAgZW52S2V5c1tcIklubmdlc3RTZXJ2ZVBhdGhcIl0gPSBcIklOTkdFU1RfU0VSVkVfUEFUSFwiO1xuICAgIGVudktleXNbXCJJbm5nZXN0TG9nTGV2ZWxcIl0gPSBcIklOTkdFU1RfTE9HX0xFVkVMXCI7XG4gICAgZW52S2V5c1tcIklubmdlc3RTdHJlYW1pbmdcIl0gPSBcIklOTkdFU1RfU1RSRUFNSU5HXCI7XG4gICAgZW52S2V5c1tcIklubmdlc3REZXZNb2RlXCJdID0gXCJJTk5HRVNUX0RFVlwiO1xuICAgIGVudktleXNbXCJJbm5nZXN0QWxsb3dJbkJhbmRTeW5jXCJdID0gXCJJTk5HRVNUX0FMTE9XX0lOX0JBTkRfU1lOQ1wiO1xuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEl0J3MgdW5rbm93biB3aGF0IHRoaXMgZW52IHZhciB3YXMgdXNlZCBmb3IsIGJ1dCB3ZSBkbyBub3RcbiAgICAgKiBwcm92aWRlIGV4cGxpY2l0IHN1cHBvcnQgZm9yIGl0LiBQcmVmZXIgdXNpbmcgYElOTkdFU1RfRU5WYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGVudktleXNbXCJCcmFuY2hOYW1lXCJdID0gXCJCUkFOQ0hfTkFNRVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBnaXQgYnJhbmNoIG9mIHRoZSBjb21taXQgdGhlIGRlcGxveW1lbnQgd2FzIHRyaWdnZXJlZCBieS4gRXhhbXBsZTpcbiAgICAgKiBgaW1wcm92ZS1hYm91dC1wYWdlYC5cbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL3ZlcmNlbC5jb20vZG9jcy9jb25jZXB0cy9wcm9qZWN0cy9lbnZpcm9ubWVudC12YXJpYWJsZXMvc3lzdGVtLWVudmlyb25tZW50LXZhcmlhYmxlcyNzeXN0ZW0tZW52aXJvbm1lbnQtdmFyaWFibGVzfVxuICAgICAqL1xuICAgIGVudktleXNbXCJWZXJjZWxCcmFuY2hcIl0gPSBcIlZFUkNFTF9HSVRfQ09NTUlUX1JFRlwiO1xuICAgIC8qKlxuICAgICAqIEV4cGVjdGVkIHRvIGJlIGBcIjFcImAgaWYgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBlbnZLZXlzW1wiSXNWZXJjZWxcIl0gPSBcIlZFUkNFTFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBicmFuY2ggbmFtZSBvZiB0aGUgY3VycmVudCBkZXBsb3ltZW50LiBNYXkgb25seSBiZSBhY2Nlc3NpYmxlIGF0IGJ1aWxkXG4gICAgICogdGltZSwgYnV0IGluY2x1ZGVkIGhlcmUganVzdCBpbiBjYXNlLlxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5jbG91ZGZsYXJlLmNvbS9wYWdlcy9wbGF0Zm9ybS9idWlsZC1jb25maWd1cmF0aW9uLyNlbnZpcm9ubWVudC12YXJpYWJsZXN9XG4gICAgICovXG4gICAgZW52S2V5c1tcIkNsb3VkZmxhcmVQYWdlc0JyYW5jaFwiXSA9IFwiQ0ZfUEFHRVNfQlJBTkNIXCI7XG4gICAgLyoqXG4gICAgICogRXhwZWN0ZWQgdG8gYmUgYFwiMVwiYCBpZiBkZWZpbmVkLlxuICAgICAqL1xuICAgIGVudktleXNbXCJJc0Nsb3VkZmxhcmVQYWdlc1wiXSA9IFwiQ0ZfUEFHRVNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgYnJhbmNoIG5hbWUgb2YgdGhlIGRlcGxveW1lbnQgZnJvbSBHaXQgdG8gTmV0bGlmeSwgaWYgYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vZG9jcy5uZXRsaWZ5LmNvbS9jb25maWd1cmUtYnVpbGRzL2Vudmlyb25tZW50LXZhcmlhYmxlcy8jZ2l0LW1ldGFkYXRhfVxuICAgICAqL1xuICAgIGVudktleXNbXCJOZXRsaWZ5QnJhbmNoXCJdID0gXCJCUkFOQ0hcIjtcbiAgICAvKipcbiAgICAgKiBFeHBlY3RlZCB0byBiZSBgXCJ0cnVlXCJgIGlmIGRlZmluZWQuXG4gICAgICovXG4gICAgZW52S2V5c1tcIklzTmV0bGlmeVwiXSA9IFwiTkVUTElGWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBHaXQgYnJhbmNoIGZvciBhIHNlcnZpY2Ugb3IgZGVwbG95LlxuICAgICAqXG4gICAgICoge0BsaW5rIGh0dHBzOi8vcmVuZGVyLmNvbS9kb2NzL2Vudmlyb25tZW50LXZhcmlhYmxlcyNhbGwtc2VydmljZXN9XG4gICAgICovXG4gICAgZW52S2V5c1tcIlJlbmRlckJyYW5jaFwiXSA9IFwiUkVOREVSX0dJVF9CUkFOQ0hcIjtcbiAgICAvKipcbiAgICAgKiBFeHBlY3RlZCB0byBiZSBgXCJ0cnVlXCJgIGlmIGRlZmluZWQuXG4gICAgICovXG4gICAgZW52S2V5c1tcIklzUmVuZGVyXCJdID0gXCJSRU5ERVJcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgYnJhbmNoIHRoYXQgdHJpZ2dlcmVkIHRoZSBkZXBsb3ltZW50LiBFeGFtcGxlOiBgbWFpbmBcbiAgICAgKlxuICAgICAqIHtAbGluayBodHRwczovL2RvY3MucmFpbHdheS5hcHAvZGV2ZWxvcC92YXJpYWJsZXMjcmFpbHdheS1wcm92aWRlZC12YXJpYWJsZXN9XG4gICAgICovXG4gICAgZW52S2V5c1tcIlJhaWx3YXlCcmFuY2hcIl0gPSBcIlJBSUxXQVlfR0lUX0JSQU5DSFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByYWlsd2F5IGVudmlyb25tZW50IGZvciB0aGUgZGVwbG95bWVudC4gRXhhbXBsZTogYHByb2R1Y3Rpb25gXG4gICAgICpcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9kb2NzLnJhaWx3YXkuYXBwL2RldmVsb3AvdmFyaWFibGVzI3JhaWx3YXktcHJvdmlkZWQtdmFyaWFibGVzfVxuICAgICAqL1xuICAgIGVudktleXNbXCJSYWlsd2F5RW52aXJvbm1lbnRcIl0gPSBcIlJBSUxXQVlfRU5WSVJPTk1FTlRcIjtcbiAgICBlbnZLZXlzW1wiVmVyY2VsRW52S2V5XCJdID0gXCJWRVJDRUxfRU5WXCI7XG4gICAgZW52S2V5c1tcIk9wZW5BaUFwaUtleVwiXSA9IFwiT1BFTkFJX0FQSV9LRVlcIjtcbiAgICBlbnZLZXlzW1wiR2VtaW5pQXBpS2V5XCJdID0gXCJHRU1JTklfQVBJX0tFWVwiO1xuICAgIGVudktleXNbXCJBbnRocm9waWNBcGlLZXlcIl0gPSBcIkFOVEhST1BJQ19BUElfS0VZXCI7XG59KShlbnZLZXlzIHx8IChleHBvcnRzLmVudktleXMgPSBlbnZLZXlzID0ge30pKTtcbi8qKlxuICogS2V5cyBmb3IgYWNjZXNzaW5nIGhlYWRlcnMgaW5jbHVkZWQgaW4gcmVxdWVzdHMgZnJvbSBJbm5nZXN0IHRvIHJ1blxuICogZnVuY3Rpb25zLlxuICpcbiAqIFVzZWQgaW50ZXJuYWxseSB0byBjcmVhdGUgaGFuZGxlcnMgdXNpbmcgYElubmdlc3RDb21tSGFuZGxlcmAsIGJ1dCBjYW4gYmVcbiAqIGltcG9ydGVkIHRvIGJlIHVzZWQgaWYgY3JlYXRpbmcgYSBjdXN0b20gaGFuZGxlciBvdXRzaWRlIG9mIHRoZSBwYWNrYWdlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIGhlYWRlcktleXM7XG4oZnVuY3Rpb24gKGhlYWRlcktleXMpIHtcbiAgICBoZWFkZXJLZXlzW1wiQ29udGVudExlbmd0aFwiXSA9IFwiY29udGVudC1sZW5ndGhcIjtcbiAgICBoZWFkZXJLZXlzW1wiU2lnbmF0dXJlXCJdID0gXCJ4LWlubmdlc3Qtc2lnbmF0dXJlXCI7XG4gICAgaGVhZGVyS2V5c1tcIlNka1ZlcnNpb25cIl0gPSBcIngtaW5uZ2VzdC1zZGtcIjtcbiAgICBoZWFkZXJLZXlzW1wiRW52aXJvbm1lbnRcIl0gPSBcIngtaW5uZ2VzdC1lbnZcIjtcbiAgICBoZWFkZXJLZXlzW1wiUGxhdGZvcm1cIl0gPSBcIngtaW5uZ2VzdC1wbGF0Zm9ybVwiO1xuICAgIGhlYWRlcktleXNbXCJGcmFtZXdvcmtcIl0gPSBcIngtaW5uZ2VzdC1mcmFtZXdvcmtcIjtcbiAgICBoZWFkZXJLZXlzW1wiTm9SZXRyeVwiXSA9IFwieC1pbm5nZXN0LW5vLXJldHJ5XCI7XG4gICAgaGVhZGVyS2V5c1tcIlJlcXVlc3RWZXJzaW9uXCJdID0gXCJ4LWlubmdlc3QtcmVxLXZlcnNpb25cIjtcbiAgICBoZWFkZXJLZXlzW1wiUmV0cnlBZnRlclwiXSA9IFwicmV0cnktYWZ0ZXJcIjtcbiAgICBoZWFkZXJLZXlzW1wiSW5uZ2VzdFNlcnZlcktpbmRcIl0gPSBcIngtaW5uZ2VzdC1zZXJ2ZXIta2luZFwiO1xuICAgIGhlYWRlcktleXNbXCJJbm5nZXN0RXhwZWN0ZWRTZXJ2ZXJLaW5kXCJdID0gXCJ4LWlubmdlc3QtZXhwZWN0ZWQtc2VydmVyLWtpbmRcIjtcbiAgICBoZWFkZXJLZXlzW1wiSW5uZ2VzdFN5bmNLaW5kXCJdID0gXCJ4LWlubmdlc3Qtc3luYy1raW5kXCI7XG4gICAgaGVhZGVyS2V5c1tcIkV2ZW50SWRTZWVkXCJdID0gXCJ4LWlubmdlc3QtZXZlbnQtaWQtc2VlZFwiO1xuICAgIGhlYWRlcktleXNbXCJUcmFjZVBhcmVudFwiXSA9IFwidHJhY2VwYXJlbnRcIjtcbiAgICBoZWFkZXJLZXlzW1wiVHJhY2VTdGF0ZVwiXSA9IFwidHJhY2VzdGF0ZVwiO1xufSkoaGVhZGVyS2V5cyB8fCAoZXhwb3J0cy5oZWFkZXJLZXlzID0gaGVhZGVyS2V5cyA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHRJbm5nZXN0QXBpQmFzZVVybCA9IFwiaHR0cHM6Ly9hcGkuaW5uZ2VzdC5jb20vXCI7XG5leHBvcnRzLmRlZmF1bHRJbm5nZXN0RXZlbnRCYXNlVXJsID0gXCJodHRwczovL2lubi5ncy9cIjtcbmV4cG9ydHMuZGVmYXVsdERldlNlcnZlckhvc3QgPSBcImh0dHA6Ly9sb2NhbGhvc3Q6ODI4OC9cIjtcbi8qKlxuICogRXZlbnRzIHRoYXQgSW5uZ2VzdCBtYXkgc2VuZCBpbnRlcm5hbGx5IHRoYXQgY2FuIGJlIHVzZWQgdG8gdHJpZ2dlclxuICogZnVuY3Rpb25zLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIGludGVybmFsRXZlbnRzO1xuKGZ1bmN0aW9uIChpbnRlcm5hbEV2ZW50cykge1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gaGFzIGZhaWxlZCBhZnRlciBleGhhdXN0aW5nIGFsbCBhdmFpbGFibGUgcmV0cmllcy4gVGhpcyBldmVudFxuICAgICAqIHdpbGwgY29udGFpbiB0aGUgb3JpZ2luYWwgZXZlbnQgYW5kIHRoZSBlcnJvciB0aGF0IGNhdXNlZCB0aGUgZmFpbHVyZS5cbiAgICAgKi9cbiAgICBpbnRlcm5hbEV2ZW50c1tcIkZ1bmN0aW9uRmFpbGVkXCJdID0gXCJpbm5nZXN0L2Z1bmN0aW9uLmZhaWxlZFwiO1xuICAgIGludGVybmFsRXZlbnRzW1wiRnVuY3Rpb25JbnZva2VkXCJdID0gXCJpbm5nZXN0L2Z1bmN0aW9uLmludm9rZWRcIjtcbiAgICBpbnRlcm5hbEV2ZW50c1tcIkZ1bmN0aW9uRmluaXNoZWRcIl0gPSBcImlubmdlc3QvZnVuY3Rpb24uZmluaXNoZWRcIjtcbiAgICBpbnRlcm5hbEV2ZW50c1tcIkZ1bmN0aW9uQ2FuY2VsbGVkXCJdID0gXCJpbm5nZXN0L2Z1bmN0aW9uLmNhbmNlbGxlZFwiO1xuICAgIGludGVybmFsRXZlbnRzW1wiU2NoZWR1bGVkVGltZXJcIl0gPSBcImlubmdlc3Qvc2NoZWR1bGVkLnRpbWVyXCI7XG59KShpbnRlcm5hbEV2ZW50cyB8fCAoZXhwb3J0cy5pbnRlcm5hbEV2ZW50cyA9IGludGVybmFsRXZlbnRzID0ge30pKTtcbmV4cG9ydHMubG9nUHJlZml4ID0gY2hhbGtfMS5kZWZhdWx0Lm1hZ2VudGEuYm9sZChcIltJbm5nZXN0XVwiKTtcbmV4cG9ydHMuZGVidWdQcmVmaXggPSBcImlubmdlc3RcIjtcbmV4cG9ydHMuZHVtbXlFdmVudEtleSA9IFwiTk9fRVZFTlRfS0VZX1NFVFwiO1xudmFyIHNlcnZlcktpbmQ7XG4oZnVuY3Rpb24gKHNlcnZlcktpbmQpIHtcbiAgICBzZXJ2ZXJLaW5kW1wiRGV2XCJdID0gXCJkZXZcIjtcbiAgICBzZXJ2ZXJLaW5kW1wiQ2xvdWRcIl0gPSBcImNsb3VkXCI7XG59KShzZXJ2ZXJLaW5kIHx8IChleHBvcnRzLnNlcnZlcktpbmQgPSBzZXJ2ZXJLaW5kID0ge30pKTtcbnZhciBzeW5jS2luZDtcbihmdW5jdGlvbiAoc3luY0tpbmQpIHtcbiAgICBzeW5jS2luZFtcIkluQmFuZFwiXSA9IFwiaW5fYmFuZFwiO1xuICAgIHN5bmNLaW5kW1wiT3V0T2ZCYW5kXCJdID0gXCJvdXRfb2ZfYmFuZFwiO1xufSkoc3luY0tpbmQgfHwgKGV4cG9ydHMuc3luY0tpbmQgPSBzeW5jS2luZCA9IHt9KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdHMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/consts.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/crypto.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/crypto.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createEntropy = createEntropy;\n/**\n * Create a cryptographically secure random value.\n *\n * @throws {Error} If the crypto module is not available.\n */\nfunction createEntropy(byteLength) {\n    const bytes = new Uint8Array(byteLength);\n    // https://developer.mozilla.org/en-US/docs/Web/API/Crypto#browser_compatibility\n    const { crypto } = globalThis;\n    if (!crypto) {\n        // This should only happen in Node <19.\n        throw new Error(\"missing crypto module\");\n    }\n    if (!crypto.getRandomValues) {\n        throw new Error(\"missing crypto.getRandomValues\");\n    }\n    crypto.getRandomValues(bytes);\n    return bytes;\n}\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2NyeXB0by5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY3JlYXRlRW50cm9weSA9IGNyZWF0ZUVudHJvcHk7XG4vKipcbiAqIENyZWF0ZSBhIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb20gdmFsdWUuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IElmIHRoZSBjcnlwdG8gbW9kdWxlIGlzIG5vdCBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVudHJvcHkoYnl0ZUxlbmd0aCkge1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnl0ZUxlbmd0aCk7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NyeXB0byNicm93c2VyX2NvbXBhdGliaWxpdHlcbiAgICBjb25zdCB7IGNyeXB0byB9ID0gZ2xvYmFsVGhpcztcbiAgICBpZiAoIWNyeXB0bykge1xuICAgICAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBOb2RlIDwxOS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjcnlwdG8gbW9kdWxlXCIpO1xuICAgIH1cbiAgICBpZiAoIWNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXCIpO1xuICAgIH1cbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jcnlwdG8uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/crypto.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/devserver.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/helpers/devserver.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.devServerHost = exports.devServerUrl = exports.devServerAvailable = void 0;\nconst consts_js_1 = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst env_js_1 = __webpack_require__(/*! ./env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\n/**\n * Attempts to contact the dev server, returning a boolean indicating whether or\n * not it was successful.\n *\n * @example devServerUrl(process.env[envKeys.DevServerUrl], \"/your-path\")\n */\nconst devServerAvailable = async (\n/**\n * The host of the dev server. You should pass in an environment variable as\n * this parameter.\n */\nhost = consts_js_1.defaultDevServerHost, \n/**\n * The fetch implementation to use to communicate with the dev server.\n */\nfetch) => {\n    try {\n        const url = (0, exports.devServerUrl)(host, \"/dev\");\n        const result = await fetch(url.toString());\n        await result.json();\n        return true;\n    }\n    catch (e) {\n        return false;\n    }\n};\nexports.devServerAvailable = devServerAvailable;\n/**\n * devServerUrl returns a full URL for the given path name.\n *\n * Because Cloudflare/V8 platforms don't allow process.env, you are expected\n * to pass in the host from the dev server env key:\n *\n * @example devServerUrl(processEnv(envKeys.DevServerUrl), \"/your-path\")\n * @example devServerUrl(\"http://localhost:8288/\", \"/your-path\")\n */\nconst devServerUrl = (host = (0, exports.devServerHost)(), pathname = \"\") => {\n    return new URL(pathname, host.includes(\"://\") ? host : `http://${host}`);\n};\nexports.devServerUrl = devServerUrl;\n/**\n * devServerHost exports the development server's domain by inspecting env\n * variables, or returns the default development server URL.\n *\n * This guarantees a specific URL as a string, as opposed to the env export\n * which only returns a value of the env var is set.\n */\nconst devServerHost = () => (0, env_js_1.devServerHost)() || consts_js_1.defaultDevServerHost;\nexports.devServerHost = devServerHost;\n//# sourceMappingURL=devserver.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2RldnNlcnZlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxvQkFBb0IsR0FBRywwQkFBMEI7QUFDekUsb0JBQW9CLG1CQUFPLENBQUMsbUVBQWE7QUFDekMsaUJBQWlCLG1CQUFPLENBQUMsNkRBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxLQUFLO0FBQzFFO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2RldnNlcnZlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGV2U2VydmVySG9zdCA9IGV4cG9ydHMuZGV2U2VydmVyVXJsID0gZXhwb3J0cy5kZXZTZXJ2ZXJBdmFpbGFibGUgPSB2b2lkIDA7XG5jb25zdCBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbnN0cy5qc1wiKTtcbmNvbnN0IGVudl9qc18xID0gcmVxdWlyZShcIi4vZW52LmpzXCIpO1xuLyoqXG4gKiBBdHRlbXB0cyB0byBjb250YWN0IHRoZSBkZXYgc2VydmVyLCByZXR1cm5pbmcgYSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBvclxuICogbm90IGl0IHdhcyBzdWNjZXNzZnVsLlxuICpcbiAqIEBleGFtcGxlIGRldlNlcnZlclVybChwcm9jZXNzLmVudltlbnZLZXlzLkRldlNlcnZlclVybF0sIFwiL3lvdXItcGF0aFwiKVxuICovXG5jb25zdCBkZXZTZXJ2ZXJBdmFpbGFibGUgPSBhc3luYyAoXG4vKipcbiAqIFRoZSBob3N0IG9mIHRoZSBkZXYgc2VydmVyLiBZb3Ugc2hvdWxkIHBhc3MgaW4gYW4gZW52aXJvbm1lbnQgdmFyaWFibGUgYXNcbiAqIHRoaXMgcGFyYW1ldGVyLlxuICovXG5ob3N0ID0gY29uc3RzX2pzXzEuZGVmYXVsdERldlNlcnZlckhvc3QsIFxuLyoqXG4gKiBUaGUgZmV0Y2ggaW1wbGVtZW50YXRpb24gdG8gdXNlIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIGRldiBzZXJ2ZXIuXG4gKi9cbmZldGNoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdXJsID0gKDAsIGV4cG9ydHMuZGV2U2VydmVyVXJsKShob3N0LCBcIi9kZXZcIik7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZldGNoKHVybC50b1N0cmluZygpKTtcbiAgICAgICAgYXdhaXQgcmVzdWx0Lmpzb24oKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZXZTZXJ2ZXJBdmFpbGFibGUgPSBkZXZTZXJ2ZXJBdmFpbGFibGU7XG4vKipcbiAqIGRldlNlcnZlclVybCByZXR1cm5zIGEgZnVsbCBVUkwgZm9yIHRoZSBnaXZlbiBwYXRoIG5hbWUuXG4gKlxuICogQmVjYXVzZSBDbG91ZGZsYXJlL1Y4IHBsYXRmb3JtcyBkb24ndCBhbGxvdyBwcm9jZXNzLmVudiwgeW91IGFyZSBleHBlY3RlZFxuICogdG8gcGFzcyBpbiB0aGUgaG9zdCBmcm9tIHRoZSBkZXYgc2VydmVyIGVudiBrZXk6XG4gKlxuICogQGV4YW1wbGUgZGV2U2VydmVyVXJsKHByb2Nlc3NFbnYoZW52S2V5cy5EZXZTZXJ2ZXJVcmwpLCBcIi95b3VyLXBhdGhcIilcbiAqIEBleGFtcGxlIGRldlNlcnZlclVybChcImh0dHA6Ly9sb2NhbGhvc3Q6ODI4OC9cIiwgXCIveW91ci1wYXRoXCIpXG4gKi9cbmNvbnN0IGRldlNlcnZlclVybCA9IChob3N0ID0gKDAsIGV4cG9ydHMuZGV2U2VydmVySG9zdCkoKSwgcGF0aG5hbWUgPSBcIlwiKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBVUkwocGF0aG5hbWUsIGhvc3QuaW5jbHVkZXMoXCI6Ly9cIikgPyBob3N0IDogYGh0dHA6Ly8ke2hvc3R9YCk7XG59O1xuZXhwb3J0cy5kZXZTZXJ2ZXJVcmwgPSBkZXZTZXJ2ZXJVcmw7XG4vKipcbiAqIGRldlNlcnZlckhvc3QgZXhwb3J0cyB0aGUgZGV2ZWxvcG1lbnQgc2VydmVyJ3MgZG9tYWluIGJ5IGluc3BlY3RpbmcgZW52XG4gKiB2YXJpYWJsZXMsIG9yIHJldHVybnMgdGhlIGRlZmF1bHQgZGV2ZWxvcG1lbnQgc2VydmVyIFVSTC5cbiAqXG4gKiBUaGlzIGd1YXJhbnRlZXMgYSBzcGVjaWZpYyBVUkwgYXMgYSBzdHJpbmcsIGFzIG9wcG9zZWQgdG8gdGhlIGVudiBleHBvcnRcbiAqIHdoaWNoIG9ubHkgcmV0dXJucyBhIHZhbHVlIG9mIHRoZSBlbnYgdmFyIGlzIHNldC5cbiAqL1xuY29uc3QgZGV2U2VydmVySG9zdCA9ICgpID0+ICgwLCBlbnZfanNfMS5kZXZTZXJ2ZXJIb3N0KSgpIHx8IGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0O1xuZXhwb3J0cy5kZXZTZXJ2ZXJIb3N0ID0gZGV2U2VydmVySG9zdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRldnNlcnZlci5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/devserver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/enum.js":
/*!**********************************************!*\
  !*** ./node_modules/inngest/helpers/enum.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enumFromValue = void 0;\n/**\n * Returns the value of an enum from a string value.\n *\n * If the value given is not a value from the enum, `undefined` is returned.\n */\nconst enumFromValue = (enumType, value) => {\n    if (Object.values(enumType).includes(value)) {\n        return value;\n    }\n};\nexports.enumFromValue = enumFromValue;\n//# sourceMappingURL=enum.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2VudW0uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCIiwic291cmNlcyI6WyIvVXNlcnMvaGFyc2hzaHJpdmFzdGF2L0Rlc2t0b3AvQ29kaW5nIFByb2plY3RzL0pvYi1Bc3Npc3RhbnQtQWdlbnQvbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9lbnVtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5lbnVtRnJvbVZhbHVlID0gdm9pZCAwO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhbiBlbnVtIGZyb20gYSBzdHJpbmcgdmFsdWUuXG4gKlxuICogSWYgdGhlIHZhbHVlIGdpdmVuIGlzIG5vdCBhIHZhbHVlIGZyb20gdGhlIGVudW0sIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICovXG5jb25zdCBlbnVtRnJvbVZhbHVlID0gKGVudW1UeXBlLCB2YWx1ZSkgPT4ge1xuICAgIGlmIChPYmplY3QudmFsdWVzKGVudW1UeXBlKS5pbmNsdWRlcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn07XG5leHBvcnRzLmVudW1Gcm9tVmFsdWUgPSBlbnVtRnJvbVZhbHVlO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW51bS5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/enum.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/env.js":
/*!*********************************************!*\
  !*** ./node_modules/inngest/helpers/env.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n// This file exists to help normalize process.env amongst the backend\n// and frontend.  Many frontends (eg. Next, CRA) utilize webpack's DefinePlugin\n// along with prefixes, meaning we have to explicitly use the full `process.env.FOO`\n// string in order to read variables.\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseAsBoolean = exports.getResponse = exports.getFetch = exports.platformSupportsStreaming = exports.getPlatformName = exports.inngestHeaders = exports.allProcessEnv = exports.processEnv = exports.getEnvironmentName = exports.getMode = exports.Mode = exports.devServerHost = void 0;\nconst version_js_1 = __webpack_require__(/*! ../version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nconst consts_js_1 = __webpack_require__(/*! ./consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nconst strings_js_1 = __webpack_require__(/*! ./strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/**\n * devServerHost returns the dev server host by searching for the INNGEST_DEVSERVER_URL\n * environment variable (plus project prefixces for eg. react, such as REACT_APP_INNGEST_DEVSERVER_URL).\n *\n * If not found this returns undefined, indicating that the env var has not been set.\n *\n * @example devServerHost()\n */\nconst devServerHost = (env = (0, exports.allProcessEnv)()) => {\n    // devServerKeys are the env keys we search for to discover the dev server\n    // URL.  This includes the standard key first, then includes prefixed keys\n    // for use within common frameworks (eg. CRA, next).\n    //\n    // We have to fully write these using process.env as they're typically\n    // processed using webpack's DefinePlugin, which is dumb and does a straight\n    // text replacement instead of actually understanding the AST, despite webpack\n    // being fully capable of understanding the AST.\n    const prefixes = [\"REACT_APP_\", \"NEXT_PUBLIC_\"];\n    const keys = [consts_js_1.envKeys.InngestBaseUrl, consts_js_1.envKeys.InngestDevMode];\n    const values = keys.flatMap((key) => {\n        return prefixes.map((prefix) => {\n            return env[prefix + key];\n        });\n    });\n    return values.find((v) => {\n        if (!v) {\n            return;\n        }\n        try {\n            return Boolean(new URL(v));\n        }\n        catch (_a) {\n            // no-op\n        }\n    });\n};\nexports.devServerHost = devServerHost;\nconst checkFns = ((checks) => checks)({\n    equals: (actual, expected) => actual === expected,\n    \"starts with\": (actual, expected) => { var _a; return expected ? (_a = actual === null || actual === void 0 ? void 0 : actual.startsWith(expected)) !== null && _a !== void 0 ? _a : false : false; },\n    \"is truthy\": (actual) => Boolean(actual),\n    \"is truthy but not\": (actual, expected) => Boolean(actual) && actual !== expected,\n});\nconst prodChecks = [\n    [\"CF_PAGES\", \"equals\", \"1\"],\n    [\"CONTEXT\", \"starts with\", \"prod\"],\n    [\"ENVIRONMENT\", \"starts with\", \"prod\"],\n    [\"NODE_ENV\", \"starts with\", \"prod\"],\n    [\"VERCEL_ENV\", \"starts with\", \"prod\"],\n    [\"DENO_DEPLOYMENT_ID\", \"is truthy\"],\n    [consts_js_1.envKeys.VercelEnvKey, \"is truthy but not\", \"development\"],\n    [consts_js_1.envKeys.IsNetlify, \"is truthy\"],\n    [consts_js_1.envKeys.IsRender, \"is truthy\"],\n    [consts_js_1.envKeys.RailwayBranch, \"is truthy\"],\n    [consts_js_1.envKeys.IsCloudflarePages, \"is truthy\"],\n];\nclass Mode {\n    constructor({ type, isExplicit, explicitDevUrl, env = (0, exports.allProcessEnv)(), }) {\n        this.env = env;\n        this.type = type;\n        this.isExplicit = isExplicit || Boolean(explicitDevUrl);\n        this.explicitDevUrl = explicitDevUrl;\n    }\n    get isDev() {\n        return this.type === \"dev\";\n    }\n    get isCloud() {\n        return this.type === \"cloud\";\n    }\n    get isInferred() {\n        return !this.isExplicit;\n    }\n    /**\n     * If we are explicitly in a particular mode, retrieve the URL that we are\n     * sure we should be using, not considering any environment variables or other\n     * influences.\n     */\n    getExplicitUrl(defaultCloudUrl) {\n        if (!this.isExplicit) {\n            return undefined;\n        }\n        if (this.explicitDevUrl) {\n            return this.explicitDevUrl.href;\n        }\n        if (this.isCloud) {\n            return defaultCloudUrl;\n        }\n        if (this.isDev) {\n            return consts_js_1.defaultDevServerHost;\n        }\n        return undefined;\n    }\n}\nexports.Mode = Mode;\n/**\n * Returns the mode of the current environment, based off of either passed\n * environment variables or `process.env`, or explicit settings.\n */\nconst getMode = ({ env = (0, exports.allProcessEnv)(), client, explicitMode, } = {}) => {\n    if (explicitMode) {\n        return new Mode({ type: explicitMode, isExplicit: true, env });\n    }\n    if (client === null || client === void 0 ? void 0 : client[\"mode\"].isExplicit) {\n        return client[\"mode\"];\n    }\n    if (consts_js_1.envKeys.InngestDevMode in env) {\n        if (typeof env[consts_js_1.envKeys.InngestDevMode] === \"string\") {\n            try {\n                const explicitDevUrl = new URL(env[consts_js_1.envKeys.InngestDevMode]);\n                return new Mode({ type: \"dev\", isExplicit: true, explicitDevUrl, env });\n            }\n            catch (_a) {\n                // no-op\n            }\n        }\n        const envIsDev = (0, exports.parseAsBoolean)(env[consts_js_1.envKeys.InngestDevMode]);\n        if (typeof envIsDev === \"boolean\") {\n            return new Mode({\n                type: envIsDev ? \"dev\" : \"cloud\",\n                isExplicit: true,\n                env,\n            });\n        }\n    }\n    const isProd = prodChecks.some(([key, checkKey, expected]) => {\n        return checkFns[checkKey]((0, strings_js_1.stringifyUnknown)(env[key]), expected);\n    });\n    return new Mode({ type: isProd ? \"cloud\" : \"dev\", isExplicit: false, env });\n};\nexports.getMode = getMode;\n/**\n * getEnvironmentName returns the suspected branch name for this environment by\n * searching through a set of common environment variables.\n *\n * This could be used to determine if we're on a branch deploy or not, though it\n * should be noted that we don't know if this is the default branch or not.\n */\nconst getEnvironmentName = (env = (0, exports.allProcessEnv)()) => {\n    /**\n     * Order is important; more than one of these env vars may be set, so ensure\n     * that we check the most specific, most reliable env vars first.\n     */\n    return (env[consts_js_1.envKeys.InngestEnvironment] ||\n        env[consts_js_1.envKeys.BranchName] ||\n        env[consts_js_1.envKeys.VercelBranch] ||\n        env[consts_js_1.envKeys.NetlifyBranch] ||\n        env[consts_js_1.envKeys.CloudflarePagesBranch] ||\n        env[consts_js_1.envKeys.RenderBranch] ||\n        env[consts_js_1.envKeys.RailwayBranch]);\n};\nexports.getEnvironmentName = getEnvironmentName;\nconst processEnv = (key) => {\n    return (0, exports.allProcessEnv)()[key];\n};\nexports.processEnv = processEnv;\n/**\n * allProcessEnv returns the current process environment variables, or an empty\n * object if they cannot be read, making sure we support environments other than\n * Node such as Deno, too.\n *\n * Using this ensures we don't dangerously access `process.env` in environments\n * where it may not be defined, such as Deno or the browser.\n */\nconst allProcessEnv = () => {\n    // Node, or Node-like environments\n    try {\n        // eslint-disable-next-line @inngest/internal/process-warn\n        if (process.env) {\n            // eslint-disable-next-line @inngest/internal/process-warn\n            return process.env;\n        }\n    }\n    catch (_err) {\n        // noop\n    }\n    // Deno\n    try {\n        const env = Deno.env.toObject();\n        if (env) {\n            return env;\n        }\n    }\n    catch (_err) {\n        // noop\n    }\n    // Netlify\n    try {\n        const env = Netlify.env.toObject();\n        if (env) {\n            return env;\n        }\n    }\n    catch (_err) {\n        // noop\n    }\n    return {};\n};\nexports.allProcessEnv = allProcessEnv;\n/**\n * Generate a standardised set of headers based on input and environment\n * variables.\n *\n *\n */\nconst inngestHeaders = (opts) => {\n    var _a;\n    const sdkVersion = `inngest-js:v${version_js_1.version}`;\n    const headers = {\n        \"Content-Type\": \"application/json\",\n        \"User-Agent\": sdkVersion,\n        [consts_js_1.headerKeys.SdkVersion]: sdkVersion,\n    };\n    if (opts === null || opts === void 0 ? void 0 : opts.framework) {\n        headers[consts_js_1.headerKeys.Framework] = opts.framework;\n    }\n    if (opts === null || opts === void 0 ? void 0 : opts.expectedServerKind) {\n        headers[consts_js_1.headerKeys.InngestExpectedServerKind] = opts.expectedServerKind;\n    }\n    const env = Object.assign(Object.assign({}, (0, exports.allProcessEnv)()), opts === null || opts === void 0 ? void 0 : opts.env);\n    const inngestEnv = (opts === null || opts === void 0 ? void 0 : opts.inngestEnv) || (0, exports.getEnvironmentName)(env);\n    if (inngestEnv) {\n        headers[consts_js_1.headerKeys.Environment] = inngestEnv;\n    }\n    const platform = (0, exports.getPlatformName)(env);\n    if (platform) {\n        headers[consts_js_1.headerKeys.Platform] = platform;\n    }\n    return Object.assign(Object.assign(Object.assign({}, headers), (_a = opts === null || opts === void 0 ? void 0 : opts.client) === null || _a === void 0 ? void 0 : _a[\"headers\"]), opts === null || opts === void 0 ? void 0 : opts.extras);\n};\nexports.inngestHeaders = inngestHeaders;\n/**\n * A set of checks that, given an environment, will return `true` if the current\n * environment is running on the platform with the given name.\n */\nconst platformChecks = {\n    /**\n     * Vercel Edge Functions don't have access to environment variables unless\n     * they are explicitly referenced in the top level code, but they do have a\n     * global `EdgeRuntime` variable set that we can use to detect this.\n     */\n    vercel: (env) => env[consts_js_1.envKeys.IsVercel] === \"1\" || typeof EdgeRuntime === \"string\",\n    netlify: (env) => env[consts_js_1.envKeys.IsNetlify] === \"true\",\n    \"cloudflare-pages\": (env) => env[consts_js_1.envKeys.IsCloudflarePages] === \"1\",\n    render: (env) => env[consts_js_1.envKeys.IsRender] === \"true\",\n    railway: (env) => Boolean(env[consts_js_1.envKeys.RailwayEnvironment]),\n};\n/**\n * A set of checks that, given an environment, will return `true` if the current\n * environment and platform supports streaming responses back to Inngest.\n *\n * Streaming capability is both framework and platform-based. Frameworks are\n * supported in serve handlers, and platforms are checked here.\n *\n * As such, this record declares which platforms we explicitly support for\n * streaming and is used by {@link platformSupportsStreaming}.\n */\nconst streamingChecks = {\n    /**\n     * \"Vercel supports streaming for Serverless Functions, Edge Functions, and\n     * React Server Components in Next.js projects.\"\n     *\n     * In practice, however, there are many reports of streaming not working as\n     * expected on Serverless Functions, so we resort to only allowing streaming\n     * for Edge Functions here.\n     *\n     * See {@link https://vercel.com/docs/frameworks/nextjs#streaming}\n     */\n    vercel: (_framework, _env) => typeof EdgeRuntime === \"string\",\n    \"cloudflare-pages\": () => true,\n};\nconst getPlatformName = (env) => {\n    return Object.keys(platformChecks).find((key) => {\n        return platformChecks[key](env);\n    });\n};\nexports.getPlatformName = getPlatformName;\n/**\n * Returns `true` if we believe the current environment supports streaming\n * responses back to Inngest.\n *\n * We run a check directly related to the platform we believe we're running on,\n * usually based on environment variables.\n */\nconst platformSupportsStreaming = (framework, env = (0, exports.allProcessEnv)()) => {\n    var _a, _b;\n    return ((_b = (_a = streamingChecks[(0, exports.getPlatformName)(env)]) === null || _a === void 0 ? void 0 : _a.call(streamingChecks, framework, env)) !== null && _b !== void 0 ? _b : false);\n};\nexports.platformSupportsStreaming = platformSupportsStreaming;\n/**\n * A unique symbol used to mark a custom fetch implementation. We wrap the\n * implementations to provide some extra control when handling errors.\n */\nconst CUSTOM_FETCH_MARKER = Symbol(\"Custom fetch implementation\");\n/**\n * Given a potential fetch function, return the fetch function to use based on\n * this and the environment.\n */\nconst getFetch = (givenFetch) => {\n    /**\n     * If we've explicitly been given a fetch function, use that.\n     */\n    if (givenFetch) {\n        if (CUSTOM_FETCH_MARKER in givenFetch) {\n            return givenFetch;\n        }\n        /**\n         * We wrap the given fetch function to provide some extra control when\n         * handling errors.\n         */\n        const customFetch = async (...args) => {\n            var _a;\n            try {\n                return await givenFetch(...args);\n            }\n            catch (err) {\n                /**\n                 * Capture warnings that are not simple fetch failures and highlight\n                 * them for the user.\n                 *\n                 * We also use this opportunity to log the causing error, as code higher\n                 * up the stack will likely abstract this.\n                 */\n                if (!(err instanceof Error) ||\n                    !((_a = err.message) === null || _a === void 0 ? void 0 : _a.startsWith(\"fetch failed\"))) {\n                    console.warn(\"A request failed when using a custom fetch implementation; this may be a misconfiguration. Make sure that your fetch client is correctly bound to the global scope.\");\n                    console.error(err);\n                }\n                throw err;\n            }\n        };\n        /**\n         * Mark the custom fetch implementation so that we can identify it later, in\n         * addition to adding some runtime properties to it to make it seem as much\n         * like the original fetch as possible.\n         */\n        Object.defineProperties(customFetch, {\n            [CUSTOM_FETCH_MARKER]: {},\n            name: { value: givenFetch.name },\n            length: { value: givenFetch.length },\n        });\n        return customFetch;\n    }\n    /**\n     * Browser or Node 18+\n     */\n    try {\n        if (typeof globalThis !== \"undefined\" && \"fetch\" in globalThis) {\n            return fetch.bind(globalThis);\n        }\n    }\n    catch (err) {\n        // no-op\n    }\n    /**\n     * Existing polyfilled fetch\n     */\n    if (typeof fetch !== \"undefined\") {\n        return fetch;\n    }\n    /**\n     * Environments where fetch cannot be found and must be polyfilled\n     */\n    // eslint-disable-next-line @typescript-eslint/no-var-requires\n    return __webpack_require__(/*! cross-fetch */ \"(rsc)/./node_modules/cross-fetch/dist/node-ponyfill.js\");\n};\nexports.getFetch = getFetch;\n/**\n * If `Response` isn't included in this environment, it's probably an earlier\n * Node env that isn't already polyfilling. This function returns either the\n * native `Response` or a polyfilled one.\n */\nconst getResponse = () => {\n    if (typeof Response !== \"undefined\") {\n        return Response;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return, @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-var-requires\n    return (__webpack_require__(/*! cross-fetch */ \"(rsc)/./node_modules/cross-fetch/dist/node-ponyfill.js\").Response);\n};\nexports.getResponse = getResponse;\n/**\n * Given an unknown value, try to parse it as a `boolean`. Useful for parsing\n * environment variables that could be a selection of different values such as\n * `\"true\"`, `\"1\"`.\n *\n * If the value could not be confidently parsed as a `boolean` or was seen to be\n * `undefined`, this function returns `undefined`.\n */\nconst parseAsBoolean = (value) => {\n    if (typeof value === \"boolean\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return Boolean(value);\n    }\n    if (typeof value === \"string\") {\n        const trimmed = value.trim().toLowerCase();\n        if (trimmed === \"undefined\") {\n            return undefined;\n        }\n        if ([\"true\", \"1\"].includes(trimmed)) {\n            return true;\n        }\n        return false;\n    }\n    return undefined;\n};\nexports.parseAsBoolean = parseAsBoolean;\n//# sourceMappingURL=env.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Vudi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHNCQUFzQixHQUFHLG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLGlDQUFpQyxHQUFHLHVCQUF1QixHQUFHLHNCQUFzQixHQUFHLHFCQUFxQixHQUFHLGtCQUFrQixHQUFHLDBCQUEwQixHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcscUJBQXFCO0FBQ3pSLHFCQUFxQixtQkFBTyxDQUFDLDhEQUFlO0FBQzVDLG9CQUFvQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3pDLHFCQUFxQixtQkFBTyxDQUFDLHFFQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsMkNBQTJDLFFBQVEsc0pBQXNKO0FBQ3pNO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1RUFBdUU7QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0REFBNEQsSUFBSTtBQUNuRjtBQUNBLDBCQUEwQiwyQ0FBMkM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxvREFBb0Q7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0Isd0RBQXdEO0FBQzlFO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MscUJBQXFCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsZ0NBQWdDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMsb0JBQW9CLHdCQUF3QjtBQUM1QyxzQkFBc0IsMEJBQTBCO0FBQ2hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLDJFQUFhO0FBQ2hDO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyR0FBK0I7QUFDMUM7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCIiwic291cmNlcyI6WyIvVXNlcnMvaGFyc2hzaHJpdmFzdGF2L0Rlc2t0b3AvQ29kaW5nIFByb2plY3RzL0pvYi1Bc3Npc3RhbnQtQWdlbnQvbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9lbnYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBUaGlzIGZpbGUgZXhpc3RzIHRvIGhlbHAgbm9ybWFsaXplIHByb2Nlc3MuZW52IGFtb25nc3QgdGhlIGJhY2tlbmRcbi8vIGFuZCBmcm9udGVuZC4gIE1hbnkgZnJvbnRlbmRzIChlZy4gTmV4dCwgQ1JBKSB1dGlsaXplIHdlYnBhY2sncyBEZWZpbmVQbHVnaW5cbi8vIGFsb25nIHdpdGggcHJlZml4ZXMsIG1lYW5pbmcgd2UgaGF2ZSB0byBleHBsaWNpdGx5IHVzZSB0aGUgZnVsbCBgcHJvY2Vzcy5lbnYuRk9PYFxuLy8gc3RyaW5nIGluIG9yZGVyIHRvIHJlYWQgdmFyaWFibGVzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUFzQm9vbGVhbiA9IGV4cG9ydHMuZ2V0UmVzcG9uc2UgPSBleHBvcnRzLmdldEZldGNoID0gZXhwb3J0cy5wbGF0Zm9ybVN1cHBvcnRzU3RyZWFtaW5nID0gZXhwb3J0cy5nZXRQbGF0Zm9ybU5hbWUgPSBleHBvcnRzLmlubmdlc3RIZWFkZXJzID0gZXhwb3J0cy5hbGxQcm9jZXNzRW52ID0gZXhwb3J0cy5wcm9jZXNzRW52ID0gZXhwb3J0cy5nZXRFbnZpcm9ubWVudE5hbWUgPSBleHBvcnRzLmdldE1vZGUgPSBleHBvcnRzLk1vZGUgPSBleHBvcnRzLmRldlNlcnZlckhvc3QgPSB2b2lkIDA7XG5jb25zdCB2ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi4vdmVyc2lvbi5qc1wiKTtcbmNvbnN0IGNvbnN0c19qc18xID0gcmVxdWlyZShcIi4vY29uc3RzLmpzXCIpO1xuY29uc3Qgc3RyaW5nc19qc18xID0gcmVxdWlyZShcIi4vc3RyaW5ncy5qc1wiKTtcbi8qKlxuICogZGV2U2VydmVySG9zdCByZXR1cm5zIHRoZSBkZXYgc2VydmVyIGhvc3QgYnkgc2VhcmNoaW5nIGZvciB0aGUgSU5OR0VTVF9ERVZTRVJWRVJfVVJMXG4gKiBlbnZpcm9ubWVudCB2YXJpYWJsZSAocGx1cyBwcm9qZWN0IHByZWZpeGNlcyBmb3IgZWcuIHJlYWN0LCBzdWNoIGFzIFJFQUNUX0FQUF9JTk5HRVNUX0RFVlNFUlZFUl9VUkwpLlxuICpcbiAqIElmIG5vdCBmb3VuZCB0aGlzIHJldHVybnMgdW5kZWZpbmVkLCBpbmRpY2F0aW5nIHRoYXQgdGhlIGVudiB2YXIgaGFzIG5vdCBiZWVuIHNldC5cbiAqXG4gKiBAZXhhbXBsZSBkZXZTZXJ2ZXJIb3N0KClcbiAqL1xuY29uc3QgZGV2U2VydmVySG9zdCA9IChlbnYgPSAoMCwgZXhwb3J0cy5hbGxQcm9jZXNzRW52KSgpKSA9PiB7XG4gICAgLy8gZGV2U2VydmVyS2V5cyBhcmUgdGhlIGVudiBrZXlzIHdlIHNlYXJjaCBmb3IgdG8gZGlzY292ZXIgdGhlIGRldiBzZXJ2ZXJcbiAgICAvLyBVUkwuICBUaGlzIGluY2x1ZGVzIHRoZSBzdGFuZGFyZCBrZXkgZmlyc3QsIHRoZW4gaW5jbHVkZXMgcHJlZml4ZWQga2V5c1xuICAgIC8vIGZvciB1c2Ugd2l0aGluIGNvbW1vbiBmcmFtZXdvcmtzIChlZy4gQ1JBLCBuZXh0KS5cbiAgICAvL1xuICAgIC8vIFdlIGhhdmUgdG8gZnVsbHkgd3JpdGUgdGhlc2UgdXNpbmcgcHJvY2Vzcy5lbnYgYXMgdGhleSdyZSB0eXBpY2FsbHlcbiAgICAvLyBwcm9jZXNzZWQgdXNpbmcgd2VicGFjaydzIERlZmluZVBsdWdpbiwgd2hpY2ggaXMgZHVtYiBhbmQgZG9lcyBhIHN0cmFpZ2h0XG4gICAgLy8gdGV4dCByZXBsYWNlbWVudCBpbnN0ZWFkIG9mIGFjdHVhbGx5IHVuZGVyc3RhbmRpbmcgdGhlIEFTVCwgZGVzcGl0ZSB3ZWJwYWNrXG4gICAgLy8gYmVpbmcgZnVsbHkgY2FwYWJsZSBvZiB1bmRlcnN0YW5kaW5nIHRoZSBBU1QuXG4gICAgY29uc3QgcHJlZml4ZXMgPSBbXCJSRUFDVF9BUFBfXCIsIFwiTkVYVF9QVUJMSUNfXCJdO1xuICAgIGNvbnN0IGtleXMgPSBbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0QmFzZVVybCwgY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RGV2TW9kZV07XG4gICAgY29uc3QgdmFsdWVzID0ga2V5cy5mbGF0TWFwKChrZXkpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZWZpeGVzLm1hcCgocHJlZml4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZW52W3ByZWZpeCArIGtleV07XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXMuZmluZCgodikgPT4ge1xuICAgICAgICBpZiAoIXYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4obmV3IFVSTCh2KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0cy5kZXZTZXJ2ZXJIb3N0ID0gZGV2U2VydmVySG9zdDtcbmNvbnN0IGNoZWNrRm5zID0gKChjaGVja3MpID0+IGNoZWNrcykoe1xuICAgIGVxdWFsczogKGFjdHVhbCwgZXhwZWN0ZWQpID0+IGFjdHVhbCA9PT0gZXhwZWN0ZWQsXG4gICAgXCJzdGFydHMgd2l0aFwiOiAoYWN0dWFsLCBleHBlY3RlZCkgPT4geyB2YXIgX2E7IHJldHVybiBleHBlY3RlZCA/IChfYSA9IGFjdHVhbCA9PT0gbnVsbCB8fCBhY3R1YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFjdHVhbC5zdGFydHNXaXRoKGV4cGVjdGVkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmFsc2UgOiBmYWxzZTsgfSxcbiAgICBcImlzIHRydXRoeVwiOiAoYWN0dWFsKSA9PiBCb29sZWFuKGFjdHVhbCksXG4gICAgXCJpcyB0cnV0aHkgYnV0IG5vdFwiOiAoYWN0dWFsLCBleHBlY3RlZCkgPT4gQm9vbGVhbihhY3R1YWwpICYmIGFjdHVhbCAhPT0gZXhwZWN0ZWQsXG59KTtcbmNvbnN0IHByb2RDaGVja3MgPSBbXG4gICAgW1wiQ0ZfUEFHRVNcIiwgXCJlcXVhbHNcIiwgXCIxXCJdLFxuICAgIFtcIkNPTlRFWFRcIiwgXCJzdGFydHMgd2l0aFwiLCBcInByb2RcIl0sXG4gICAgW1wiRU5WSVJPTk1FTlRcIiwgXCJzdGFydHMgd2l0aFwiLCBcInByb2RcIl0sXG4gICAgW1wiTk9ERV9FTlZcIiwgXCJzdGFydHMgd2l0aFwiLCBcInByb2RcIl0sXG4gICAgW1wiVkVSQ0VMX0VOVlwiLCBcInN0YXJ0cyB3aXRoXCIsIFwicHJvZFwiXSxcbiAgICBbXCJERU5PX0RFUExPWU1FTlRfSURcIiwgXCJpcyB0cnV0aHlcIl0sXG4gICAgW2NvbnN0c19qc18xLmVudktleXMuVmVyY2VsRW52S2V5LCBcImlzIHRydXRoeSBidXQgbm90XCIsIFwiZGV2ZWxvcG1lbnRcIl0sXG4gICAgW2NvbnN0c19qc18xLmVudktleXMuSXNOZXRsaWZ5LCBcImlzIHRydXRoeVwiXSxcbiAgICBbY29uc3RzX2pzXzEuZW52S2V5cy5Jc1JlbmRlciwgXCJpcyB0cnV0aHlcIl0sXG4gICAgW2NvbnN0c19qc18xLmVudktleXMuUmFpbHdheUJyYW5jaCwgXCJpcyB0cnV0aHlcIl0sXG4gICAgW2NvbnN0c19qc18xLmVudktleXMuSXNDbG91ZGZsYXJlUGFnZXMsIFwiaXMgdHJ1dGh5XCJdLFxuXTtcbmNsYXNzIE1vZGUge1xuICAgIGNvbnN0cnVjdG9yKHsgdHlwZSwgaXNFeHBsaWNpdCwgZXhwbGljaXREZXZVcmwsIGVudiA9ICgwLCBleHBvcnRzLmFsbFByb2Nlc3NFbnYpKCksIH0pIHtcbiAgICAgICAgdGhpcy5lbnYgPSBlbnY7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaXNFeHBsaWNpdCA9IGlzRXhwbGljaXQgfHwgQm9vbGVhbihleHBsaWNpdERldlVybCk7XG4gICAgICAgIHRoaXMuZXhwbGljaXREZXZVcmwgPSBleHBsaWNpdERldlVybDtcbiAgICB9XG4gICAgZ2V0IGlzRGV2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBcImRldlwiO1xuICAgIH1cbiAgICBnZXQgaXNDbG91ZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHlwZSA9PT0gXCJjbG91ZFwiO1xuICAgIH1cbiAgICBnZXQgaXNJbmZlcnJlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmlzRXhwbGljaXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHdlIGFyZSBleHBsaWNpdGx5IGluIGEgcGFydGljdWxhciBtb2RlLCByZXRyaWV2ZSB0aGUgVVJMIHRoYXQgd2UgYXJlXG4gICAgICogc3VyZSB3ZSBzaG91bGQgYmUgdXNpbmcsIG5vdCBjb25zaWRlcmluZyBhbnkgZW52aXJvbm1lbnQgdmFyaWFibGVzIG9yIG90aGVyXG4gICAgICogaW5mbHVlbmNlcy5cbiAgICAgKi9cbiAgICBnZXRFeHBsaWNpdFVybChkZWZhdWx0Q2xvdWRVcmwpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRXhwbGljaXQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZXhwbGljaXREZXZVcmwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV4cGxpY2l0RGV2VXJsLmhyZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDbG91ZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRDbG91ZFVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc0Rldikge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnN0c19qc18xLmRlZmF1bHREZXZTZXJ2ZXJIb3N0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5Nb2RlID0gTW9kZTtcbi8qKlxuICogUmV0dXJucyB0aGUgbW9kZSBvZiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCwgYmFzZWQgb2ZmIG9mIGVpdGhlciBwYXNzZWRcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlcyBvciBgcHJvY2Vzcy5lbnZgLCBvciBleHBsaWNpdCBzZXR0aW5ncy5cbiAqL1xuY29uc3QgZ2V0TW9kZSA9ICh7IGVudiA9ICgwLCBleHBvcnRzLmFsbFByb2Nlc3NFbnYpKCksIGNsaWVudCwgZXhwbGljaXRNb2RlLCB9ID0ge30pID0+IHtcbiAgICBpZiAoZXhwbGljaXRNb2RlKSB7XG4gICAgICAgIHJldHVybiBuZXcgTW9kZSh7IHR5cGU6IGV4cGxpY2l0TW9kZSwgaXNFeHBsaWNpdDogdHJ1ZSwgZW52IH0pO1xuICAgIH1cbiAgICBpZiAoY2xpZW50ID09PSBudWxsIHx8IGNsaWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2xpZW50W1wibW9kZVwiXS5pc0V4cGxpY2l0KSB7XG4gICAgICAgIHJldHVybiBjbGllbnRbXCJtb2RlXCJdO1xuICAgIH1cbiAgICBpZiAoY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RGV2TW9kZSBpbiBlbnYpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jbm5nZXN0RGV2TW9kZV0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwbGljaXREZXZVcmwgPSBuZXcgVVJMKGVudltjb25zdHNfanNfMS5lbnZLZXlzLklubmdlc3REZXZNb2RlXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNb2RlKHsgdHlwZTogXCJkZXZcIiwgaXNFeHBsaWNpdDogdHJ1ZSwgZXhwbGljaXREZXZVcmwsIGVudiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW52SXNEZXYgPSAoMCwgZXhwb3J0cy5wYXJzZUFzQm9vbGVhbikoZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdERldk1vZGVdKTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnZJc0RldiA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9kZSh7XG4gICAgICAgICAgICAgICAgdHlwZTogZW52SXNEZXYgPyBcImRldlwiIDogXCJjbG91ZFwiLFxuICAgICAgICAgICAgICAgIGlzRXhwbGljaXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZW52LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaXNQcm9kID0gcHJvZENoZWNrcy5zb21lKChba2V5LCBjaGVja0tleSwgZXhwZWN0ZWRdKSA9PiB7XG4gICAgICAgIHJldHVybiBjaGVja0Zuc1tjaGVja0tleV0oKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnlVbmtub3duKShlbnZba2V5XSksIGV4cGVjdGVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IE1vZGUoeyB0eXBlOiBpc1Byb2QgPyBcImNsb3VkXCIgOiBcImRldlwiLCBpc0V4cGxpY2l0OiBmYWxzZSwgZW52IH0pO1xufTtcbmV4cG9ydHMuZ2V0TW9kZSA9IGdldE1vZGU7XG4vKipcbiAqIGdldEVudmlyb25tZW50TmFtZSByZXR1cm5zIHRoZSBzdXNwZWN0ZWQgYnJhbmNoIG5hbWUgZm9yIHRoaXMgZW52aXJvbm1lbnQgYnlcbiAqIHNlYXJjaGluZyB0aHJvdWdoIGEgc2V0IG9mIGNvbW1vbiBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogVGhpcyBjb3VsZCBiZSB1c2VkIHRvIGRldGVybWluZSBpZiB3ZSdyZSBvbiBhIGJyYW5jaCBkZXBsb3kgb3Igbm90LCB0aG91Z2ggaXRcbiAqIHNob3VsZCBiZSBub3RlZCB0aGF0IHdlIGRvbid0IGtub3cgaWYgdGhpcyBpcyB0aGUgZGVmYXVsdCBicmFuY2ggb3Igbm90LlxuICovXG5jb25zdCBnZXRFbnZpcm9ubWVudE5hbWUgPSAoZW52ID0gKDAsIGV4cG9ydHMuYWxsUHJvY2Vzc0VudikoKSkgPT4ge1xuICAgIC8qKlxuICAgICAqIE9yZGVyIGlzIGltcG9ydGFudDsgbW9yZSB0aGFuIG9uZSBvZiB0aGVzZSBlbnYgdmFycyBtYXkgYmUgc2V0LCBzbyBlbnN1cmVcbiAgICAgKiB0aGF0IHdlIGNoZWNrIHRoZSBtb3N0IHNwZWNpZmljLCBtb3N0IHJlbGlhYmxlIGVudiB2YXJzIGZpcnN0LlxuICAgICAqL1xuICAgIHJldHVybiAoZW52W2NvbnN0c19qc18xLmVudktleXMuSW5uZ2VzdEVudmlyb25tZW50XSB8fFxuICAgICAgICBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5CcmFuY2hOYW1lXSB8fFxuICAgICAgICBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5WZXJjZWxCcmFuY2hdIHx8XG4gICAgICAgIGVudltjb25zdHNfanNfMS5lbnZLZXlzLk5ldGxpZnlCcmFuY2hdIHx8XG4gICAgICAgIGVudltjb25zdHNfanNfMS5lbnZLZXlzLkNsb3VkZmxhcmVQYWdlc0JyYW5jaF0gfHxcbiAgICAgICAgZW52W2NvbnN0c19qc18xLmVudktleXMuUmVuZGVyQnJhbmNoXSB8fFxuICAgICAgICBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5SYWlsd2F5QnJhbmNoXSk7XG59O1xuZXhwb3J0cy5nZXRFbnZpcm9ubWVudE5hbWUgPSBnZXRFbnZpcm9ubWVudE5hbWU7XG5jb25zdCBwcm9jZXNzRW52ID0gKGtleSkgPT4ge1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5hbGxQcm9jZXNzRW52KSgpW2tleV07XG59O1xuZXhwb3J0cy5wcm9jZXNzRW52ID0gcHJvY2Vzc0Vudjtcbi8qKlxuICogYWxsUHJvY2Vzc0VudiByZXR1cm5zIHRoZSBjdXJyZW50IHByb2Nlc3MgZW52aXJvbm1lbnQgdmFyaWFibGVzLCBvciBhbiBlbXB0eVxuICogb2JqZWN0IGlmIHRoZXkgY2Fubm90IGJlIHJlYWQsIG1ha2luZyBzdXJlIHdlIHN1cHBvcnQgZW52aXJvbm1lbnRzIG90aGVyIHRoYW5cbiAqIE5vZGUgc3VjaCBhcyBEZW5vLCB0b28uXG4gKlxuICogVXNpbmcgdGhpcyBlbnN1cmVzIHdlIGRvbid0IGRhbmdlcm91c2x5IGFjY2VzcyBgcHJvY2Vzcy5lbnZgIGluIGVudmlyb25tZW50c1xuICogd2hlcmUgaXQgbWF5IG5vdCBiZSBkZWZpbmVkLCBzdWNoIGFzIERlbm8gb3IgdGhlIGJyb3dzZXIuXG4gKi9cbmNvbnN0IGFsbFByb2Nlc3NFbnYgPSAoKSA9PiB7XG4gICAgLy8gTm9kZSwgb3IgTm9kZS1saWtlIGVudmlyb25tZW50c1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAaW5uZ2VzdC9pbnRlcm5hbC9wcm9jZXNzLXdhcm5cbiAgICAgICAgaWYgKHByb2Nlc3MuZW52KSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGlubmdlc3QvaW50ZXJuYWwvcHJvY2Vzcy13YXJuXG4gICAgICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgLy8gbm9vcFxuICAgIH1cbiAgICAvLyBEZW5vXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgZW52ID0gRGVuby5lbnYudG9PYmplY3QoKTtcbiAgICAgICAgaWYgKGVudikge1xuICAgICAgICAgICAgcmV0dXJuIGVudjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICAvLyBub29wXG4gICAgfVxuICAgIC8vIE5ldGxpZnlcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBlbnYgPSBOZXRsaWZ5LmVudi50b09iamVjdCgpO1xuICAgICAgICBpZiAoZW52KSB7XG4gICAgICAgICAgICByZXR1cm4gZW52O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfZXJyKSB7XG4gICAgICAgIC8vIG5vb3BcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufTtcbmV4cG9ydHMuYWxsUHJvY2Vzc0VudiA9IGFsbFByb2Nlc3NFbnY7XG4vKipcbiAqIEdlbmVyYXRlIGEgc3RhbmRhcmRpc2VkIHNldCBvZiBoZWFkZXJzIGJhc2VkIG9uIGlucHV0IGFuZCBlbnZpcm9ubWVudFxuICogdmFyaWFibGVzLlxuICpcbiAqXG4gKi9cbmNvbnN0IGlubmdlc3RIZWFkZXJzID0gKG9wdHMpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc2RrVmVyc2lvbiA9IGBpbm5nZXN0LWpzOnYke3ZlcnNpb25fanNfMS52ZXJzaW9ufWA7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgIFwiVXNlci1BZ2VudFwiOiBzZGtWZXJzaW9uLFxuICAgICAgICBbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5TZGtWZXJzaW9uXTogc2RrVmVyc2lvbixcbiAgICB9O1xuICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZnJhbWV3b3JrKSB7XG4gICAgICAgIGhlYWRlcnNbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5GcmFtZXdvcmtdID0gb3B0cy5mcmFtZXdvcms7XG4gICAgfVxuICAgIGlmIChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZXhwZWN0ZWRTZXJ2ZXJLaW5kKSB7XG4gICAgICAgIGhlYWRlcnNbY29uc3RzX2pzXzEuaGVhZGVyS2V5cy5Jbm5nZXN0RXhwZWN0ZWRTZXJ2ZXJLaW5kXSA9IG9wdHMuZXhwZWN0ZWRTZXJ2ZXJLaW5kO1xuICAgIH1cbiAgICBjb25zdCBlbnYgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBleHBvcnRzLmFsbFByb2Nlc3NFbnYpKCkpLCBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZW52KTtcbiAgICBjb25zdCBpbm5nZXN0RW52ID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5pbm5nZXN0RW52KSB8fCAoMCwgZXhwb3J0cy5nZXRFbnZpcm9ubWVudE5hbWUpKGVudik7XG4gICAgaWYgKGlubmdlc3RFbnYpIHtcbiAgICAgICAgaGVhZGVyc1tjb25zdHNfanNfMS5oZWFkZXJLZXlzLkVudmlyb25tZW50XSA9IGlubmdlc3RFbnY7XG4gICAgfVxuICAgIGNvbnN0IHBsYXRmb3JtID0gKDAsIGV4cG9ydHMuZ2V0UGxhdGZvcm1OYW1lKShlbnYpO1xuICAgIGlmIChwbGF0Zm9ybSkge1xuICAgICAgICBoZWFkZXJzW2NvbnN0c19qc18xLmhlYWRlcktleXMuUGxhdGZvcm1dID0gcGxhdGZvcm07XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgaGVhZGVycyksIChfYSA9IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5jbGllbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtcImhlYWRlcnNcIl0pLCBvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMuZXh0cmFzKTtcbn07XG5leHBvcnRzLmlubmdlc3RIZWFkZXJzID0gaW5uZ2VzdEhlYWRlcnM7XG4vKipcbiAqIEEgc2V0IG9mIGNoZWNrcyB0aGF0LCBnaXZlbiBhbiBlbnZpcm9ubWVudCwgd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBjdXJyZW50XG4gKiBlbnZpcm9ubWVudCBpcyBydW5uaW5nIG9uIHRoZSBwbGF0Zm9ybSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxuICovXG5jb25zdCBwbGF0Zm9ybUNoZWNrcyA9IHtcbiAgICAvKipcbiAgICAgKiBWZXJjZWwgRWRnZSBGdW5jdGlvbnMgZG9uJ3QgaGF2ZSBhY2Nlc3MgdG8gZW52aXJvbm1lbnQgdmFyaWFibGVzIHVubGVzc1xuICAgICAqIHRoZXkgYXJlIGV4cGxpY2l0bHkgcmVmZXJlbmNlZCBpbiB0aGUgdG9wIGxldmVsIGNvZGUsIGJ1dCB0aGV5IGRvIGhhdmUgYVxuICAgICAqIGdsb2JhbCBgRWRnZVJ1bnRpbWVgIHZhcmlhYmxlIHNldCB0aGF0IHdlIGNhbiB1c2UgdG8gZGV0ZWN0IHRoaXMuXG4gICAgICovXG4gICAgdmVyY2VsOiAoZW52KSA9PiBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jc1ZlcmNlbF0gPT09IFwiMVwiIHx8IHR5cGVvZiBFZGdlUnVudGltZSA9PT0gXCJzdHJpbmdcIixcbiAgICBuZXRsaWZ5OiAoZW52KSA9PiBlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5Jc05ldGxpZnldID09PSBcInRydWVcIixcbiAgICBcImNsb3VkZmxhcmUtcGFnZXNcIjogKGVudikgPT4gZW52W2NvbnN0c19qc18xLmVudktleXMuSXNDbG91ZGZsYXJlUGFnZXNdID09PSBcIjFcIixcbiAgICByZW5kZXI6IChlbnYpID0+IGVudltjb25zdHNfanNfMS5lbnZLZXlzLklzUmVuZGVyXSA9PT0gXCJ0cnVlXCIsXG4gICAgcmFpbHdheTogKGVudikgPT4gQm9vbGVhbihlbnZbY29uc3RzX2pzXzEuZW52S2V5cy5SYWlsd2F5RW52aXJvbm1lbnRdKSxcbn07XG4vKipcbiAqIEEgc2V0IG9mIGNoZWNrcyB0aGF0LCBnaXZlbiBhbiBlbnZpcm9ubWVudCwgd2lsbCByZXR1cm4gYHRydWVgIGlmIHRoZSBjdXJyZW50XG4gKiBlbnZpcm9ubWVudCBhbmQgcGxhdGZvcm0gc3VwcG9ydHMgc3RyZWFtaW5nIHJlc3BvbnNlcyBiYWNrIHRvIElubmdlc3QuXG4gKlxuICogU3RyZWFtaW5nIGNhcGFiaWxpdHkgaXMgYm90aCBmcmFtZXdvcmsgYW5kIHBsYXRmb3JtLWJhc2VkLiBGcmFtZXdvcmtzIGFyZVxuICogc3VwcG9ydGVkIGluIHNlcnZlIGhhbmRsZXJzLCBhbmQgcGxhdGZvcm1zIGFyZSBjaGVja2VkIGhlcmUuXG4gKlxuICogQXMgc3VjaCwgdGhpcyByZWNvcmQgZGVjbGFyZXMgd2hpY2ggcGxhdGZvcm1zIHdlIGV4cGxpY2l0bHkgc3VwcG9ydCBmb3JcbiAqIHN0cmVhbWluZyBhbmQgaXMgdXNlZCBieSB7QGxpbmsgcGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZ30uXG4gKi9cbmNvbnN0IHN0cmVhbWluZ0NoZWNrcyA9IHtcbiAgICAvKipcbiAgICAgKiBcIlZlcmNlbCBzdXBwb3J0cyBzdHJlYW1pbmcgZm9yIFNlcnZlcmxlc3MgRnVuY3Rpb25zLCBFZGdlIEZ1bmN0aW9ucywgYW5kXG4gICAgICogUmVhY3QgU2VydmVyIENvbXBvbmVudHMgaW4gTmV4dC5qcyBwcm9qZWN0cy5cIlxuICAgICAqXG4gICAgICogSW4gcHJhY3RpY2UsIGhvd2V2ZXIsIHRoZXJlIGFyZSBtYW55IHJlcG9ydHMgb2Ygc3RyZWFtaW5nIG5vdCB3b3JraW5nIGFzXG4gICAgICogZXhwZWN0ZWQgb24gU2VydmVybGVzcyBGdW5jdGlvbnMsIHNvIHdlIHJlc29ydCB0byBvbmx5IGFsbG93aW5nIHN0cmVhbWluZ1xuICAgICAqIGZvciBFZGdlIEZ1bmN0aW9ucyBoZXJlLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL3ZlcmNlbC5jb20vZG9jcy9mcmFtZXdvcmtzL25leHRqcyNzdHJlYW1pbmd9XG4gICAgICovXG4gICAgdmVyY2VsOiAoX2ZyYW1ld29yaywgX2VudikgPT4gdHlwZW9mIEVkZ2VSdW50aW1lID09PSBcInN0cmluZ1wiLFxuICAgIFwiY2xvdWRmbGFyZS1wYWdlc1wiOiAoKSA9PiB0cnVlLFxufTtcbmNvbnN0IGdldFBsYXRmb3JtTmFtZSA9IChlbnYpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMocGxhdGZvcm1DaGVja3MpLmZpbmQoKGtleSkgPT4ge1xuICAgICAgICByZXR1cm4gcGxhdGZvcm1DaGVja3Nba2V5XShlbnYpO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuZ2V0UGxhdGZvcm1OYW1lID0gZ2V0UGxhdGZvcm1OYW1lO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCBpZiB3ZSBiZWxpZXZlIHRoZSBjdXJyZW50IGVudmlyb25tZW50IHN1cHBvcnRzIHN0cmVhbWluZ1xuICogcmVzcG9uc2VzIGJhY2sgdG8gSW5uZ2VzdC5cbiAqXG4gKiBXZSBydW4gYSBjaGVjayBkaXJlY3RseSByZWxhdGVkIHRvIHRoZSBwbGF0Zm9ybSB3ZSBiZWxpZXZlIHdlJ3JlIHJ1bm5pbmcgb24sXG4gKiB1c3VhbGx5IGJhc2VkIG9uIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqL1xuY29uc3QgcGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZyA9IChmcmFtZXdvcmssIGVudiA9ICgwLCBleHBvcnRzLmFsbFByb2Nlc3NFbnYpKCkpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoKF9iID0gKF9hID0gc3RyZWFtaW5nQ2hlY2tzWygwLCBleHBvcnRzLmdldFBsYXRmb3JtTmFtZSkoZW52KV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHN0cmVhbWluZ0NoZWNrcywgZnJhbWV3b3JrLCBlbnYpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSk7XG59O1xuZXhwb3J0cy5wbGF0Zm9ybVN1cHBvcnRzU3RyZWFtaW5nID0gcGxhdGZvcm1TdXBwb3J0c1N0cmVhbWluZztcbi8qKlxuICogQSB1bmlxdWUgc3ltYm9sIHVzZWQgdG8gbWFyayBhIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbi4gV2Ugd3JhcCB0aGVcbiAqIGltcGxlbWVudGF0aW9ucyB0byBwcm92aWRlIHNvbWUgZXh0cmEgY29udHJvbCB3aGVuIGhhbmRsaW5nIGVycm9ycy5cbiAqL1xuY29uc3QgQ1VTVE9NX0ZFVENIX01BUktFUiA9IFN5bWJvbChcIkN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvblwiKTtcbi8qKlxuICogR2l2ZW4gYSBwb3RlbnRpYWwgZmV0Y2ggZnVuY3Rpb24sIHJldHVybiB0aGUgZmV0Y2ggZnVuY3Rpb24gdG8gdXNlIGJhc2VkIG9uXG4gKiB0aGlzIGFuZCB0aGUgZW52aXJvbm1lbnQuXG4gKi9cbmNvbnN0IGdldEZldGNoID0gKGdpdmVuRmV0Y2gpID0+IHtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSd2ZSBleHBsaWNpdGx5IGJlZW4gZ2l2ZW4gYSBmZXRjaCBmdW5jdGlvbiwgdXNlIHRoYXQuXG4gICAgICovXG4gICAgaWYgKGdpdmVuRmV0Y2gpIHtcbiAgICAgICAgaWYgKENVU1RPTV9GRVRDSF9NQVJLRVIgaW4gZ2l2ZW5GZXRjaCkge1xuICAgICAgICAgICAgcmV0dXJuIGdpdmVuRmV0Y2g7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlIHdyYXAgdGhlIGdpdmVuIGZldGNoIGZ1bmN0aW9uIHRvIHByb3ZpZGUgc29tZSBleHRyYSBjb250cm9sIHdoZW5cbiAgICAgICAgICogaGFuZGxpbmcgZXJyb3JzLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY3VzdG9tRmV0Y2ggPSBhc3luYyAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgZ2l2ZW5GZXRjaCguLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBDYXB0dXJlIHdhcm5pbmdzIHRoYXQgYXJlIG5vdCBzaW1wbGUgZmV0Y2ggZmFpbHVyZXMgYW5kIGhpZ2hsaWdodFxuICAgICAgICAgICAgICAgICAqIHRoZW0gZm9yIHRoZSB1c2VyLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogV2UgYWxzbyB1c2UgdGhpcyBvcHBvcnR1bml0eSB0byBsb2cgdGhlIGNhdXNpbmcgZXJyb3IsIGFzIGNvZGUgaGlnaGVyXG4gICAgICAgICAgICAgICAgICogdXAgdGhlIHN0YWNrIHdpbGwgbGlrZWx5IGFic3RyYWN0IHRoaXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCEoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHx8XG4gICAgICAgICAgICAgICAgICAgICEoKF9hID0gZXJyLm1lc3NhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGFydHNXaXRoKFwiZmV0Y2ggZmFpbGVkXCIpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJBIHJlcXVlc3QgZmFpbGVkIHdoZW4gdXNpbmcgYSBjdXN0b20gZmV0Y2ggaW1wbGVtZW50YXRpb247IHRoaXMgbWF5IGJlIGEgbWlzY29uZmlndXJhdGlvbi4gTWFrZSBzdXJlIHRoYXQgeW91ciBmZXRjaCBjbGllbnQgaXMgY29ycmVjdGx5IGJvdW5kIHRvIHRoZSBnbG9iYWwgc2NvcGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcmsgdGhlIGN1c3RvbSBmZXRjaCBpbXBsZW1lbnRhdGlvbiBzbyB0aGF0IHdlIGNhbiBpZGVudGlmeSBpdCBsYXRlciwgaW5cbiAgICAgICAgICogYWRkaXRpb24gdG8gYWRkaW5nIHNvbWUgcnVudGltZSBwcm9wZXJ0aWVzIHRvIGl0IHRvIG1ha2UgaXQgc2VlbSBhcyBtdWNoXG4gICAgICAgICAqIGxpa2UgdGhlIG9yaWdpbmFsIGZldGNoIGFzIHBvc3NpYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY3VzdG9tRmV0Y2gsIHtcbiAgICAgICAgICAgIFtDVVNUT01fRkVUQ0hfTUFSS0VSXToge30sXG4gICAgICAgICAgICBuYW1lOiB7IHZhbHVlOiBnaXZlbkZldGNoLm5hbWUgfSxcbiAgICAgICAgICAgIGxlbmd0aDogeyB2YWx1ZTogZ2l2ZW5GZXRjaC5sZW5ndGggfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdXN0b21GZXRjaDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnJvd3NlciBvciBOb2RlIDE4K1xuICAgICAqL1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcImZldGNoXCIgaW4gZ2xvYmFsVGhpcykge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoLmJpbmQoZ2xvYmFsVGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBuby1vcFxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGlzdGluZyBwb2x5ZmlsbGVkIGZldGNoXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBmZXRjaCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gZmV0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVudmlyb25tZW50cyB3aGVyZSBmZXRjaCBjYW5ub3QgYmUgZm91bmQgYW5kIG11c3QgYmUgcG9seWZpbGxlZFxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG4gICAgcmV0dXJuIHJlcXVpcmUoXCJjcm9zcy1mZXRjaFwiKTtcbn07XG5leHBvcnRzLmdldEZldGNoID0gZ2V0RmV0Y2g7XG4vKipcbiAqIElmIGBSZXNwb25zZWAgaXNuJ3QgaW5jbHVkZWQgaW4gdGhpcyBlbnZpcm9ubWVudCwgaXQncyBwcm9iYWJseSBhbiBlYXJsaWVyXG4gKiBOb2RlIGVudiB0aGF0IGlzbid0IGFscmVhZHkgcG9seWZpbGxpbmcuIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBlaXRoZXIgdGhlXG4gKiBuYXRpdmUgYFJlc3BvbnNlYCBvciBhIHBvbHlmaWxsZWQgb25lLlxuICovXG5jb25zdCBnZXRSZXNwb25zZSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIFJlc3BvbnNlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBSZXNwb25zZTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsIEB0eXBlc2NyaXB0LWVzbGludC9uby12YXItcmVxdWlyZXNcbiAgICByZXR1cm4gcmVxdWlyZShcImNyb3NzLWZldGNoXCIpLlJlc3BvbnNlO1xufTtcbmV4cG9ydHMuZ2V0UmVzcG9uc2UgPSBnZXRSZXNwb25zZTtcbi8qKlxuICogR2l2ZW4gYW4gdW5rbm93biB2YWx1ZSwgdHJ5IHRvIHBhcnNlIGl0IGFzIGEgYGJvb2xlYW5gLiBVc2VmdWwgZm9yIHBhcnNpbmdcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IGNvdWxkIGJlIGEgc2VsZWN0aW9uIG9mIGRpZmZlcmVudCB2YWx1ZXMgc3VjaCBhc1xuICogYFwidHJ1ZVwiYCwgYFwiMVwiYC5cbiAqXG4gKiBJZiB0aGUgdmFsdWUgY291bGQgbm90IGJlIGNvbmZpZGVudGx5IHBhcnNlZCBhcyBhIGBib29sZWFuYCBvciB3YXMgc2VlbiB0byBiZVxuICogYHVuZGVmaW5lZGAsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqL1xuY29uc3QgcGFyc2VBc0Jvb2xlYW4gPSAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odmFsdWUpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IHRyaW1tZWQgPSB2YWx1ZS50cmltKCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKHRyaW1tZWQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFtcInRydWVcIiwgXCIxXCJdLmluY2x1ZGVzKHRyaW1tZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59O1xuZXhwb3J0cy5wYXJzZUFzQm9vbGVhbiA9IHBhcnNlQXNCb29sZWFuO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW52LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/env.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/errors.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/errors.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.functionStoppedRunningErr = exports.rethrowError = exports.OutgoingResultError = exports.fixEventKeyMissingSteps = exports.prettyError = exports.getErrorMessage = exports.minifyPrettyError = exports.prettyErrorSplitter = exports.ErrCode = exports.deserializeError = exports.isSerializedError = exports.serializeError = void 0;\nconst chalk_1 = __importDefault(__webpack_require__(/*! chalk */ \"(rsc)/./node_modules/chalk/source/index.js\"));\nconst json_stringify_safe_1 = __importDefault(__webpack_require__(/*! json-stringify-safe */ \"(rsc)/./node_modules/json-stringify-safe/stringify.js\"));\nconst serialize_error_cjs_1 = __webpack_require__(/*! serialize-error-cjs */ \"(rsc)/./node_modules/serialize-error-cjs/dist/index.js\");\nconst strip_ansi_1 = __importDefault(__webpack_require__(/*! strip-ansi */ \"(rsc)/./node_modules/inngest/node_modules/strip-ansi/index.js\"));\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst NonRetriableError_js_1 = __webpack_require__(/*! ../components/NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nconst SERIALIZED_KEY = \"__serialized\";\nconst SERIALIZED_VALUE = true;\n/**\n * Add first-class support for certain errors that we control, in addition to\n * built-in errors such as `TypeError`.\n *\n * Adding these allows these non-standard errors to be correctly serialized,\n * sent to Inngest, then deserialized back into the correct error type for users\n * to react to correctly.\n *\n * Note that these errors only support `message?: string | undefined` as the\n * input; more custom errors are not supported with this current strategy.\n */\nserialize_error_cjs_1.errorConstructors.set(\"NonRetriableError\", NonRetriableError_js_1.NonRetriableError);\n/**\n * Serialise an error to a serialized JSON string.\n *\n * Errors do not serialise nicely to JSON, so we use this function to convert\n * them to a serialized JSON string. Doing this is also non-trivial for some\n * errors, so we use the `serialize-error` package to do it for us.\n *\n * See {@link https://www.npmjs.com/package/serialize-error}\n *\n * This function is a small wrapper around that package to also add a `type`\n * property to the serialised error, so that we can distinguish between\n * serialised errors and other objects.\n *\n * Will not reserialise existing serialised errors.\n */\nconst serializeError = (\n/**\n * The suspected error to serialize.\n */\nsubject, \n/**\n * If `true` and the error is not serializable, will return the original value\n * as `unknown` instead of coercing it to a serialized error.\n */\nallowUnknown = false) => {\n    try {\n        // Try to understand if this is already done.\n        // Will handle stringified errors.\n        const existingSerializedError = (0, exports.isSerializedError)(subject);\n        if (existingSerializedError) {\n            return existingSerializedError;\n        }\n        if (typeof subject === \"object\" && subject !== null) {\n            // Is an object, so let's try and serialize it.\n            const serializedErr = (0, serialize_error_cjs_1.serializeError)(subject);\n            // Not a proper error was caught, so give us a chance to return `unknown`.\n            if (!serializedErr.name && allowUnknown) {\n                return subject;\n            }\n            // Serialization can succeed but assign no name or message, so we'll\n            // map over the result here to ensure we have everything.\n            // We'll just stringify the entire subject for the message, as this at\n            // least provides some context for the user.\n            const ret = Object.assign(Object.assign({}, serializedErr), { name: serializedErr.name || \"Error\", message: serializedErr.message ||\n                    (0, json_stringify_safe_1.default)(subject) ||\n                    \"Unknown error; error serialization could not find a message.\", stack: serializedErr.stack || \"\", [SERIALIZED_KEY]: SERIALIZED_VALUE });\n            // If we have a cause, make sure we recursively serialize them too. We are\n            // lighter with causes though; attempt to recursively serialize them, but\n            // stop if we find something that doesn't work and just return `unknown`.\n            let target = ret;\n            const maxDepth = 5;\n            for (let i = 0; i < maxDepth; i++) {\n                if (typeof target === \"object\" &&\n                    target !== null &&\n                    \"cause\" in target &&\n                    target.cause) {\n                    target = target.cause = (0, exports.serializeError)(target.cause, true);\n                    continue;\n                }\n                break;\n            }\n            return ret;\n        }\n        // If it's not an object, it's hard to parse this as an Error. In this case,\n        // we'll throw an error to start attempting backup strategies.\n        throw new Error(\"Error is not an object; strange throw value.\");\n    }\n    catch (err) {\n        if (allowUnknown) {\n            // If we are allowed to return unknown, we'll just return the original\n            // value.\n            return subject;\n        }\n        try {\n            // If serialization fails, fall back to a regular Error and use the\n            // original object as the message for an Error. We don't know what this\n            // object looks like, so we can't do anything else with it.\n            return Object.assign(Object.assign({}, (0, exports.serializeError)(new Error(typeof subject === \"string\" ? subject : (0, json_stringify_safe_1.default)(subject)), false)), { \n                // Remove the stack; it's not relevant here\n                stack: \"\", [SERIALIZED_KEY]: SERIALIZED_VALUE });\n        }\n        catch (err) {\n            // If this failed, then stringifying the object also failed, so we'll just\n            // return a completely generic error.\n            // Failing to stringify the object is very unlikely.\n            return {\n                name: \"Could not serialize source error\",\n                message: \"Serializing the source error failed.\",\n                stack: \"\",\n                [SERIALIZED_KEY]: SERIALIZED_VALUE,\n            };\n        }\n    }\n};\nexports.serializeError = serializeError;\n/**\n * Check if an object or a string is a serialised error created by\n * {@link serializeError}.\n */\nconst isSerializedError = (value) => {\n    try {\n        if (typeof value === \"string\") {\n            const parsed = zod_1.z\n                .object({\n                [SERIALIZED_KEY]: zod_1.z.literal(SERIALIZED_VALUE),\n                name: zod_1.z.enum([...Array.from(serialize_error_cjs_1.errorConstructors.keys())]),\n                message: zod_1.z.string(),\n                stack: zod_1.z.string(),\n            })\n                .passthrough()\n                .safeParse(JSON.parse(value));\n            if (parsed.success) {\n                return parsed.data;\n            }\n        }\n        if (typeof value === \"object\" && value !== null) {\n            const objIsSerializedErr = Object.prototype.hasOwnProperty.call(value, SERIALIZED_KEY) &&\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n                value[SERIALIZED_KEY] ===\n                    SERIALIZED_VALUE;\n            if (objIsSerializedErr) {\n                return value;\n            }\n        }\n    }\n    catch (_a) {\n        // no-op; we'll return undefined if parsing failed, as it isn't a serialized\n        // error\n    }\n};\nexports.isSerializedError = isSerializedError;\n/**\n * Deserialise an error created by {@link serializeError}.\n *\n * Ensures we only deserialise errors that meet a minimum level of\n * applicability, inclusive of error handling to ensure that badly serialized\n * errors are still handled.\n */\nconst deserializeError = (subject, allowUnknown = false) => {\n    const requiredFields = [\"name\", \"message\"];\n    try {\n        const hasRequiredFields = requiredFields.every((field) => {\n            return Object.prototype.hasOwnProperty.call(subject, field);\n        });\n        if (!hasRequiredFields) {\n            throw new Error();\n        }\n        const deserializedErr = (0, serialize_error_cjs_1.deserializeError)(subject);\n        if (\"cause\" in deserializedErr) {\n            deserializedErr.cause = (0, exports.deserializeError)(deserializedErr.cause, true);\n        }\n        return deserializedErr;\n    }\n    catch (_a) {\n        if (allowUnknown) {\n            // If we are allowed to return unknown, we'll just return the original\n            // value.\n            return subject;\n        }\n        const err = new Error(\"Unknown error; could not reserialize\");\n        /**\n         * Remove the stack so that it's not misleadingly shown as the Inngest\n         * internals.\n         */\n        err.stack = undefined;\n        return err;\n    }\n};\nexports.deserializeError = deserializeError;\nvar ErrCode;\n(function (ErrCode) {\n    ErrCode[\"NESTING_STEPS\"] = \"NESTING_STEPS\";\n    /**\n     * Legacy v0 execution error code for when a function has changed and no\n     * longer matches its in-progress state.\n     *\n     * @deprecated Not for use in latest execution method.\n     */\n    ErrCode[\"NON_DETERMINISTIC_FUNCTION\"] = \"NON_DETERMINISTIC_FUNCTION\";\n    /**\n     * Legacy v0 execution error code for when a function is found to be using\n     * async actions after memoziation has occurred, which v0 doesn't support.\n     *\n     * @deprecated Not for use in latest execution method.\n     */\n    ErrCode[\"ASYNC_DETECTED_AFTER_MEMOIZATION\"] = \"ASYNC_DETECTED_AFTER_MEMOIZATION\";\n    /**\n     * Legacy v0 execution error code for when a function is found to be using\n     * steps after a non-step async action has occurred.\n     *\n     * @deprecated Not for use in latest execution method.\n     */\n    ErrCode[\"STEP_USED_AFTER_ASYNC\"] = \"STEP_USED_AFTER_ASYNC\";\n    ErrCode[\"AUTOMATIC_PARALLEL_INDEXING\"] = \"AUTOMATIC_PARALLEL_INDEXING\";\n})(ErrCode || (exports.ErrCode = ErrCode = {}));\nexports.prettyErrorSplitter = \"=================================================\";\n/**\n * Given an unknown `err`, mutate it to minify any pretty errors that it\n * contains.\n */\nconst minifyPrettyError = (err) => {\n    var _a, _b, _c, _d;\n    try {\n        if (!isError(err)) {\n            return err;\n        }\n        const isPrettyError = err.message.includes(exports.prettyErrorSplitter);\n        if (!isPrettyError) {\n            return err;\n        }\n        const sanitizedMessage = (0, strip_ansi_1.default)(err.message);\n        const message = ((_b = (_a = sanitizedMessage.split(\"  \")[1]) === null || _a === void 0 ? void 0 : _a.split(\"\\n\")[0]) === null || _b === void 0 ? void 0 : _b.trim()) || err.message;\n        const code = ((_d = (_c = sanitizedMessage.split(\"\\n\\nCode: \")[1]) === null || _c === void 0 ? void 0 : _c.split(\"\\n\\n\")[0]) === null || _d === void 0 ? void 0 : _d.trim()) ||\n            undefined;\n        err.message = [code, message].filter(Boolean).join(\" - \");\n        if (err.stack) {\n            const sanitizedStack = (0, strip_ansi_1.default)(err.stack);\n            const stackRest = sanitizedStack\n                .split(`${exports.prettyErrorSplitter}\\n`)\n                .slice(2)\n                .join(\"\\n\");\n            err.stack = `${err.name}: ${err.message}\\n${stackRest}`;\n        }\n        return err;\n    }\n    catch (noopErr) {\n        return err;\n    }\n};\nexports.minifyPrettyError = minifyPrettyError;\n/**\n * Given an `err`, return a boolean representing whether it is in the shape of\n * an `Error` or not.\n */\nconst isError = (err) => {\n    try {\n        if (err instanceof Error) {\n            return true;\n        }\n        const hasName = Object.prototype.hasOwnProperty.call(err, \"name\");\n        const hasMessage = Object.prototype.hasOwnProperty.call(err, \"message\");\n        return hasName && hasMessage;\n    }\n    catch (noopErr) {\n        return false;\n    }\n};\n/**\n * Given an `unknown` object, retrieve the `message` property from it, or fall\n * back to the `fallback` string if it doesn't exist or is empty.\n */\nconst getErrorMessage = (err, fallback) => {\n    const { message } = zod_1.z\n        .object({ message: zod_1.z.string().min(1) })\n        .catch({ message: fallback })\n        .parse(err);\n    return message;\n};\nexports.getErrorMessage = getErrorMessage;\n/**\n * Given a {@link PrettyError}, return a nicely-formatted string ready to log\n * or throw.\n *\n * Useful for ensuring that errors are logged in a consistent, helpful format\n * across the SDK by prompting for key pieces of information.\n */\nconst prettyError = ({ type = \"error\", whatHappened, otherwise, reassurance, toFixNow, why, consequences, stack, code, }) => {\n    var _a, _b;\n    const { icon, colorFn } = {\n        error: { icon: \"\", colorFn: chalk_1.default.red },\n        warn: { icon: \"\", colorFn: chalk_1.default.yellow },\n    }[type];\n    let header = `${icon}  ${chalk_1.default.bold.underline(whatHappened.trim())}`;\n    if (stack) {\n        header +=\n            \"\\n\" +\n                [...(((_a = new Error().stack) === null || _a === void 0 ? void 0 : _a.split(\"\\n\").slice(1).filter(Boolean)) || [])].join(\"\\n\");\n    }\n    let toFixNowStr = (_b = (Array.isArray(toFixNow)\n        ? toFixNow\n            .map((s) => s.trim())\n            .filter(Boolean)\n            .map((s, i) => `\\t${i + 1}. ${s}`)\n            .join(\"\\n\")\n        : toFixNow === null || toFixNow === void 0 ? void 0 : toFixNow.trim())) !== null && _b !== void 0 ? _b : \"\";\n    if (Array.isArray(toFixNow) && toFixNowStr) {\n        toFixNowStr = `To fix this, you can take one of the following courses of action:\\n\\n${toFixNowStr}`;\n    }\n    let body = [reassurance === null || reassurance === void 0 ? void 0 : reassurance.trim(), why === null || why === void 0 ? void 0 : why.trim(), consequences === null || consequences === void 0 ? void 0 : consequences.trim()]\n        .filter(Boolean)\n        .join(\" \");\n    body += body ? `\\n\\n${toFixNowStr}` : toFixNowStr;\n    const trailer = [otherwise === null || otherwise === void 0 ? void 0 : otherwise.trim()].filter(Boolean).join(\" \");\n    const message = [\n        exports.prettyErrorSplitter,\n        header,\n        body,\n        trailer,\n        code ? `Code: ${code}` : \"\",\n        exports.prettyErrorSplitter,\n    ]\n        .filter(Boolean)\n        .join(\"\\n\\n\");\n    return colorFn(message);\n};\nexports.prettyError = prettyError;\nexports.fixEventKeyMissingSteps = [\n    \"Set the `INNGEST_EVENT_KEY` environment variable\",\n    `Pass a key to the \\`new Inngest()\\` constructor using the \\`${\"eventKey\"}\\` option`,\n    `Use \\`inngest.${\"setEventKey\"}()\\` at runtime`,\n];\n/**\n * An error that, when thrown, indicates internally that an outgoing operation\n * contains an error.\n *\n * We use this because serialized `data` sent back to Inngest may differ from\n * the error instance itself due to middleware.\n *\n * @internal\n */\nclass OutgoingResultError extends Error {\n    constructor(result) {\n        super(\"OutgoingOpError\");\n        this.result = result;\n    }\n}\nexports.OutgoingResultError = OutgoingResultError;\n/**\n * Create a function that will rethrow an error with a prefix added to the\n * message.\n *\n * Useful for adding context to errors that are rethrown.\n *\n * @example\n * ```ts\n * await doSomeAction().catch(rethrowError(\"Failed to do some action\"));\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst rethrowError = (prefix) => {\n    return (err) => {\n        try {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/restrict-template-expressions\n            err.message && (err.message = `${prefix}; ${err.message}`);\n        }\n        catch (noopErr) {\n            // no-op\n        }\n        finally {\n            // eslint-disable-next-line no-unsafe-finally\n            throw err;\n        }\n    };\n};\nexports.rethrowError = rethrowError;\n/**\n * Legacy v0 execution error for functions that don't support mixing steps and\n * regular async actions.\n */\nconst functionStoppedRunningErr = (code) => {\n    return (0, exports.prettyError)({\n        whatHappened: \"Your function was stopped from running\",\n        why: \"We detected a mix of asynchronous logic, some using step tooling and some not.\",\n        consequences: \"This can cause unexpected behaviour when a function is paused and resumed and is therefore strongly discouraged; we stopped your function to ensure nothing unexpected happened!\",\n        stack: true,\n        toFixNow: \"Ensure that your function is either entirely step-based or entirely non-step-based, by either wrapping all asynchronous logic in `step.run()` calls or by removing all `step.*()` calls.\",\n        otherwise: \"For more information on why step functions work in this manner, see https://www.inngest.com/docs/functions/multi-step#gotchas\",\n        code,\n    });\n};\nexports.functionStoppedRunningErr = functionStoppedRunningErr;\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQyxHQUFHLG9CQUFvQixHQUFHLDJCQUEyQixHQUFHLCtCQUErQixHQUFHLG1CQUFtQixHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLDJCQUEyQixHQUFHLGVBQWUsR0FBRyx3QkFBd0IsR0FBRyx5QkFBeUIsR0FBRyxzQkFBc0I7QUFDcFUsZ0NBQWdDLG1CQUFPLENBQUMseURBQU87QUFDL0MsOENBQThDLG1CQUFPLENBQUMsa0ZBQXFCO0FBQzNFLDhCQUE4QixtQkFBTyxDQUFDLG1GQUFxQjtBQUMzRCxxQ0FBcUMsbUJBQU8sQ0FBQyxpRkFBWTtBQUN6RCxjQUFjLG1CQUFPLENBQUMsa0RBQUs7QUFDM0IsK0JBQStCLG1CQUFPLENBQUMsd0dBQW9DO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsb0JBQW9CO0FBQzFFO0FBQ0Esb0NBQW9DLHNIQUFzSDtBQUMxSjtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHFDQUFxQztBQUNyQywrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsSUFBSSxxQkFBcUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxvQ0FBb0MscUJBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxjQUFjLGVBQWUsZUFBZTtBQUM3QywyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsNEJBQTRCO0FBQ3REO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUyxJQUFJLFlBQVksSUFBSSxVQUFVO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLGtCQUFrQixrQ0FBa0M7QUFDcEQsaUJBQWlCLG1CQUFtQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlHQUFpRztBQUN4SDtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCLGlCQUFpQix5Q0FBeUM7QUFDMUQsZ0JBQWdCLDZDQUE2QztBQUM3RCxLQUFLO0FBQ0wsb0JBQW9CLE9BQU8sRUFBRSxvREFBb0Q7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU0sSUFBSSxFQUFFO0FBQzVDO0FBQ0E7QUFDQTtBQUNBLDhGQUE4RixZQUFZO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFlBQVk7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLEtBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLCtCQUErQjtBQUMvQjtBQUNBLG1FQUFtRSxXQUFXO0FBQzlFLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFNBQVMsRUFBRSxZQUFZO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3SUFBd0k7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxpQ0FBaUM7QUFDakMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Vycm9ycy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnVuY3Rpb25TdG9wcGVkUnVubmluZ0VyciA9IGV4cG9ydHMucmV0aHJvd0Vycm9yID0gZXhwb3J0cy5PdXRnb2luZ1Jlc3VsdEVycm9yID0gZXhwb3J0cy5maXhFdmVudEtleU1pc3NpbmdTdGVwcyA9IGV4cG9ydHMucHJldHR5RXJyb3IgPSBleHBvcnRzLmdldEVycm9yTWVzc2FnZSA9IGV4cG9ydHMubWluaWZ5UHJldHR5RXJyb3IgPSBleHBvcnRzLnByZXR0eUVycm9yU3BsaXR0ZXIgPSBleHBvcnRzLkVyckNvZGUgPSBleHBvcnRzLmRlc2VyaWFsaXplRXJyb3IgPSBleHBvcnRzLmlzU2VyaWFsaXplZEVycm9yID0gZXhwb3J0cy5zZXJpYWxpemVFcnJvciA9IHZvaWQgMDtcbmNvbnN0IGNoYWxrXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNoYWxrXCIpKTtcbmNvbnN0IGpzb25fc3RyaW5naWZ5X3NhZmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwianNvbi1zdHJpbmdpZnktc2FmZVwiKSk7XG5jb25zdCBzZXJpYWxpemVfZXJyb3JfY2pzXzEgPSByZXF1aXJlKFwic2VyaWFsaXplLWVycm9yLWNqc1wiKTtcbmNvbnN0IHN0cmlwX2Fuc2lfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwic3RyaXAtYW5zaVwiKSk7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBOb25SZXRyaWFibGVFcnJvcl9qc18xID0gcmVxdWlyZShcIi4uL2NvbXBvbmVudHMvTm9uUmV0cmlhYmxlRXJyb3IuanNcIik7XG5jb25zdCBTRVJJQUxJWkVEX0tFWSA9IFwiX19zZXJpYWxpemVkXCI7XG5jb25zdCBTRVJJQUxJWkVEX1ZBTFVFID0gdHJ1ZTtcbi8qKlxuICogQWRkIGZpcnN0LWNsYXNzIHN1cHBvcnQgZm9yIGNlcnRhaW4gZXJyb3JzIHRoYXQgd2UgY29udHJvbCwgaW4gYWRkaXRpb24gdG9cbiAqIGJ1aWx0LWluIGVycm9ycyBzdWNoIGFzIGBUeXBlRXJyb3JgLlxuICpcbiAqIEFkZGluZyB0aGVzZSBhbGxvd3MgdGhlc2Ugbm9uLXN0YW5kYXJkIGVycm9ycyB0byBiZSBjb3JyZWN0bHkgc2VyaWFsaXplZCxcbiAqIHNlbnQgdG8gSW5uZ2VzdCwgdGhlbiBkZXNlcmlhbGl6ZWQgYmFjayBpbnRvIHRoZSBjb3JyZWN0IGVycm9yIHR5cGUgZm9yIHVzZXJzXG4gKiB0byByZWFjdCB0byBjb3JyZWN0bHkuXG4gKlxuICogTm90ZSB0aGF0IHRoZXNlIGVycm9ycyBvbmx5IHN1cHBvcnQgYG1lc3NhZ2U/OiBzdHJpbmcgfCB1bmRlZmluZWRgIGFzIHRoZVxuICogaW5wdXQ7IG1vcmUgY3VzdG9tIGVycm9ycyBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIHRoaXMgY3VycmVudCBzdHJhdGVneS5cbiAqL1xuc2VyaWFsaXplX2Vycm9yX2Nqc18xLmVycm9yQ29uc3RydWN0b3JzLnNldChcIk5vblJldHJpYWJsZUVycm9yXCIsIE5vblJldHJpYWJsZUVycm9yX2pzXzEuTm9uUmV0cmlhYmxlRXJyb3IpO1xuLyoqXG4gKiBTZXJpYWxpc2UgYW4gZXJyb3IgdG8gYSBzZXJpYWxpemVkIEpTT04gc3RyaW5nLlxuICpcbiAqIEVycm9ycyBkbyBub3Qgc2VyaWFsaXNlIG5pY2VseSB0byBKU09OLCBzbyB3ZSB1c2UgdGhpcyBmdW5jdGlvbiB0byBjb252ZXJ0XG4gKiB0aGVtIHRvIGEgc2VyaWFsaXplZCBKU09OIHN0cmluZy4gRG9pbmcgdGhpcyBpcyBhbHNvIG5vbi10cml2aWFsIGZvciBzb21lXG4gKiBlcnJvcnMsIHNvIHdlIHVzZSB0aGUgYHNlcmlhbGl6ZS1lcnJvcmAgcGFja2FnZSB0byBkbyBpdCBmb3IgdXMuXG4gKlxuICogU2VlIHtAbGluayBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9zZXJpYWxpemUtZXJyb3J9XG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBhIHNtYWxsIHdyYXBwZXIgYXJvdW5kIHRoYXQgcGFja2FnZSB0byBhbHNvIGFkZCBhIGB0eXBlYFxuICogcHJvcGVydHkgdG8gdGhlIHNlcmlhbGlzZWQgZXJyb3IsIHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIGJldHdlZW5cbiAqIHNlcmlhbGlzZWQgZXJyb3JzIGFuZCBvdGhlciBvYmplY3RzLlxuICpcbiAqIFdpbGwgbm90IHJlc2VyaWFsaXNlIGV4aXN0aW5nIHNlcmlhbGlzZWQgZXJyb3JzLlxuICovXG5jb25zdCBzZXJpYWxpemVFcnJvciA9IChcbi8qKlxuICogVGhlIHN1c3BlY3RlZCBlcnJvciB0byBzZXJpYWxpemUuXG4gKi9cbnN1YmplY3QsIFxuLyoqXG4gKiBJZiBgdHJ1ZWAgYW5kIHRoZSBlcnJvciBpcyBub3Qgc2VyaWFsaXphYmxlLCB3aWxsIHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWVcbiAqIGFzIGB1bmtub3duYCBpbnN0ZWFkIG9mIGNvZXJjaW5nIGl0IHRvIGEgc2VyaWFsaXplZCBlcnJvci5cbiAqL1xuYWxsb3dVbmtub3duID0gZmFsc2UpID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUcnkgdG8gdW5kZXJzdGFuZCBpZiB0aGlzIGlzIGFscmVhZHkgZG9uZS5cbiAgICAgICAgLy8gV2lsbCBoYW5kbGUgc3RyaW5naWZpZWQgZXJyb3JzLlxuICAgICAgICBjb25zdCBleGlzdGluZ1NlcmlhbGl6ZWRFcnJvciA9ICgwLCBleHBvcnRzLmlzU2VyaWFsaXplZEVycm9yKShzdWJqZWN0KTtcbiAgICAgICAgaWYgKGV4aXN0aW5nU2VyaWFsaXplZEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdTZXJpYWxpemVkRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJqZWN0ID09PSBcIm9iamVjdFwiICYmIHN1YmplY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElzIGFuIG9iamVjdCwgc28gbGV0J3MgdHJ5IGFuZCBzZXJpYWxpemUgaXQuXG4gICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkRXJyID0gKDAsIHNlcmlhbGl6ZV9lcnJvcl9janNfMS5zZXJpYWxpemVFcnJvcikoc3ViamVjdCk7XG4gICAgICAgICAgICAvLyBOb3QgYSBwcm9wZXIgZXJyb3Igd2FzIGNhdWdodCwgc28gZ2l2ZSB1cyBhIGNoYW5jZSB0byByZXR1cm4gYHVua25vd25gLlxuICAgICAgICAgICAgaWYgKCFzZXJpYWxpemVkRXJyLm5hbWUgJiYgYWxsb3dVbmtub3duKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXJpYWxpemF0aW9uIGNhbiBzdWNjZWVkIGJ1dCBhc3NpZ24gbm8gbmFtZSBvciBtZXNzYWdlLCBzbyB3ZSdsbFxuICAgICAgICAgICAgLy8gbWFwIG92ZXIgdGhlIHJlc3VsdCBoZXJlIHRvIGVuc3VyZSB3ZSBoYXZlIGV2ZXJ5dGhpbmcuXG4gICAgICAgICAgICAvLyBXZSdsbCBqdXN0IHN0cmluZ2lmeSB0aGUgZW50aXJlIHN1YmplY3QgZm9yIHRoZSBtZXNzYWdlLCBhcyB0aGlzIGF0XG4gICAgICAgICAgICAvLyBsZWFzdCBwcm92aWRlcyBzb21lIGNvbnRleHQgZm9yIHRoZSB1c2VyLlxuICAgICAgICAgICAgY29uc3QgcmV0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzZXJpYWxpemVkRXJyKSwgeyBuYW1lOiBzZXJpYWxpemVkRXJyLm5hbWUgfHwgXCJFcnJvclwiLCBtZXNzYWdlOiBzZXJpYWxpemVkRXJyLm1lc3NhZ2UgfHxcbiAgICAgICAgICAgICAgICAgICAgKDAsIGpzb25fc3RyaW5naWZ5X3NhZmVfMS5kZWZhdWx0KShzdWJqZWN0KSB8fFxuICAgICAgICAgICAgICAgICAgICBcIlVua25vd24gZXJyb3I7IGVycm9yIHNlcmlhbGl6YXRpb24gY291bGQgbm90IGZpbmQgYSBtZXNzYWdlLlwiLCBzdGFjazogc2VyaWFsaXplZEVyci5zdGFjayB8fCBcIlwiLCBbU0VSSUFMSVpFRF9LRVldOiBTRVJJQUxJWkVEX1ZBTFVFIH0pO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIGNhdXNlLCBtYWtlIHN1cmUgd2UgcmVjdXJzaXZlbHkgc2VyaWFsaXplIHRoZW0gdG9vLiBXZSBhcmVcbiAgICAgICAgICAgIC8vIGxpZ2h0ZXIgd2l0aCBjYXVzZXMgdGhvdWdoOyBhdHRlbXB0IHRvIHJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSB0aGVtLCBidXRcbiAgICAgICAgICAgIC8vIHN0b3AgaWYgd2UgZmluZCBzb21ldGhpbmcgdGhhdCBkb2Vzbid0IHdvcmsgYW5kIGp1c3QgcmV0dXJuIGB1bmtub3duYC5cbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSByZXQ7XG4gICAgICAgICAgICBjb25zdCBtYXhEZXB0aCA9IDU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1heERlcHRoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQgIT09IG51bGwgJiZcbiAgICAgICAgICAgICAgICAgICAgXCJjYXVzZVwiIGluIHRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQuY2F1c2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0LmNhdXNlID0gKDAsIGV4cG9ydHMuc2VyaWFsaXplRXJyb3IpKHRhcmdldC5jYXVzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgaXQncyBub3QgYW4gb2JqZWN0LCBpdCdzIGhhcmQgdG8gcGFyc2UgdGhpcyBhcyBhbiBFcnJvci4gSW4gdGhpcyBjYXNlLFxuICAgICAgICAvLyB3ZSdsbCB0aHJvdyBhbiBlcnJvciB0byBzdGFydCBhdHRlbXB0aW5nIGJhY2t1cCBzdHJhdGVnaWVzLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpcyBub3QgYW4gb2JqZWN0OyBzdHJhbmdlIHRocm93IHZhbHVlLlwiKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoYWxsb3dVbmtub3duKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBhcmUgYWxsb3dlZCB0byByZXR1cm4gdW5rbm93biwgd2UnbGwganVzdCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgICAgICAgICAvLyB2YWx1ZS5cbiAgICAgICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJZiBzZXJpYWxpemF0aW9uIGZhaWxzLCBmYWxsIGJhY2sgdG8gYSByZWd1bGFyIEVycm9yIGFuZCB1c2UgdGhlXG4gICAgICAgICAgICAvLyBvcmlnaW5hbCBvYmplY3QgYXMgdGhlIG1lc3NhZ2UgZm9yIGFuIEVycm9yLiBXZSBkb24ndCBrbm93IHdoYXQgdGhpc1xuICAgICAgICAgICAgLy8gb2JqZWN0IGxvb2tzIGxpa2UsIHNvIHdlIGNhbid0IGRvIGFueXRoaW5nIGVsc2Ugd2l0aCBpdC5cbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sICgwLCBleHBvcnRzLnNlcmlhbGl6ZUVycm9yKShuZXcgRXJyb3IodHlwZW9mIHN1YmplY3QgPT09IFwic3RyaW5nXCIgPyBzdWJqZWN0IDogKDAsIGpzb25fc3RyaW5naWZ5X3NhZmVfMS5kZWZhdWx0KShzdWJqZWN0KSksIGZhbHNlKSksIHsgXG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBzdGFjazsgaXQncyBub3QgcmVsZXZhbnQgaGVyZVxuICAgICAgICAgICAgICAgIHN0YWNrOiBcIlwiLCBbU0VSSUFMSVpFRF9LRVldOiBTRVJJQUxJWkVEX1ZBTFVFIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgZmFpbGVkLCB0aGVuIHN0cmluZ2lmeWluZyB0aGUgb2JqZWN0IGFsc28gZmFpbGVkLCBzbyB3ZSdsbCBqdXN0XG4gICAgICAgICAgICAvLyByZXR1cm4gYSBjb21wbGV0ZWx5IGdlbmVyaWMgZXJyb3IuXG4gICAgICAgICAgICAvLyBGYWlsaW5nIHRvIHN0cmluZ2lmeSB0aGUgb2JqZWN0IGlzIHZlcnkgdW5saWtlbHkuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiQ291bGQgbm90IHNlcmlhbGl6ZSBzb3VyY2UgZXJyb3JcIixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIlNlcmlhbGl6aW5nIHRoZSBzb3VyY2UgZXJyb3IgZmFpbGVkLlwiLFxuICAgICAgICAgICAgICAgIHN0YWNrOiBcIlwiLFxuICAgICAgICAgICAgICAgIFtTRVJJQUxJWkVEX0tFWV06IFNFUklBTElaRURfVkFMVUUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydHMuc2VyaWFsaXplRXJyb3IgPSBzZXJpYWxpemVFcnJvcjtcbi8qKlxuICogQ2hlY2sgaWYgYW4gb2JqZWN0IG9yIGEgc3RyaW5nIGlzIGEgc2VyaWFsaXNlZCBlcnJvciBjcmVhdGVkIGJ5XG4gKiB7QGxpbmsgc2VyaWFsaXplRXJyb3J9LlxuICovXG5jb25zdCBpc1NlcmlhbGl6ZWRFcnJvciA9ICh2YWx1ZSkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBbU0VSSUFMSVpFRF9LRVldOiB6b2RfMS56LmxpdGVyYWwoU0VSSUFMSVpFRF9WQUxVRSksXG4gICAgICAgICAgICAgICAgbmFtZTogem9kXzEuei5lbnVtKFsuLi5BcnJheS5mcm9tKHNlcmlhbGl6ZV9lcnJvcl9janNfMS5lcnJvckNvbnN0cnVjdG9ycy5rZXlzKCkpXSksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICBzdGFjazogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnBhc3N0aHJvdWdoKClcbiAgICAgICAgICAgICAgICAuc2FmZVBhcnNlKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgICAgIGlmIChwYXJzZWQuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWQuZGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBvYmpJc1NlcmlhbGl6ZWRFcnIgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIFNFUklBTElaRURfS0VZKSAmJlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgICAgICAgICB2YWx1ZVtTRVJJQUxJWkVEX0tFWV0gPT09XG4gICAgICAgICAgICAgICAgICAgIFNFUklBTElaRURfVkFMVUU7XG4gICAgICAgICAgICBpZiAob2JqSXNTZXJpYWxpemVkRXJyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICAvLyBuby1vcDsgd2UnbGwgcmV0dXJuIHVuZGVmaW5lZCBpZiBwYXJzaW5nIGZhaWxlZCwgYXMgaXQgaXNuJ3QgYSBzZXJpYWxpemVkXG4gICAgICAgIC8vIGVycm9yXG4gICAgfVxufTtcbmV4cG9ydHMuaXNTZXJpYWxpemVkRXJyb3IgPSBpc1NlcmlhbGl6ZWRFcnJvcjtcbi8qKlxuICogRGVzZXJpYWxpc2UgYW4gZXJyb3IgY3JlYXRlZCBieSB7QGxpbmsgc2VyaWFsaXplRXJyb3J9LlxuICpcbiAqIEVuc3VyZXMgd2Ugb25seSBkZXNlcmlhbGlzZSBlcnJvcnMgdGhhdCBtZWV0IGEgbWluaW11bSBsZXZlbCBvZlxuICogYXBwbGljYWJpbGl0eSwgaW5jbHVzaXZlIG9mIGVycm9yIGhhbmRsaW5nIHRvIGVuc3VyZSB0aGF0IGJhZGx5IHNlcmlhbGl6ZWRcbiAqIGVycm9ycyBhcmUgc3RpbGwgaGFuZGxlZC5cbiAqL1xuY29uc3QgZGVzZXJpYWxpemVFcnJvciA9IChzdWJqZWN0LCBhbGxvd1Vua25vd24gPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHJlcXVpcmVkRmllbGRzID0gW1wibmFtZVwiLCBcIm1lc3NhZ2VcIl07XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGFzUmVxdWlyZWRGaWVsZHMgPSByZXF1aXJlZEZpZWxkcy5ldmVyeSgoZmllbGQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3ViamVjdCwgZmllbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFoYXNSZXF1aXJlZEZpZWxkcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzZXJpYWxpemVkRXJyID0gKDAsIHNlcmlhbGl6ZV9lcnJvcl9janNfMS5kZXNlcmlhbGl6ZUVycm9yKShzdWJqZWN0KTtcbiAgICAgICAgaWYgKFwiY2F1c2VcIiBpbiBkZXNlcmlhbGl6ZWRFcnIpIHtcbiAgICAgICAgICAgIGRlc2VyaWFsaXplZEVyci5jYXVzZSA9ICgwLCBleHBvcnRzLmRlc2VyaWFsaXplRXJyb3IpKGRlc2VyaWFsaXplZEVyci5jYXVzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplZEVycjtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIGlmIChhbGxvd1Vua25vd24pIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGFyZSBhbGxvd2VkIHRvIHJldHVybiB1bmtub3duLCB3ZSdsbCBqdXN0IHJldHVybiB0aGUgb3JpZ2luYWxcbiAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgcmV0dXJuIHN1YmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFwiVW5rbm93biBlcnJvcjsgY291bGQgbm90IHJlc2VyaWFsaXplXCIpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlIHRoZSBzdGFjayBzbyB0aGF0IGl0J3Mgbm90IG1pc2xlYWRpbmdseSBzaG93biBhcyB0aGUgSW5uZ2VzdFxuICAgICAgICAgKiBpbnRlcm5hbHMuXG4gICAgICAgICAqL1xuICAgICAgICBlcnIuc3RhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVzZXJpYWxpemVFcnJvciA9IGRlc2VyaWFsaXplRXJyb3I7XG52YXIgRXJyQ29kZTtcbihmdW5jdGlvbiAoRXJyQ29kZSkge1xuICAgIEVyckNvZGVbXCJORVNUSU5HX1NURVBTXCJdID0gXCJORVNUSU5HX1NURVBTXCI7XG4gICAgLyoqXG4gICAgICogTGVnYWN5IHYwIGV4ZWN1dGlvbiBlcnJvciBjb2RlIGZvciB3aGVuIGEgZnVuY3Rpb24gaGFzIGNoYW5nZWQgYW5kIG5vXG4gICAgICogbG9uZ2VyIG1hdGNoZXMgaXRzIGluLXByb2dyZXNzIHN0YXRlLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgTm90IGZvciB1c2UgaW4gbGF0ZXN0IGV4ZWN1dGlvbiBtZXRob2QuXG4gICAgICovXG4gICAgRXJyQ29kZVtcIk5PTl9ERVRFUk1JTklTVElDX0ZVTkNUSU9OXCJdID0gXCJOT05fREVURVJNSU5JU1RJQ19GVU5DVElPTlwiO1xuICAgIC8qKlxuICAgICAqIExlZ2FjeSB2MCBleGVjdXRpb24gZXJyb3IgY29kZSBmb3Igd2hlbiBhIGZ1bmN0aW9uIGlzIGZvdW5kIHRvIGJlIHVzaW5nXG4gICAgICogYXN5bmMgYWN0aW9ucyBhZnRlciBtZW1vemlhdGlvbiBoYXMgb2NjdXJyZWQsIHdoaWNoIHYwIGRvZXNuJ3Qgc3VwcG9ydC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIE5vdCBmb3IgdXNlIGluIGxhdGVzdCBleGVjdXRpb24gbWV0aG9kLlxuICAgICAqL1xuICAgIEVyckNvZGVbXCJBU1lOQ19ERVRFQ1RFRF9BRlRFUl9NRU1PSVpBVElPTlwiXSA9IFwiQVNZTkNfREVURUNURURfQUZURVJfTUVNT0laQVRJT05cIjtcbiAgICAvKipcbiAgICAgKiBMZWdhY3kgdjAgZXhlY3V0aW9uIGVycm9yIGNvZGUgZm9yIHdoZW4gYSBmdW5jdGlvbiBpcyBmb3VuZCB0byBiZSB1c2luZ1xuICAgICAqIHN0ZXBzIGFmdGVyIGEgbm9uLXN0ZXAgYXN5bmMgYWN0aW9uIGhhcyBvY2N1cnJlZC5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIE5vdCBmb3IgdXNlIGluIGxhdGVzdCBleGVjdXRpb24gbWV0aG9kLlxuICAgICAqL1xuICAgIEVyckNvZGVbXCJTVEVQX1VTRURfQUZURVJfQVNZTkNcIl0gPSBcIlNURVBfVVNFRF9BRlRFUl9BU1lOQ1wiO1xuICAgIEVyckNvZGVbXCJBVVRPTUFUSUNfUEFSQUxMRUxfSU5ERVhJTkdcIl0gPSBcIkFVVE9NQVRJQ19QQVJBTExFTF9JTkRFWElOR1wiO1xufSkoRXJyQ29kZSB8fCAoZXhwb3J0cy5FcnJDb2RlID0gRXJyQ29kZSA9IHt9KSk7XG5leHBvcnRzLnByZXR0eUVycm9yU3BsaXR0ZXIgPSBcIj09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cIjtcbi8qKlxuICogR2l2ZW4gYW4gdW5rbm93biBgZXJyYCwgbXV0YXRlIGl0IHRvIG1pbmlmeSBhbnkgcHJldHR5IGVycm9ycyB0aGF0IGl0XG4gKiBjb250YWlucy5cbiAqL1xuY29uc3QgbWluaWZ5UHJldHR5RXJyb3IgPSAoZXJyKSA9PiB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghaXNFcnJvcihlcnIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzUHJldHR5RXJyb3IgPSBlcnIubWVzc2FnZS5pbmNsdWRlcyhleHBvcnRzLnByZXR0eUVycm9yU3BsaXR0ZXIpO1xuICAgICAgICBpZiAoIWlzUHJldHR5RXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2FuaXRpemVkTWVzc2FnZSA9ICgwLCBzdHJpcF9hbnNpXzEuZGVmYXVsdCkoZXJyLm1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gKChfYiA9IChfYSA9IHNhbml0aXplZE1lc3NhZ2Uuc3BsaXQoXCIgIFwiKVsxXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNwbGl0KFwiXFxuXCIpWzBdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudHJpbSgpKSB8fCBlcnIubWVzc2FnZTtcbiAgICAgICAgY29uc3QgY29kZSA9ICgoX2QgPSAoX2MgPSBzYW5pdGl6ZWRNZXNzYWdlLnNwbGl0KFwiXFxuXFxuQ29kZTogXCIpWzFdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3BsaXQoXCJcXG5cXG5cIilbMF0pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC50cmltKCkpIHx8XG4gICAgICAgICAgICB1bmRlZmluZWQ7XG4gICAgICAgIGVyci5tZXNzYWdlID0gW2NvZGUsIG1lc3NhZ2VdLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIC0gXCIpO1xuICAgICAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRTdGFjayA9ICgwLCBzdHJpcF9hbnNpXzEuZGVmYXVsdCkoZXJyLnN0YWNrKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrUmVzdCA9IHNhbml0aXplZFN0YWNrXG4gICAgICAgICAgICAgICAgLnNwbGl0KGAke2V4cG9ydHMucHJldHR5RXJyb3JTcGxpdHRlcn1cXG5gKVxuICAgICAgICAgICAgICAgIC5zbGljZSgyKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpO1xuICAgICAgICAgICAgZXJyLnN0YWNrID0gYCR7ZXJyLm5hbWV9OiAke2Vyci5tZXNzYWdlfVxcbiR7c3RhY2tSZXN0fWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gICAgY2F0Y2ggKG5vb3BFcnIpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG59O1xuZXhwb3J0cy5taW5pZnlQcmV0dHlFcnJvciA9IG1pbmlmeVByZXR0eUVycm9yO1xuLyoqXG4gKiBHaXZlbiBhbiBgZXJyYCwgcmV0dXJuIGEgYm9vbGVhbiByZXByZXNlbnRpbmcgd2hldGhlciBpdCBpcyBpbiB0aGUgc2hhcGUgb2ZcbiAqIGFuIGBFcnJvcmAgb3Igbm90LlxuICovXG5jb25zdCBpc0Vycm9yID0gKGVycikgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzTmFtZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIsIFwibmFtZVwiKTtcbiAgICAgICAgY29uc3QgaGFzTWVzc2FnZSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIsIFwibWVzc2FnZVwiKTtcbiAgICAgICAgcmV0dXJuIGhhc05hbWUgJiYgaGFzTWVzc2FnZTtcbiAgICB9XG4gICAgY2F0Y2ggKG5vb3BFcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG4vKipcbiAqIEdpdmVuIGFuIGB1bmtub3duYCBvYmplY3QsIHJldHJpZXZlIHRoZSBgbWVzc2FnZWAgcHJvcGVydHkgZnJvbSBpdCwgb3IgZmFsbFxuICogYmFjayB0byB0aGUgYGZhbGxiYWNrYCBzdHJpbmcgaWYgaXQgZG9lc24ndCBleGlzdCBvciBpcyBlbXB0eS5cbiAqL1xuY29uc3QgZ2V0RXJyb3JNZXNzYWdlID0gKGVyciwgZmFsbGJhY2spID0+IHtcbiAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHpvZF8xLnpcbiAgICAgICAgLm9iamVjdCh7IG1lc3NhZ2U6IHpvZF8xLnouc3RyaW5nKCkubWluKDEpIH0pXG4gICAgICAgIC5jYXRjaCh7IG1lc3NhZ2U6IGZhbGxiYWNrIH0pXG4gICAgICAgIC5wYXJzZShlcnIpO1xuICAgIHJldHVybiBtZXNzYWdlO1xufTtcbmV4cG9ydHMuZ2V0RXJyb3JNZXNzYWdlID0gZ2V0RXJyb3JNZXNzYWdlO1xuLyoqXG4gKiBHaXZlbiBhIHtAbGluayBQcmV0dHlFcnJvcn0sIHJldHVybiBhIG5pY2VseS1mb3JtYXR0ZWQgc3RyaW5nIHJlYWR5IHRvIGxvZ1xuICogb3IgdGhyb3cuXG4gKlxuICogVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGVycm9ycyBhcmUgbG9nZ2VkIGluIGEgY29uc2lzdGVudCwgaGVscGZ1bCBmb3JtYXRcbiAqIGFjcm9zcyB0aGUgU0RLIGJ5IHByb21wdGluZyBmb3Iga2V5IHBpZWNlcyBvZiBpbmZvcm1hdGlvbi5cbiAqL1xuY29uc3QgcHJldHR5RXJyb3IgPSAoeyB0eXBlID0gXCJlcnJvclwiLCB3aGF0SGFwcGVuZWQsIG90aGVyd2lzZSwgcmVhc3N1cmFuY2UsIHRvRml4Tm93LCB3aHksIGNvbnNlcXVlbmNlcywgc3RhY2ssIGNvZGUsIH0pID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgaWNvbiwgY29sb3JGbiB9ID0ge1xuICAgICAgICBlcnJvcjogeyBpY29uOiBcIuKdjFwiLCBjb2xvckZuOiBjaGFsa18xLmRlZmF1bHQucmVkIH0sXG4gICAgICAgIHdhcm46IHsgaWNvbjogXCLimqDvuI9cIiwgY29sb3JGbjogY2hhbGtfMS5kZWZhdWx0LnllbGxvdyB9LFxuICAgIH1bdHlwZV07XG4gICAgbGV0IGhlYWRlciA9IGAke2ljb259ICAke2NoYWxrXzEuZGVmYXVsdC5ib2xkLnVuZGVybGluZSh3aGF0SGFwcGVuZWQudHJpbSgpKX1gO1xuICAgIGlmIChzdGFjaykge1xuICAgICAgICBoZWFkZXIgKz1cbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgICAgIFsuLi4oKChfYSA9IG5ldyBFcnJvcigpLnN0YWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3BsaXQoXCJcXG5cIikuc2xpY2UoMSkuZmlsdGVyKEJvb2xlYW4pKSB8fCBbXSldLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIGxldCB0b0ZpeE5vd1N0ciA9IChfYiA9IChBcnJheS5pc0FycmF5KHRvRml4Tm93KVxuICAgICAgICA/IHRvRml4Tm93XG4gICAgICAgICAgICAubWFwKChzKSA9PiBzLnRyaW0oKSlcbiAgICAgICAgICAgIC5maWx0ZXIoQm9vbGVhbilcbiAgICAgICAgICAgIC5tYXAoKHMsIGkpID0+IGBcXHQke2kgKyAxfS4gJHtzfWApXG4gICAgICAgICAgICAuam9pbihcIlxcblwiKVxuICAgICAgICA6IHRvRml4Tm93ID09PSBudWxsIHx8IHRvRml4Tm93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b0ZpeE5vdy50cmltKCkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwiO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRvRml4Tm93KSAmJiB0b0ZpeE5vd1N0cikge1xuICAgICAgICB0b0ZpeE5vd1N0ciA9IGBUbyBmaXggdGhpcywgeW91IGNhbiB0YWtlIG9uZSBvZiB0aGUgZm9sbG93aW5nIGNvdXJzZXMgb2YgYWN0aW9uOlxcblxcbiR7dG9GaXhOb3dTdHJ9YDtcbiAgICB9XG4gICAgbGV0IGJvZHkgPSBbcmVhc3N1cmFuY2UgPT09IG51bGwgfHwgcmVhc3N1cmFuY2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlYXNzdXJhbmNlLnRyaW0oKSwgd2h5ID09PSBudWxsIHx8IHdoeSA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2h5LnRyaW0oKSwgY29uc2VxdWVuY2VzID09PSBudWxsIHx8IGNvbnNlcXVlbmNlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uc2VxdWVuY2VzLnRyaW0oKV1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbihcIiBcIik7XG4gICAgYm9keSArPSBib2R5ID8gYFxcblxcbiR7dG9GaXhOb3dTdHJ9YCA6IHRvRml4Tm93U3RyO1xuICAgIGNvbnN0IHRyYWlsZXIgPSBbb3RoZXJ3aXNlID09PSBudWxsIHx8IG90aGVyd2lzZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3RoZXJ3aXNlLnRyaW0oKV0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBbXG4gICAgICAgIGV4cG9ydHMucHJldHR5RXJyb3JTcGxpdHRlcixcbiAgICAgICAgaGVhZGVyLFxuICAgICAgICBib2R5LFxuICAgICAgICB0cmFpbGVyLFxuICAgICAgICBjb2RlID8gYENvZGU6ICR7Y29kZX1gIDogXCJcIixcbiAgICAgICAgZXhwb3J0cy5wcmV0dHlFcnJvclNwbGl0dGVyLFxuICAgIF1cbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbihcIlxcblxcblwiKTtcbiAgICByZXR1cm4gY29sb3JGbihtZXNzYWdlKTtcbn07XG5leHBvcnRzLnByZXR0eUVycm9yID0gcHJldHR5RXJyb3I7XG5leHBvcnRzLmZpeEV2ZW50S2V5TWlzc2luZ1N0ZXBzID0gW1xuICAgIFwiU2V0IHRoZSBgSU5OR0VTVF9FVkVOVF9LRVlgIGVudmlyb25tZW50IHZhcmlhYmxlXCIsXG4gICAgYFBhc3MgYSBrZXkgdG8gdGhlIFxcYG5ldyBJbm5nZXN0KClcXGAgY29uc3RydWN0b3IgdXNpbmcgdGhlIFxcYCR7XCJldmVudEtleVwifVxcYCBvcHRpb25gLFxuICAgIGBVc2UgXFxgaW5uZ2VzdC4ke1wic2V0RXZlbnRLZXlcIn0oKVxcYCBhdCBydW50aW1lYCxcbl07XG4vKipcbiAqIEFuIGVycm9yIHRoYXQsIHdoZW4gdGhyb3duLCBpbmRpY2F0ZXMgaW50ZXJuYWxseSB0aGF0IGFuIG91dGdvaW5nIG9wZXJhdGlvblxuICogY29udGFpbnMgYW4gZXJyb3IuXG4gKlxuICogV2UgdXNlIHRoaXMgYmVjYXVzZSBzZXJpYWxpemVkIGBkYXRhYCBzZW50IGJhY2sgdG8gSW5uZ2VzdCBtYXkgZGlmZmVyIGZyb21cbiAqIHRoZSBlcnJvciBpbnN0YW5jZSBpdHNlbGYgZHVlIHRvIG1pZGRsZXdhcmUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIE91dGdvaW5nUmVzdWx0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVzdWx0KSB7XG4gICAgICAgIHN1cGVyKFwiT3V0Z29pbmdPcEVycm9yXCIpO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICB9XG59XG5leHBvcnRzLk91dGdvaW5nUmVzdWx0RXJyb3IgPSBPdXRnb2luZ1Jlc3VsdEVycm9yO1xuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IHdpbGwgcmV0aHJvdyBhbiBlcnJvciB3aXRoIGEgcHJlZml4IGFkZGVkIHRvIHRoZVxuICogbWVzc2FnZS5cbiAqXG4gKiBVc2VmdWwgZm9yIGFkZGluZyBjb250ZXh0IHRvIGVycm9ycyB0aGF0IGFyZSByZXRocm93bi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGF3YWl0IGRvU29tZUFjdGlvbigpLmNhdGNoKHJldGhyb3dFcnJvcihcIkZhaWxlZCB0byBkbyBzb21lIGFjdGlvblwiKSk7XG4gKiBgYGBcbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IHJldGhyb3dFcnJvciA9IChwcmVmaXgpID0+IHtcbiAgICByZXR1cm4gKGVycikgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtbWVtYmVyLWFjY2VzcywgQHR5cGVzY3JpcHQtZXNsaW50L3Jlc3RyaWN0LXRlbXBsYXRlLWV4cHJlc3Npb25zXG4gICAgICAgICAgICBlcnIubWVzc2FnZSAmJiAoZXJyLm1lc3NhZ2UgPSBgJHtwcmVmaXh9OyAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChub29wRXJyKSB7XG4gICAgICAgICAgICAvLyBuby1vcFxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuc2FmZS1maW5hbGx5XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydHMucmV0aHJvd0Vycm9yID0gcmV0aHJvd0Vycm9yO1xuLyoqXG4gKiBMZWdhY3kgdjAgZXhlY3V0aW9uIGVycm9yIGZvciBmdW5jdGlvbnMgdGhhdCBkb24ndCBzdXBwb3J0IG1peGluZyBzdGVwcyBhbmRcbiAqIHJlZ3VsYXIgYXN5bmMgYWN0aW9ucy5cbiAqL1xuY29uc3QgZnVuY3Rpb25TdG9wcGVkUnVubmluZ0VyciA9IChjb2RlKSA9PiB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLnByZXR0eUVycm9yKSh7XG4gICAgICAgIHdoYXRIYXBwZW5lZDogXCJZb3VyIGZ1bmN0aW9uIHdhcyBzdG9wcGVkIGZyb20gcnVubmluZ1wiLFxuICAgICAgICB3aHk6IFwiV2UgZGV0ZWN0ZWQgYSBtaXggb2YgYXN5bmNocm9ub3VzIGxvZ2ljLCBzb21lIHVzaW5nIHN0ZXAgdG9vbGluZyBhbmQgc29tZSBub3QuXCIsXG4gICAgICAgIGNvbnNlcXVlbmNlczogXCJUaGlzIGNhbiBjYXVzZSB1bmV4cGVjdGVkIGJlaGF2aW91ciB3aGVuIGEgZnVuY3Rpb24gaXMgcGF1c2VkIGFuZCByZXN1bWVkIGFuZCBpcyB0aGVyZWZvcmUgc3Ryb25nbHkgZGlzY291cmFnZWQ7IHdlIHN0b3BwZWQgeW91ciBmdW5jdGlvbiB0byBlbnN1cmUgbm90aGluZyB1bmV4cGVjdGVkIGhhcHBlbmVkIVwiLFxuICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgdG9GaXhOb3c6IFwiRW5zdXJlIHRoYXQgeW91ciBmdW5jdGlvbiBpcyBlaXRoZXIgZW50aXJlbHkgc3RlcC1iYXNlZCBvciBlbnRpcmVseSBub24tc3RlcC1iYXNlZCwgYnkgZWl0aGVyIHdyYXBwaW5nIGFsbCBhc3luY2hyb25vdXMgbG9naWMgaW4gYHN0ZXAucnVuKClgIGNhbGxzIG9yIGJ5IHJlbW92aW5nIGFsbCBgc3RlcC4qKClgIGNhbGxzLlwiLFxuICAgICAgICBvdGhlcndpc2U6IFwiRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gd2h5IHN0ZXAgZnVuY3Rpb25zIHdvcmsgaW4gdGhpcyBtYW5uZXIsIHNlZSBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzL2Z1bmN0aW9ucy9tdWx0aS1zdGVwI2dvdGNoYXNcIixcbiAgICAgICAgY29kZSxcbiAgICB9KTtcbn07XG5leHBvcnRzLmZ1bmN0aW9uU3RvcHBlZFJ1bm5pbmdFcnIgPSBmdW5jdGlvblN0b3BwZWRSdW5uaW5nRXJyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/functions.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/helpers/functions.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetchAllFnData = exports.parseFnData = exports.undefinedToNull = exports.waterfall = exports.cacheFn = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst schema_js_1 = __webpack_require__(/*! ../api/schema.js */ \"(rsc)/./node_modules/inngest/api/schema.js\");\nconst InngestExecution_js_1 = __webpack_require__(/*! ../components/execution/InngestExecution.js */ \"(rsc)/./node_modules/inngest/components/execution/InngestExecution.js\");\nconst types_js_1 = __webpack_require__(/*! ../types.js */ \"(rsc)/./node_modules/inngest/types.js\");\nconst errors_js_1 = __webpack_require__(/*! ./errors.js */ \"(rsc)/./node_modules/inngest/helpers/errors.js\");\n/**\n * Wraps a function with a cache. When the returned function is run, it will\n * cache the result and return it on subsequent calls.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst cacheFn = (fn) => {\n    const key = \"value\";\n    const cache = new Map();\n    return ((...args) => {\n        if (!cache.has(key)) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            cache.set(key, fn(...args));\n        }\n        return cache.get(key);\n    });\n};\nexports.cacheFn = cacheFn;\n/**\n * Given an array of functions, return a new function that will run each\n * function in series and return the result of the final function. Regardless of\n * if the functions are synchronous or asynchronous, they'll be made into an\n * async promise chain.\n *\n * If an error is thrown, the waterfall will stop and return the error.\n *\n * Because this needs to support both sync and async functions, it only allows\n * functions that accept a single argument.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst waterfall = (fns, \n/**\n * A function that transforms the result of each function in the waterfall,\n * ready for the next function.\n *\n * Will not be called on the final function.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntransform) => {\n    return (...args) => {\n        const chain = fns.reduce(async (acc, fn) => {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const prev = await acc;\n            const output = (await fn(prev));\n            if (transform) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return await transform(prev, output);\n            }\n            if (typeof output === \"undefined\") {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                return prev;\n            }\n            return output;\n        }, Promise.resolve(args[0]));\n        return chain;\n    };\n};\nexports.waterfall = waterfall;\n/**\n * Given a value `v`, return `v` if it's not undefined, otherwise return `null`.\n */\nconst undefinedToNull = (v) => {\n    const isUndefined = typeof v === \"undefined\";\n    return isUndefined ? null : v;\n};\nexports.undefinedToNull = undefinedToNull;\nconst fnDataVersionSchema = zod_1.z.object({\n    version: zod_1.z\n        .literal(-1)\n        .or(zod_1.z.literal(0))\n        .or(zod_1.z.literal(1))\n        .or(zod_1.z.literal(2))\n        .optional()\n        .transform((v) => {\n        if (typeof v === \"undefined\") {\n            console.debug(`No request version specified by executor; defaulting to v${InngestExecution_js_1.PREFERRED_EXECUTION_VERSION}`);\n            return InngestExecution_js_1.PREFERRED_EXECUTION_VERSION;\n        }\n        return v === -1 ? InngestExecution_js_1.PREFERRED_EXECUTION_VERSION : v;\n    }),\n});\nconst parseFnData = (data) => {\n    let version;\n    try {\n        ({ version } = fnDataVersionSchema.parse(data));\n        const versionHandlers = {\n            [InngestExecution_js_1.ExecutionVersion.V0]: () => (Object.assign({ version: InngestExecution_js_1.ExecutionVersion.V0 }, zod_1.z\n                .object({\n                event: zod_1.z.record(zod_1.z.any()),\n                events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),\n                steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V0],\n                ctx: zod_1.z\n                    .object({\n                    run_id: zod_1.z.string(),\n                    attempt: zod_1.z.number().default(0),\n                    stack: zod_1.z\n                        .object({\n                        stack: zod_1.z\n                            .array(zod_1.z.string())\n                            .nullable()\n                            .transform((v) => (Array.isArray(v) ? v : [])),\n                        current: zod_1.z.number(),\n                    })\n                        .passthrough()\n                        .optional()\n                        .nullable(),\n                })\n                    .optional()\n                    .nullable(),\n                use_api: zod_1.z.boolean().default(false),\n            })\n                .parse(data))),\n            [InngestExecution_js_1.ExecutionVersion.V1]: () => (Object.assign({ version: InngestExecution_js_1.ExecutionVersion.V1 }, zod_1.z\n                .object({\n                event: zod_1.z.record(zod_1.z.any()),\n                events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),\n                steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V1],\n                ctx: zod_1.z\n                    .object({\n                    run_id: zod_1.z.string(),\n                    attempt: zod_1.z.number().default(0),\n                    disable_immediate_execution: zod_1.z.boolean().default(false),\n                    use_api: zod_1.z.boolean().default(false),\n                    stack: zod_1.z\n                        .object({\n                        stack: zod_1.z\n                            .array(zod_1.z.string())\n                            .nullable()\n                            .transform((v) => (Array.isArray(v) ? v : [])),\n                        current: zod_1.z.number(),\n                    })\n                        .passthrough()\n                        .optional()\n                        .nullable(),\n                })\n                    .optional()\n                    .nullable(),\n            })\n                .parse(data))),\n            [InngestExecution_js_1.ExecutionVersion.V2]: () => (Object.assign({ version: InngestExecution_js_1.ExecutionVersion.V2 }, zod_1.z\n                .object({\n                event: zod_1.z.record(zod_1.z.any()),\n                events: zod_1.z.array(zod_1.z.record(zod_1.z.any())).default([]),\n                steps: schema_js_1.stepsSchemas[InngestExecution_js_1.ExecutionVersion.V2],\n                ctx: zod_1.z\n                    .object({\n                    run_id: zod_1.z.string(),\n                    attempt: zod_1.z.number().default(0),\n                    disable_immediate_execution: zod_1.z.boolean().default(false),\n                    use_api: zod_1.z.boolean().default(false),\n                    stack: zod_1.z\n                        .object({\n                        stack: zod_1.z\n                            .array(zod_1.z.string())\n                            .nullable()\n                            .transform((v) => (Array.isArray(v) ? v : [])),\n                        current: zod_1.z.number(),\n                    })\n                        .passthrough()\n                        .optional()\n                        .nullable(),\n                })\n                    .optional()\n                    .nullable(),\n            })\n                .parse(data))),\n        };\n        return versionHandlers[version]();\n    }\n    catch (err) {\n        throw new Error(parseFailureErr(err));\n    }\n};\nexports.parseFnData = parseFnData;\nconst fetchAllFnData = async ({ data, api, version, }) => {\n    var _a, _b, _c, _d;\n    const result = Object.assign({}, data);\n    try {\n        if ((result.version === InngestExecution_js_1.ExecutionVersion.V0 && result.use_api) ||\n            (result.version === InngestExecution_js_1.ExecutionVersion.V1 && ((_a = result.ctx) === null || _a === void 0 ? void 0 : _a.use_api))) {\n            if (!((_b = result.ctx) === null || _b === void 0 ? void 0 : _b.run_id)) {\n                return (0, types_js_1.err)((0, errors_js_1.prettyError)({\n                    whatHappened: \"failed to attempt retrieving data from API\",\n                    consequences: \"function execution can't continue\",\n                    why: \"run_id is missing from context\",\n                    stack: true,\n                }));\n            }\n            const [evtResp, stepResp] = await Promise.all([\n                api.getRunBatch(result.ctx.run_id),\n                api.getRunSteps(result.ctx.run_id, version),\n            ]);\n            if (evtResp.ok) {\n                result.events = evtResp.value;\n            }\n            else {\n                return (0, types_js_1.err)((0, errors_js_1.prettyError)({\n                    whatHappened: \"failed to retrieve list of events\",\n                    consequences: \"function execution can't continue\",\n                    why: (_c = evtResp.error) === null || _c === void 0 ? void 0 : _c.error,\n                    stack: true,\n                }));\n            }\n            if (stepResp.ok) {\n                result.steps = stepResp.value;\n            }\n            else {\n                return (0, types_js_1.err)((0, errors_js_1.prettyError)({\n                    whatHappened: \"failed to retrieve steps for function run\",\n                    consequences: \"function execution can't continue\",\n                    why: (_d = stepResp.error) === null || _d === void 0 ? void 0 : _d.error,\n                    stack: true,\n                }));\n            }\n        }\n        return (0, types_js_1.ok)(result);\n    }\n    catch (error) {\n        // print it out for now.\n        // move to something like protobuf so we don't have to deal with this\n        console.error(error);\n        return (0, types_js_1.err)(parseFailureErr(error));\n    }\n};\nexports.fetchAllFnData = fetchAllFnData;\nconst parseFailureErr = (err) => {\n    let why;\n    if (err instanceof zod_1.ZodError) {\n        why = err.toString();\n    }\n    return (0, errors_js_1.prettyError)({\n        whatHappened: \"Failed to parse data from executor.\",\n        consequences: \"Function execution can't continue.\",\n        toFixNow: \"Make sure that your API is set up to parse incoming request bodies as JSON, like body-parser for Express (https://expressjs.com/en/resources/middleware/body-parser.html).\",\n        stack: true,\n        why,\n    });\n};\n//# sourceMappingURL=functions.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL2Z1bmN0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxtQkFBbUIsR0FBRyx1QkFBdUIsR0FBRyxpQkFBaUIsR0FBRyxlQUFlO0FBQzVHLGNBQWMsbUJBQU8sQ0FBQyxrREFBSztBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyxvRUFBa0I7QUFDOUMsOEJBQThCLG1CQUFPLENBQUMsMEhBQTZDO0FBQ25GLG1CQUFtQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3hDLG9CQUFvQixtQkFBTyxDQUFDLG1FQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLGlCQUFpQixrREFBa0Q7QUFDeEk7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckI7QUFDQSxnRkFBZ0Ysb0RBQW9EO0FBQ3BJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0ZBQWdGLG9EQUFvRDtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0ZBQWdGLG9EQUFvRDtBQUNwSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvZnVuY3Rpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mZXRjaEFsbEZuRGF0YSA9IGV4cG9ydHMucGFyc2VGbkRhdGEgPSBleHBvcnRzLnVuZGVmaW5lZFRvTnVsbCA9IGV4cG9ydHMud2F0ZXJmYWxsID0gZXhwb3J0cy5jYWNoZUZuID0gdm9pZCAwO1xuY29uc3Qgem9kXzEgPSByZXF1aXJlKFwiem9kXCIpO1xuY29uc3Qgc2NoZW1hX2pzXzEgPSByZXF1aXJlKFwiLi4vYXBpL3NjaGVtYS5qc1wiKTtcbmNvbnN0IElubmdlc3RFeGVjdXRpb25fanNfMSA9IHJlcXVpcmUoXCIuLi9jb21wb25lbnRzL2V4ZWN1dGlvbi9Jbm5nZXN0RXhlY3V0aW9uLmpzXCIpO1xuY29uc3QgdHlwZXNfanNfMSA9IHJlcXVpcmUoXCIuLi90eXBlcy5qc1wiKTtcbmNvbnN0IGVycm9yc19qc18xID0gcmVxdWlyZShcIi4vZXJyb3JzLmpzXCIpO1xuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHdpdGggYSBjYWNoZS4gV2hlbiB0aGUgcmV0dXJuZWQgZnVuY3Rpb24gaXMgcnVuLCBpdCB3aWxsXG4gKiBjYWNoZSB0aGUgcmVzdWx0IGFuZCByZXR1cm4gaXQgb24gc3Vic2VxdWVudCBjYWxscy5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGNhY2hlRm4gPSAoZm4pID0+IHtcbiAgICBjb25zdCBrZXkgPSBcInZhbHVlXCI7XG4gICAgY29uc3QgY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuICgoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoIWNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICAgICAgICAgICAgY2FjaGUuc2V0KGtleSwgZm4oLi4uYXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICB9KTtcbn07XG5leHBvcnRzLmNhY2hlRm4gPSBjYWNoZUZuO1xuLyoqXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBmdW5jdGlvbnMsIHJldHVybiBhIG5ldyBmdW5jdGlvbiB0aGF0IHdpbGwgcnVuIGVhY2hcbiAqIGZ1bmN0aW9uIGluIHNlcmllcyBhbmQgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGZpbmFsIGZ1bmN0aW9uLiBSZWdhcmRsZXNzIG9mXG4gKiBpZiB0aGUgZnVuY3Rpb25zIGFyZSBzeW5jaHJvbm91cyBvciBhc3luY2hyb25vdXMsIHRoZXknbGwgYmUgbWFkZSBpbnRvIGFuXG4gKiBhc3luYyBwcm9taXNlIGNoYWluLlxuICpcbiAqIElmIGFuIGVycm9yIGlzIHRocm93biwgdGhlIHdhdGVyZmFsbCB3aWxsIHN0b3AgYW5kIHJldHVybiB0aGUgZXJyb3IuXG4gKlxuICogQmVjYXVzZSB0aGlzIG5lZWRzIHRvIHN1cHBvcnQgYm90aCBzeW5jIGFuZCBhc3luYyBmdW5jdGlvbnMsIGl0IG9ubHkgYWxsb3dzXG4gKiBmdW5jdGlvbnMgdGhhdCBhY2NlcHQgYSBzaW5nbGUgYXJndW1lbnQuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCB3YXRlcmZhbGwgPSAoZm5zLCBcbi8qKlxuICogQSBmdW5jdGlvbiB0aGF0IHRyYW5zZm9ybXMgdGhlIHJlc3VsdCBvZiBlYWNoIGZ1bmN0aW9uIGluIHRoZSB3YXRlcmZhbGwsXG4gKiByZWFkeSBmb3IgdGhlIG5leHQgZnVuY3Rpb24uXG4gKlxuICogV2lsbCBub3QgYmUgY2FsbGVkIG9uIHRoZSBmaW5hbCBmdW5jdGlvbi5cbiAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbnRyYW5zZm9ybSkgPT4ge1xuICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBjaGFpbiA9IGZucy5yZWR1Y2UoYXN5bmMgKGFjYywgZm4pID0+IHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnRcbiAgICAgICAgICAgIGNvbnN0IHByZXYgPSBhd2FpdCBhY2M7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSAoYXdhaXQgZm4ocHJldikpO1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0cmFuc2Zvcm0ocHJldiwgb3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9LCBQcm9taXNlLnJlc29sdmUoYXJnc1swXSkpO1xuICAgICAgICByZXR1cm4gY2hhaW47XG4gICAgfTtcbn07XG5leHBvcnRzLndhdGVyZmFsbCA9IHdhdGVyZmFsbDtcbi8qKlxuICogR2l2ZW4gYSB2YWx1ZSBgdmAsIHJldHVybiBgdmAgaWYgaXQncyBub3QgdW5kZWZpbmVkLCBvdGhlcndpc2UgcmV0dXJuIGBudWxsYC5cbiAqL1xuY29uc3QgdW5kZWZpbmVkVG9OdWxsID0gKHYpID0+IHtcbiAgICBjb25zdCBpc1VuZGVmaW5lZCA9IHR5cGVvZiB2ID09PSBcInVuZGVmaW5lZFwiO1xuICAgIHJldHVybiBpc1VuZGVmaW5lZCA/IG51bGwgOiB2O1xufTtcbmV4cG9ydHMudW5kZWZpbmVkVG9OdWxsID0gdW5kZWZpbmVkVG9OdWxsO1xuY29uc3QgZm5EYXRhVmVyc2lvblNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICB2ZXJzaW9uOiB6b2RfMS56XG4gICAgICAgIC5saXRlcmFsKC0xKVxuICAgICAgICAub3Ioem9kXzEuei5saXRlcmFsKDApKVxuICAgICAgICAub3Ioem9kXzEuei5saXRlcmFsKDEpKVxuICAgICAgICAub3Ioem9kXzEuei5saXRlcmFsKDIpKVxuICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAudHJhbnNmb3JtKCh2KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhgTm8gcmVxdWVzdCB2ZXJzaW9uIHNwZWNpZmllZCBieSBleGVjdXRvcjsgZGVmYXVsdGluZyB0byB2JHtJbm5nZXN0RXhlY3V0aW9uX2pzXzEuUFJFRkVSUkVEX0VYRUNVVElPTl9WRVJTSU9OfWApO1xuICAgICAgICAgICAgcmV0dXJuIElubmdlc3RFeGVjdXRpb25fanNfMS5QUkVGRVJSRURfRVhFQ1VUSU9OX1ZFUlNJT047XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHYgPT09IC0xID8gSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLlBSRUZFUlJFRF9FWEVDVVRJT05fVkVSU0lPTiA6IHY7XG4gICAgfSksXG59KTtcbmNvbnN0IHBhcnNlRm5EYXRhID0gKGRhdGEpID0+IHtcbiAgICBsZXQgdmVyc2lvbjtcbiAgICB0cnkge1xuICAgICAgICAoeyB2ZXJzaW9uIH0gPSBmbkRhdGFWZXJzaW9uU2NoZW1hLnBhcnNlKGRhdGEpKTtcbiAgICAgICAgY29uc3QgdmVyc2lvbkhhbmRsZXJzID0ge1xuICAgICAgICAgICAgW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYwXTogKCkgPT4gKE9iamVjdC5hc3NpZ24oeyB2ZXJzaW9uOiBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMCB9LCB6b2RfMS56XG4gICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgZXZlbnQ6IHpvZF8xLnoucmVjb3JkKHpvZF8xLnouYW55KCkpLFxuICAgICAgICAgICAgICAgIGV2ZW50czogem9kXzEuei5hcnJheSh6b2RfMS56LnJlY29yZCh6b2RfMS56LmFueSgpKSkuZGVmYXVsdChbXSksXG4gICAgICAgICAgICAgICAgc3RlcHM6IHNjaGVtYV9qc18xLnN0ZXBzU2NoZW1hc1tJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMF0sXG4gICAgICAgICAgICAgICAgY3R4OiB6b2RfMS56XG4gICAgICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICBydW5faWQ6IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIGF0dGVtcHQ6IHpvZF8xLnoubnVtYmVyKCkuZGVmYXVsdCgwKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXJyYXkoem9kXzEuei5zdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubnVsbGFibGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2Zvcm0oKHYpID0+IChBcnJheS5pc0FycmF5KHYpID8gdiA6IFtdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiB6b2RfMS56Lm51bWJlcigpLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnBhc3N0aHJvdWdoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAubnVsbGFibGUoKSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAgICAgICAgICAgICAubnVsbGFibGUoKSxcbiAgICAgICAgICAgICAgICB1c2VfYXBpOiB6b2RfMS56LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnBhcnNlKGRhdGEpKSksXG4gICAgICAgICAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjFdOiAoKSA9PiAoT2JqZWN0LmFzc2lnbih7IHZlcnNpb246IElubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYxIH0sIHpvZF8xLnpcbiAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBldmVudDogem9kXzEuei5yZWNvcmQoem9kXzEuei5hbnkoKSksXG4gICAgICAgICAgICAgICAgZXZlbnRzOiB6b2RfMS56LmFycmF5KHpvZF8xLnoucmVjb3JkKHpvZF8xLnouYW55KCkpKS5kZWZhdWx0KFtdKSxcbiAgICAgICAgICAgICAgICBzdGVwczogc2NoZW1hX2pzXzEuc3RlcHNTY2hlbWFzW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYxXSxcbiAgICAgICAgICAgICAgICBjdHg6IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdDogem9kXzEuei5udW1iZXIoKS5kZWZhdWx0KDApLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlX2ltbWVkaWF0ZV9leGVjdXRpb246IHpvZF8xLnouYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICB1c2VfYXBpOiB6b2RfMS56LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXJyYXkoem9kXzEuei5zdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubnVsbGFibGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2Zvcm0oKHYpID0+IChBcnJheS5pc0FycmF5KHYpID8gdiA6IFtdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiB6b2RfMS56Lm51bWJlcigpLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnBhc3N0aHJvdWdoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAubnVsbGFibGUoKSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAgICAgICAgICAgICAubnVsbGFibGUoKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnBhcnNlKGRhdGEpKSksXG4gICAgICAgICAgICBbSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjJdOiAoKSA9PiAoT2JqZWN0LmFzc2lnbih7IHZlcnNpb246IElubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYyIH0sIHpvZF8xLnpcbiAgICAgICAgICAgICAgICAub2JqZWN0KHtcbiAgICAgICAgICAgICAgICBldmVudDogem9kXzEuei5yZWNvcmQoem9kXzEuei5hbnkoKSksXG4gICAgICAgICAgICAgICAgZXZlbnRzOiB6b2RfMS56LmFycmF5KHpvZF8xLnoucmVjb3JkKHpvZF8xLnouYW55KCkpKS5kZWZhdWx0KFtdKSxcbiAgICAgICAgICAgICAgICBzdGVwczogc2NoZW1hX2pzXzEuc3RlcHNTY2hlbWFzW0lubmdlc3RFeGVjdXRpb25fanNfMS5FeGVjdXRpb25WZXJzaW9uLlYyXSxcbiAgICAgICAgICAgICAgICBjdHg6IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAgICAgLm9iamVjdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bl9pZDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdDogem9kXzEuei5udW1iZXIoKS5kZWZhdWx0KDApLFxuICAgICAgICAgICAgICAgICAgICBkaXNhYmxlX2ltbWVkaWF0ZV9leGVjdXRpb246IHpvZF8xLnouYm9vbGVhbigpLmRlZmF1bHQoZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICB1c2VfYXBpOiB6b2RfMS56LmJvb2xlYW4oKS5kZWZhdWx0KGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vYmplY3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHpvZF8xLnpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuYXJyYXkoem9kXzEuei5zdHJpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAubnVsbGFibGUoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50cmFuc2Zvcm0oKHYpID0+IChBcnJheS5pc0FycmF5KHYpID8gdiA6IFtdKSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50OiB6b2RfMS56Lm51bWJlcigpLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnBhc3N0aHJvdWdoKClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vcHRpb25hbCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAubnVsbGFibGUoKSxcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAub3B0aW9uYWwoKVxuICAgICAgICAgICAgICAgICAgICAubnVsbGFibGUoKSxcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnBhcnNlKGRhdGEpKSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB2ZXJzaW9uSGFuZGxlcnNbdmVyc2lvbl0oKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocGFyc2VGYWlsdXJlRXJyKGVycikpO1xuICAgIH1cbn07XG5leHBvcnRzLnBhcnNlRm5EYXRhID0gcGFyc2VGbkRhdGE7XG5jb25zdCBmZXRjaEFsbEZuRGF0YSA9IGFzeW5jICh7IGRhdGEsIGFwaSwgdmVyc2lvbiwgfSkgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhKTtcbiAgICB0cnkge1xuICAgICAgICBpZiAoKHJlc3VsdC52ZXJzaW9uID09PSBJbm5nZXN0RXhlY3V0aW9uX2pzXzEuRXhlY3V0aW9uVmVyc2lvbi5WMCAmJiByZXN1bHQudXNlX2FwaSkgfHxcbiAgICAgICAgICAgIChyZXN1bHQudmVyc2lvbiA9PT0gSW5uZ2VzdEV4ZWN1dGlvbl9qc18xLkV4ZWN1dGlvblZlcnNpb24uVjEgJiYgKChfYSA9IHJlc3VsdC5jdHgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51c2VfYXBpKSkpIHtcbiAgICAgICAgICAgIGlmICghKChfYiA9IHJlc3VsdC5jdHgpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5ydW5faWQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikoKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCJmYWlsZWQgdG8gYXR0ZW1wdCByZXRyaWV2aW5nIGRhdGEgZnJvbSBBUElcIixcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcImZ1bmN0aW9uIGV4ZWN1dGlvbiBjYW4ndCBjb250aW51ZVwiLFxuICAgICAgICAgICAgICAgICAgICB3aHk6IFwicnVuX2lkIGlzIG1pc3NpbmcgZnJvbSBjb250ZXh0XCIsXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IFtldnRSZXNwLCBzdGVwUmVzcF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgYXBpLmdldFJ1bkJhdGNoKHJlc3VsdC5jdHgucnVuX2lkKSxcbiAgICAgICAgICAgICAgICBhcGkuZ2V0UnVuU3RlcHMocmVzdWx0LmN0eC5ydW5faWQsIHZlcnNpb24pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAoZXZ0UmVzcC5vaykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5ldmVudHMgPSBldnRSZXNwLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikoKDAsIGVycm9yc19qc18xLnByZXR0eUVycm9yKSh7XG4gICAgICAgICAgICAgICAgICAgIHdoYXRIYXBwZW5lZDogXCJmYWlsZWQgdG8gcmV0cmlldmUgbGlzdCBvZiBldmVudHNcIixcbiAgICAgICAgICAgICAgICAgICAgY29uc2VxdWVuY2VzOiBcImZ1bmN0aW9uIGV4ZWN1dGlvbiBjYW4ndCBjb250aW51ZVwiLFxuICAgICAgICAgICAgICAgICAgICB3aHk6IChfYyA9IGV2dFJlc3AuZXJyb3IpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5lcnJvcixcbiAgICAgICAgICAgICAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0ZXBSZXNwLm9rKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnN0ZXBzID0gc3RlcFJlc3AudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDAsIHR5cGVzX2pzXzEuZXJyKSgoMCwgZXJyb3JzX2pzXzEucHJldHR5RXJyb3IpKHtcbiAgICAgICAgICAgICAgICAgICAgd2hhdEhhcHBlbmVkOiBcImZhaWxlZCB0byByZXRyaWV2ZSBzdGVwcyBmb3IgZnVuY3Rpb24gcnVuXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnNlcXVlbmNlczogXCJmdW5jdGlvbiBleGVjdXRpb24gY2FuJ3QgY29udGludWVcIixcbiAgICAgICAgICAgICAgICAgICAgd2h5OiAoX2QgPSBzdGVwUmVzcC5lcnJvcikgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmVycm9yLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLm9rKShyZXN1bHQpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgLy8gcHJpbnQgaXQgb3V0IGZvciBub3cuXG4gICAgICAgIC8vIG1vdmUgdG8gc29tZXRoaW5nIGxpa2UgcHJvdG9idWYgc28gd2UgZG9uJ3QgaGF2ZSB0byBkZWFsIHdpdGggdGhpc1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuICgwLCB0eXBlc19qc18xLmVycikocGFyc2VGYWlsdXJlRXJyKGVycm9yKSk7XG4gICAgfVxufTtcbmV4cG9ydHMuZmV0Y2hBbGxGbkRhdGEgPSBmZXRjaEFsbEZuRGF0YTtcbmNvbnN0IHBhcnNlRmFpbHVyZUVyciA9IChlcnIpID0+IHtcbiAgICBsZXQgd2h5O1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiB6b2RfMS5ab2RFcnJvcikge1xuICAgICAgICB3aHkgPSBlcnIudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBlcnJvcnNfanNfMS5wcmV0dHlFcnJvcikoe1xuICAgICAgICB3aGF0SGFwcGVuZWQ6IFwiRmFpbGVkIHRvIHBhcnNlIGRhdGEgZnJvbSBleGVjdXRvci5cIixcbiAgICAgICAgY29uc2VxdWVuY2VzOiBcIkZ1bmN0aW9uIGV4ZWN1dGlvbiBjYW4ndCBjb250aW51ZS5cIixcbiAgICAgICAgdG9GaXhOb3c6IFwiTWFrZSBzdXJlIHRoYXQgeW91ciBBUEkgaXMgc2V0IHVwIHRvIHBhcnNlIGluY29taW5nIHJlcXVlc3QgYm9kaWVzIGFzIEpTT04sIGxpa2UgYm9keS1wYXJzZXIgZm9yIEV4cHJlc3MgKGh0dHBzOi8vZXhwcmVzc2pzLmNvbS9lbi9yZXNvdXJjZXMvbWlkZGxld2FyZS9ib2R5LXBhcnNlci5odG1sKS5cIixcbiAgICAgICAgc3RhY2s6IHRydWUsXG4gICAgICAgIHdoeSxcbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbnMuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/functions.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/net.js":
/*!*********************************************!*\
  !*** ./node_modules/inngest/helpers/net.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fetchWithAuthFallback = fetchWithAuthFallback;\nexports.signDataWithKey = signDataWithKey;\nconst canonicalize_1 = __importDefault(__webpack_require__(/*! canonicalize */ \"(rsc)/./node_modules/canonicalize/lib/canonicalize.js\"));\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\n/**\n * Send an HTTP request with the given signing key. If the response is a 401 or\n * 403, then try again with the fallback signing key\n */\nasync function fetchWithAuthFallback({ authToken, authTokenFallback, fetch, options, url, }) {\n    let res = await fetch(url, Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), { Authorization: `Bearer ${authToken}` }) }));\n    if ([401, 403].includes(res.status) && authTokenFallback) {\n        res = await fetch(url, Object.assign(Object.assign({}, options), { headers: Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.headers), { Authorization: `Bearer ${authTokenFallback}` }) }));\n    }\n    return res;\n}\nfunction signDataWithKey(data, signingKey, ts) {\n    // Calculate the HMAC of the request body ourselves.\n    // We make the assumption here that a stringified body is the same as the\n    // raw bytes; it may be pertinent in the future to always parse, then\n    // canonicalize the body to ensure it's consistent.\n    const encoded = typeof data === \"string\" ? data : (0, canonicalize_1.default)(data);\n    // Remove the `/signkey-[test|prod]-/` prefix from our signing key to calculate the HMAC.\n    const key = signingKey.replace(/signkey-\\w+-/, \"\");\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument, @typescript-eslint/no-explicit-any\n    const mac = (0, hash_js_1.hmac)(hash_js_1.sha256, key)\n        .update(encoded)\n        .update(ts)\n        .digest(\"hex\");\n    return mac;\n}\n//# sourceMappingURL=net.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL25ldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qix1QkFBdUI7QUFDdkIsdUNBQXVDLG1CQUFPLENBQUMsMkVBQWM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMseURBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0RBQW9EO0FBQzNGLDZEQUE2RCxjQUFjLHVDQUF1Qyx3RUFBd0UseUJBQXlCLFVBQVUsR0FBRyxHQUFHO0FBQ25PO0FBQ0EsNkRBQTZELGNBQWMsdUNBQXVDLHdFQUF3RSx5QkFBeUIsa0JBQWtCLEdBQUcsR0FBRztBQUMzTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvaGFyc2hzaHJpdmFzdGF2L0Rlc2t0b3AvQ29kaW5nIFByb2plY3RzL0pvYi1Bc3Npc3RhbnQtQWdlbnQvbm9kZV9tb2R1bGVzL2lubmdlc3QvaGVscGVycy9uZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmZldGNoV2l0aEF1dGhGYWxsYmFjayA9IGZldGNoV2l0aEF1dGhGYWxsYmFjaztcbmV4cG9ydHMuc2lnbkRhdGFXaXRoS2V5ID0gc2lnbkRhdGFXaXRoS2V5O1xuY29uc3QgY2Fub25pY2FsaXplXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImNhbm9uaWNhbGl6ZVwiKSk7XG5jb25zdCBoYXNoX2pzXzEgPSByZXF1aXJlKFwiaGFzaC5qc1wiKTtcbi8qKlxuICogU2VuZCBhbiBIVFRQIHJlcXVlc3Qgd2l0aCB0aGUgZ2l2ZW4gc2lnbmluZyBrZXkuIElmIHRoZSByZXNwb25zZSBpcyBhIDQwMSBvclxuICogNDAzLCB0aGVuIHRyeSBhZ2FpbiB3aXRoIHRoZSBmYWxsYmFjayBzaWduaW5nIGtleVxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaFdpdGhBdXRoRmFsbGJhY2soeyBhdXRoVG9rZW4sIGF1dGhUb2tlbkZhbGxiYWNrLCBmZXRjaCwgb3B0aW9ucywgdXJsLCB9KSB7XG4gICAgbGV0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSwgeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aFRva2VufWAgfSkgfSkpO1xuICAgIGlmIChbNDAxLCA0MDNdLmluY2x1ZGVzKHJlcy5zdGF0dXMpICYmIGF1dGhUb2tlbkZhbGxiYWNrKSB7XG4gICAgICAgIHJlcyA9IGF3YWl0IGZldGNoKHVybCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBoZWFkZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5oZWFkZXJzKSwgeyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7YXV0aFRva2VuRmFsbGJhY2t9YCB9KSB9KSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBzaWduRGF0YVdpdGhLZXkoZGF0YSwgc2lnbmluZ0tleSwgdHMpIHtcbiAgICAvLyBDYWxjdWxhdGUgdGhlIEhNQUMgb2YgdGhlIHJlcXVlc3QgYm9keSBvdXJzZWx2ZXMuXG4gICAgLy8gV2UgbWFrZSB0aGUgYXNzdW1wdGlvbiBoZXJlIHRoYXQgYSBzdHJpbmdpZmllZCBib2R5IGlzIHRoZSBzYW1lIGFzIHRoZVxuICAgIC8vIHJhdyBieXRlczsgaXQgbWF5IGJlIHBlcnRpbmVudCBpbiB0aGUgZnV0dXJlIHRvIGFsd2F5cyBwYXJzZSwgdGhlblxuICAgIC8vIGNhbm9uaWNhbGl6ZSB0aGUgYm9keSB0byBlbnN1cmUgaXQncyBjb25zaXN0ZW50LlxuICAgIGNvbnN0IGVuY29kZWQgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiA/IGRhdGEgOiAoMCwgY2Fub25pY2FsaXplXzEuZGVmYXVsdCkoZGF0YSk7XG4gICAgLy8gUmVtb3ZlIHRoZSBgL3NpZ25rZXktW3Rlc3R8cHJvZF0tL2AgcHJlZml4IGZyb20gb3VyIHNpZ25pbmcga2V5IHRvIGNhbGN1bGF0ZSB0aGUgSE1BQy5cbiAgICBjb25zdCBrZXkgPSBzaWduaW5nS2V5LnJlcGxhY2UoL3NpZ25rZXktXFx3Ky0vLCBcIlwiKTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IG1hYyA9ICgwLCBoYXNoX2pzXzEuaG1hYykoaGFzaF9qc18xLnNoYTI1Niwga2V5KVxuICAgICAgICAudXBkYXRlKGVuY29kZWQpXG4gICAgICAgIC51cGRhdGUodHMpXG4gICAgICAgIC5kaWdlc3QoXCJoZXhcIik7XG4gICAgcmV0dXJuIG1hYztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5ldC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/net.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/promises.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/helpers/promises.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports) {

eval("\nvar __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }\nvar __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n    function fulfill(value) { resume(\"next\", value); }\n    function reject(value) { resume(\"throw\", value); }\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.retryWithBackoff = exports.resolveNextTick = exports.runAsPromise = exports.createTimeoutPromise = exports.createDeferredPromiseWithStack = exports.createDeferredPromise = exports.resolveAfterPending = exports.createFrozenPromise = void 0;\n/**\n * Some environments don't allow access to the global queueMicrotask(). While we\n * had assumed this was only true for those powered by earlier versions of Node\n * (<14) that we don't officially support, Vercel's Edge Functions also obscure\n * the function in dev, even though the platform it's based on (Cloudflare\n * Workers) appropriately exposes it. Even worse, production Vercel Edge\n * Functions can see the function, but it immediately blows up the function when\n * used.\n *\n * Therefore, we can fall back to a reasonable alternative of\n * `Promise.resolve().then(fn)` instead. This _may_ be slightly slower in modern\n * environments, but at least we can still work in these environments.\n */\nconst shimQueueMicrotask = (callback) => {\n    void Promise.resolve().then(callback);\n};\n/**\n * A helper function to create a `Promise` that will never settle.\n *\n * It purposefully creates no references to `resolve` or `reject` so that the\n * returned `Promise` will remain unsettled until it falls out of scope and is\n * garbage collected.\n *\n * This should be used within transient closures to fake asynchronous action, so\n * long as it's guaranteed that they will fall out of scope.\n */\nconst createFrozenPromise = () => {\n    return new Promise(() => undefined);\n};\nexports.createFrozenPromise = createFrozenPromise;\n/**\n * Returns a Promise that resolves after the current event loop's microtasks\n * have finished, but before the next event loop tick.\n */\nconst resolveAfterPending = (count = 100) => {\n    /**\n     * This uses a brute force implementation that will continue to enqueue\n     * microtasks 10 times before resolving. This is to ensure that the microtask\n     * queue is drained, even if the microtask queue is being manipulated by other\n     * code.\n     *\n     * While this still doesn't guarantee that the microtask queue is drained,\n     * it's our best bet for giving other non-controlled promises a chance to\n     * resolve before we continue without resorting to falling in to the next\n     * tick.\n     */\n    return new Promise((resolve) => {\n        let i = 0;\n        const iterate = () => {\n            shimQueueMicrotask(() => {\n                if (i++ > count) {\n                    return resolve();\n                }\n                iterate();\n            });\n        };\n        iterate();\n    });\n};\nexports.resolveAfterPending = resolveAfterPending;\n/**\n * Creates and returns Promise that can be resolved or rejected with the\n * returned `resolve` and `reject` functions.\n *\n * Resolving or rejecting the function will return a new set of Promise control\n * functions. These can be ignored if the original Promise is all that's needed.\n */\nconst createDeferredPromise = () => {\n    let resolve;\n    let reject;\n    const promise = new Promise((_resolve, _reject) => {\n        resolve = (value) => {\n            _resolve(value);\n            return (0, exports.createDeferredPromise)();\n        };\n        reject = (reason) => {\n            _reject(reason);\n            return (0, exports.createDeferredPromise)();\n        };\n    });\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return { promise, resolve: resolve, reject: reject };\n};\nexports.createDeferredPromise = createDeferredPromise;\n/**\n * Creates and returns a deferred Promise that can be resolved or rejected with\n * the returned `resolve` and `reject` functions.\n *\n * For each Promise resolved or rejected this way, this will also keep a stack\n * of all unhandled Promises, resolved or rejected.\n *\n * Once a Promise is read, it is removed from the stack.\n */\nconst createDeferredPromiseWithStack = () => {\n    const settledPromises = [];\n    let rotateQueue = () => { };\n    const results = (function () {\n        return __asyncGenerator(this, arguments, function* () {\n            while (true) {\n                const next = settledPromises.shift();\n                if (next) {\n                    yield yield __await(next);\n                }\n                else {\n                    yield __await(new Promise((resolve) => {\n                        rotateQueue = resolve;\n                    }));\n                }\n            }\n        });\n    })();\n    const shimDeferredPromise = (deferred) => {\n        const originalResolve = deferred.resolve;\n        const originalReject = deferred.reject;\n        deferred.resolve = (value) => {\n            settledPromises.push(deferred.promise);\n            rotateQueue();\n            return shimDeferredPromise(originalResolve(value));\n        };\n        deferred.reject = (reason) => {\n            settledPromises.push(deferred.promise);\n            rotateQueue();\n            return shimDeferredPromise(originalReject(reason));\n        };\n        return deferred;\n    };\n    const deferred = shimDeferredPromise((0, exports.createDeferredPromise)());\n    return { deferred, results };\n};\nexports.createDeferredPromiseWithStack = createDeferredPromiseWithStack;\n/**\n * Creates a Promise that will resolve after the given duration, along with\n * methods to start, clear, and reset the timeout.\n */\nconst createTimeoutPromise = (duration) => {\n    const { promise, resolve } = (0, exports.createDeferredPromise)();\n    let timeout;\n    // eslint-disable-next-line prefer-const\n    let ret;\n    const start = () => {\n        if (timeout)\n            return ret;\n        timeout = setTimeout(() => {\n            resolve();\n        }, duration);\n        return ret;\n    };\n    const clear = () => {\n        clearTimeout(timeout);\n        timeout = undefined;\n    };\n    const reset = () => {\n        clear();\n        return start();\n    };\n    ret = Object.assign(promise, { start, clear, reset });\n    return ret;\n};\nexports.createTimeoutPromise = createTimeoutPromise;\n/**\n * Take any function and safely promisify such that both synchronous and\n * asynchronous errors are caught and returned as a rejected Promise.\n *\n * The passed `fn` can be undefined to support functions that may conditionally\n * be defined.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst runAsPromise = (fn\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n) => {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return Promise.resolve().then(fn);\n};\nexports.runAsPromise = runAsPromise;\n/**\n * Returns a Promise that resolve after the current event loop tick.\n */\nconst resolveNextTick = () => {\n    return new Promise((resolve) => setTimeout(resolve));\n};\nexports.resolveNextTick = resolveNextTick;\nconst retryWithBackoff = async (fn, opts) => {\n    var _a;\n    const maxAttempts = (opts === null || opts === void 0 ? void 0 : opts.maxAttempts) || 5;\n    const baseDelay = (_a = opts === null || opts === void 0 ? void 0 : opts.baseDelay) !== null && _a !== void 0 ? _a : 100;\n    for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n        try {\n            return await fn();\n        }\n        catch (err) {\n            if (attempt >= maxAttempts) {\n                throw err;\n            }\n            const jitter = Math.random() * baseDelay;\n            const delay = baseDelay * Math.pow(2, attempt - 1) + jitter;\n            await new Promise((resolve) => setTimeout(resolve, delay));\n        }\n    }\n    throw new Error(\"Max retries reached; this should be unreachable.\");\n};\nexports.retryWithBackoff = retryWithBackoff;\n//# sourceMappingURL=promises.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3Byb21pc2VzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLDBNQUEwTSxjQUFjO0FBQ3hOLDhCQUE4QixzQkFBc0I7QUFDcEQsMEJBQTBCLFlBQVksc0JBQXNCLHFDQUFxQywyQ0FBMkMsTUFBTTtBQUNsSiw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsd0JBQXdCLEdBQUcsdUJBQXVCLEdBQUcsb0JBQW9CLEdBQUcsNEJBQTRCLEdBQUcsc0NBQXNDLEdBQUcsNkJBQTZCLEdBQUcsMkJBQTJCLEdBQUcsMkJBQTJCO0FBQzdPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxhQUFhO0FBQ2I7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQW1CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hEO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0JBQXdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHdCQUF3QjtBQUN4QiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvcHJvbWlzZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdCA9ICh0aGlzICYmIHRoaXMuX19hd2FpdCkgfHwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7IH1cbnZhciBfX2FzeW5jR2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2FzeW5jR2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICAgIHJldHVybiBpID0gT2JqZWN0LmNyZWF0ZSgodHlwZW9mIEFzeW5jSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEFzeW5jSXRlcmF0b3IgOiBPYmplY3QpLnByb3RvdHlwZSksIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiwgYXdhaXRSZXR1cm4pLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XG4gICAgZnVuY3Rpb24gYXdhaXRSZXR1cm4oZikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGYsIHJlamVjdCk7IH07IH1cbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXRyeVdpdGhCYWNrb2ZmID0gZXhwb3J0cy5yZXNvbHZlTmV4dFRpY2sgPSBleHBvcnRzLnJ1bkFzUHJvbWlzZSA9IGV4cG9ydHMuY3JlYXRlVGltZW91dFByb21pc2UgPSBleHBvcnRzLmNyZWF0ZURlZmVycmVkUHJvbWlzZVdpdGhTdGFjayA9IGV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gZXhwb3J0cy5yZXNvbHZlQWZ0ZXJQZW5kaW5nID0gZXhwb3J0cy5jcmVhdGVGcm96ZW5Qcm9taXNlID0gdm9pZCAwO1xuLyoqXG4gKiBTb21lIGVudmlyb25tZW50cyBkb24ndCBhbGxvdyBhY2Nlc3MgdG8gdGhlIGdsb2JhbCBxdWV1ZU1pY3JvdGFzaygpLiBXaGlsZSB3ZVxuICogaGFkIGFzc3VtZWQgdGhpcyB3YXMgb25seSB0cnVlIGZvciB0aG9zZSBwb3dlcmVkIGJ5IGVhcmxpZXIgdmVyc2lvbnMgb2YgTm9kZVxuICogKDwxNCkgdGhhdCB3ZSBkb24ndCBvZmZpY2lhbGx5IHN1cHBvcnQsIFZlcmNlbCdzIEVkZ2UgRnVuY3Rpb25zIGFsc28gb2JzY3VyZVxuICogdGhlIGZ1bmN0aW9uIGluIGRldiwgZXZlbiB0aG91Z2ggdGhlIHBsYXRmb3JtIGl0J3MgYmFzZWQgb24gKENsb3VkZmxhcmVcbiAqIFdvcmtlcnMpIGFwcHJvcHJpYXRlbHkgZXhwb3NlcyBpdC4gRXZlbiB3b3JzZSwgcHJvZHVjdGlvbiBWZXJjZWwgRWRnZVxuICogRnVuY3Rpb25zIGNhbiBzZWUgdGhlIGZ1bmN0aW9uLCBidXQgaXQgaW1tZWRpYXRlbHkgYmxvd3MgdXAgdGhlIGZ1bmN0aW9uIHdoZW5cbiAqIHVzZWQuXG4gKlxuICogVGhlcmVmb3JlLCB3ZSBjYW4gZmFsbCBiYWNrIHRvIGEgcmVhc29uYWJsZSBhbHRlcm5hdGl2ZSBvZlxuICogYFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pYCBpbnN0ZWFkLiBUaGlzIF9tYXlfIGJlIHNsaWdodGx5IHNsb3dlciBpbiBtb2Rlcm5cbiAqIGVudmlyb25tZW50cywgYnV0IGF0IGxlYXN0IHdlIGNhbiBzdGlsbCB3b3JrIGluIHRoZXNlIGVudmlyb25tZW50cy5cbiAqL1xuY29uc3Qgc2hpbVF1ZXVlTWljcm90YXNrID0gKGNhbGxiYWNrKSA9PiB7XG4gICAgdm9pZCBQcm9taXNlLnJlc29sdmUoKS50aGVuKGNhbGxiYWNrKTtcbn07XG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGBQcm9taXNlYCB0aGF0IHdpbGwgbmV2ZXIgc2V0dGxlLlxuICpcbiAqIEl0IHB1cnBvc2VmdWxseSBjcmVhdGVzIG5vIHJlZmVyZW5jZXMgdG8gYHJlc29sdmVgIG9yIGByZWplY3RgIHNvIHRoYXQgdGhlXG4gKiByZXR1cm5lZCBgUHJvbWlzZWAgd2lsbCByZW1haW4gdW5zZXR0bGVkIHVudGlsIGl0IGZhbGxzIG91dCBvZiBzY29wZSBhbmQgaXNcbiAqIGdhcmJhZ2UgY29sbGVjdGVkLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgd2l0aGluIHRyYW5zaWVudCBjbG9zdXJlcyB0byBmYWtlIGFzeW5jaHJvbm91cyBhY3Rpb24sIHNvXG4gKiBsb25nIGFzIGl0J3MgZ3VhcmFudGVlZCB0aGF0IHRoZXkgd2lsbCBmYWxsIG91dCBvZiBzY29wZS5cbiAqL1xuY29uc3QgY3JlYXRlRnJvemVuUHJvbWlzZSA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKCkgPT4gdW5kZWZpbmVkKTtcbn07XG5leHBvcnRzLmNyZWF0ZUZyb3plblByb21pc2UgPSBjcmVhdGVGcm96ZW5Qcm9taXNlO1xuLyoqXG4gKiBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIGFmdGVyIHRoZSBjdXJyZW50IGV2ZW50IGxvb3AncyBtaWNyb3Rhc2tzXG4gKiBoYXZlIGZpbmlzaGVkLCBidXQgYmVmb3JlIHRoZSBuZXh0IGV2ZW50IGxvb3AgdGljay5cbiAqL1xuY29uc3QgcmVzb2x2ZUFmdGVyUGVuZGluZyA9IChjb3VudCA9IDEwMCkgPT4ge1xuICAgIC8qKlxuICAgICAqIFRoaXMgdXNlcyBhIGJydXRlIGZvcmNlIGltcGxlbWVudGF0aW9uIHRoYXQgd2lsbCBjb250aW51ZSB0byBlbnF1ZXVlXG4gICAgICogbWljcm90YXNrcyAxMCB0aW1lcyBiZWZvcmUgcmVzb2x2aW5nLiBUaGlzIGlzIHRvIGVuc3VyZSB0aGF0IHRoZSBtaWNyb3Rhc2tcbiAgICAgKiBxdWV1ZSBpcyBkcmFpbmVkLCBldmVuIGlmIHRoZSBtaWNyb3Rhc2sgcXVldWUgaXMgYmVpbmcgbWFuaXB1bGF0ZWQgYnkgb3RoZXJcbiAgICAgKiBjb2RlLlxuICAgICAqXG4gICAgICogV2hpbGUgdGhpcyBzdGlsbCBkb2Vzbid0IGd1YXJhbnRlZSB0aGF0IHRoZSBtaWNyb3Rhc2sgcXVldWUgaXMgZHJhaW5lZCxcbiAgICAgKiBpdCdzIG91ciBiZXN0IGJldCBmb3IgZ2l2aW5nIG90aGVyIG5vbi1jb250cm9sbGVkIHByb21pc2VzIGEgY2hhbmNlIHRvXG4gICAgICogcmVzb2x2ZSBiZWZvcmUgd2UgY29udGludWUgd2l0aG91dCByZXNvcnRpbmcgdG8gZmFsbGluZyBpbiB0byB0aGUgbmV4dFxuICAgICAqIHRpY2suXG4gICAgICovXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgaXRlcmF0ZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHNoaW1RdWV1ZU1pY3JvdGFzaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGkrKyA+IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZXJhdGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpdGVyYXRlKCk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5yZXNvbHZlQWZ0ZXJQZW5kaW5nID0gcmVzb2x2ZUFmdGVyUGVuZGluZztcbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBQcm9taXNlIHRoYXQgY2FuIGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIHdpdGggdGhlXG4gKiByZXR1cm5lZCBgcmVzb2x2ZWAgYW5kIGByZWplY3RgIGZ1bmN0aW9ucy5cbiAqXG4gKiBSZXNvbHZpbmcgb3IgcmVqZWN0aW5nIHRoZSBmdW5jdGlvbiB3aWxsIHJldHVybiBhIG5ldyBzZXQgb2YgUHJvbWlzZSBjb250cm9sXG4gKiBmdW5jdGlvbnMuIFRoZXNlIGNhbiBiZSBpZ25vcmVkIGlmIHRoZSBvcmlnaW5hbCBQcm9taXNlIGlzIGFsbCB0aGF0J3MgbmVlZGVkLlxuICovXG5jb25zdCBjcmVhdGVEZWZlcnJlZFByb21pc2UgPSAoKSA9PiB7XG4gICAgbGV0IHJlc29sdmU7XG4gICAgbGV0IHJlamVjdDtcbiAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKF9yZXNvbHZlLCBfcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIF9yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlamVjdCA9IChyZWFzb24pID0+IHtcbiAgICAgICAgICAgIF9yZWplY3QocmVhc29uKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZXhwb3J0cy5jcmVhdGVEZWZlcnJlZFByb21pc2UpKCk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICByZXR1cm4geyBwcm9taXNlLCByZXNvbHZlOiByZXNvbHZlLCByZWplY3Q6IHJlamVjdCB9O1xufTtcbmV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlID0gY3JlYXRlRGVmZXJyZWRQcm9taXNlO1xuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGEgZGVmZXJyZWQgUHJvbWlzZSB0aGF0IGNhbiBiZSByZXNvbHZlZCBvciByZWplY3RlZCB3aXRoXG4gKiB0aGUgcmV0dXJuZWQgYHJlc29sdmVgIGFuZCBgcmVqZWN0YCBmdW5jdGlvbnMuXG4gKlxuICogRm9yIGVhY2ggUHJvbWlzZSByZXNvbHZlZCBvciByZWplY3RlZCB0aGlzIHdheSwgdGhpcyB3aWxsIGFsc28ga2VlcCBhIHN0YWNrXG4gKiBvZiBhbGwgdW5oYW5kbGVkIFByb21pc2VzLCByZXNvbHZlZCBvciByZWplY3RlZC5cbiAqXG4gKiBPbmNlIGEgUHJvbWlzZSBpcyByZWFkLCBpdCBpcyByZW1vdmVkIGZyb20gdGhlIHN0YWNrLlxuICovXG5jb25zdCBjcmVhdGVEZWZlcnJlZFByb21pc2VXaXRoU3RhY2sgPSAoKSA9PiB7XG4gICAgY29uc3Qgc2V0dGxlZFByb21pc2VzID0gW107XG4gICAgbGV0IHJvdGF0ZVF1ZXVlID0gKCkgPT4geyB9O1xuICAgIGNvbnN0IHJlc3VsdHMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hc3luY0dlbmVyYXRvcih0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBzZXR0bGVkUHJvbWlzZXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB5aWVsZCBfX2F3YWl0KG5leHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgX19hd2FpdChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlUXVldWUgPSByZXNvbHZlO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHNoaW1EZWZlcnJlZFByb21pc2UgPSAoZGVmZXJyZWQpID0+IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxSZXNvbHZlID0gZGVmZXJyZWQucmVzb2x2ZTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxSZWplY3QgPSBkZWZlcnJlZC5yZWplY3Q7XG4gICAgICAgIGRlZmVycmVkLnJlc29sdmUgPSAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHNldHRsZWRQcm9taXNlcy5wdXNoKGRlZmVycmVkLnByb21pc2UpO1xuICAgICAgICAgICAgcm90YXRlUXVldWUoKTtcbiAgICAgICAgICAgIHJldHVybiBzaGltRGVmZXJyZWRQcm9taXNlKG9yaWdpbmFsUmVzb2x2ZSh2YWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBkZWZlcnJlZC5yZWplY3QgPSAocmVhc29uKSA9PiB7XG4gICAgICAgICAgICBzZXR0bGVkUHJvbWlzZXMucHVzaChkZWZlcnJlZC5wcm9taXNlKTtcbiAgICAgICAgICAgIHJvdGF0ZVF1ZXVlKCk7XG4gICAgICAgICAgICByZXR1cm4gc2hpbURlZmVycmVkUHJvbWlzZShvcmlnaW5hbFJlamVjdChyZWFzb24pKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkO1xuICAgIH07XG4gICAgY29uc3QgZGVmZXJyZWQgPSBzaGltRGVmZXJyZWRQcm9taXNlKCgwLCBleHBvcnRzLmNyZWF0ZURlZmVycmVkUHJvbWlzZSkoKSk7XG4gICAgcmV0dXJuIHsgZGVmZXJyZWQsIHJlc3VsdHMgfTtcbn07XG5leHBvcnRzLmNyZWF0ZURlZmVycmVkUHJvbWlzZVdpdGhTdGFjayA9IGNyZWF0ZURlZmVycmVkUHJvbWlzZVdpdGhTdGFjaztcbi8qKlxuICogQ3JlYXRlcyBhIFByb21pc2UgdGhhdCB3aWxsIHJlc29sdmUgYWZ0ZXIgdGhlIGdpdmVuIGR1cmF0aW9uLCBhbG9uZyB3aXRoXG4gKiBtZXRob2RzIHRvIHN0YXJ0LCBjbGVhciwgYW5kIHJlc2V0IHRoZSB0aW1lb3V0LlxuICovXG5jb25zdCBjcmVhdGVUaW1lb3V0UHJvbWlzZSA9IChkdXJhdGlvbikgPT4ge1xuICAgIGNvbnN0IHsgcHJvbWlzZSwgcmVzb2x2ZSB9ID0gKDAsIGV4cG9ydHMuY3JlYXRlRGVmZXJyZWRQcm9taXNlKSgpO1xuICAgIGxldCB0aW1lb3V0O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItY29uc3RcbiAgICBsZXQgcmV0O1xuICAgIGNvbnN0IHN0YXJ0ID0gKCkgPT4ge1xuICAgICAgICBpZiAodGltZW91dClcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH07XG4gICAgY29uc3QgY2xlYXIgPSAoKSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICBjbGVhcigpO1xuICAgICAgICByZXR1cm4gc3RhcnQoKTtcbiAgICB9O1xuICAgIHJldCA9IE9iamVjdC5hc3NpZ24ocHJvbWlzZSwgeyBzdGFydCwgY2xlYXIsIHJlc2V0IH0pO1xuICAgIHJldHVybiByZXQ7XG59O1xuZXhwb3J0cy5jcmVhdGVUaW1lb3V0UHJvbWlzZSA9IGNyZWF0ZVRpbWVvdXRQcm9taXNlO1xuLyoqXG4gKiBUYWtlIGFueSBmdW5jdGlvbiBhbmQgc2FmZWx5IHByb21pc2lmeSBzdWNoIHRoYXQgYm90aCBzeW5jaHJvbm91cyBhbmRcbiAqIGFzeW5jaHJvbm91cyBlcnJvcnMgYXJlIGNhdWdodCBhbmQgcmV0dXJuZWQgYXMgYSByZWplY3RlZCBQcm9taXNlLlxuICpcbiAqIFRoZSBwYXNzZWQgYGZuYCBjYW4gYmUgdW5kZWZpbmVkIHRvIHN1cHBvcnQgZnVuY3Rpb25zIHRoYXQgbWF5IGNvbmRpdGlvbmFsbHlcbiAqIGJlIGRlZmluZWQuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5jb25zdCBydW5Bc1Byb21pc2UgPSAoZm5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4pID0+IHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmbik7XG59O1xuZXhwb3J0cy5ydW5Bc1Byb21pc2UgPSBydW5Bc1Byb21pc2U7XG4vKipcbiAqIFJldHVybnMgYSBQcm9taXNlIHRoYXQgcmVzb2x2ZSBhZnRlciB0aGUgY3VycmVudCBldmVudCBsb29wIHRpY2suXG4gKi9cbmNvbnN0IHJlc29sdmVOZXh0VGljayA9ICgpID0+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSkpO1xufTtcbmV4cG9ydHMucmVzb2x2ZU5leHRUaWNrID0gcmVzb2x2ZU5leHRUaWNrO1xuY29uc3QgcmV0cnlXaXRoQmFja29mZiA9IGFzeW5jIChmbiwgb3B0cykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBtYXhBdHRlbXB0cyA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdHMubWF4QXR0ZW1wdHMpIHx8IDU7XG4gICAgY29uc3QgYmFzZURlbGF5ID0gKF9hID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmJhc2VEZWxheSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTAwO1xuICAgIGZvciAobGV0IGF0dGVtcHQgPSAxOyBhdHRlbXB0IDw9IG1heEF0dGVtcHRzOyBhdHRlbXB0KyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBmbigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChhdHRlbXB0ID49IG1heEF0dGVtcHRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgaml0dGVyID0gTWF0aC5yYW5kb20oKSAqIGJhc2VEZWxheTtcbiAgICAgICAgICAgIGNvbnN0IGRlbGF5ID0gYmFzZURlbGF5ICogTWF0aC5wb3coMiwgYXR0ZW1wdCAtIDEpICsgaml0dGVyO1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgZGVsYXkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXggcmV0cmllcyByZWFjaGVkOyB0aGlzIHNob3VsZCBiZSB1bnJlYWNoYWJsZS5cIik7XG59O1xuZXhwb3J0cy5yZXRyeVdpdGhCYWNrb2ZmID0gcmV0cnlXaXRoQmFja29mZjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb21pc2VzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/promises.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/stream.js":
/*!************************************************!*\
  !*** ./node_modules/inngest/helpers/stream.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createStream = void 0;\nconst strings_js_1 = __webpack_require__(/*! ./strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\n/**\n * Creates a {@link ReadableStream} that sends a `value` every `interval`\n * milliseconds as a heartbeat, intended to keep a stream open.\n *\n * Returns the `stream` itself and a `finalize` function that can be used to\n * close the stream and send a final value.\n */\nconst createStream = (opts) => {\n    var _a, _b;\n    /**\n     * We need to resolve this promise with both the stream and the `finalize`\n     * function, but having them both instantiated synchronously is difficult, as\n     * we need access to the stream's internals too.\n     *\n     * We create this cheeky deferred promise to grab the internal `finalize`\n     * value. Be warned that simpler solutions may appear to compile, but fail at\n     * runtime due to variables not being assigned; make sure to test your code!\n     */\n    let passFinalize;\n    const finalizeP = new Promise((resolve) => {\n        passFinalize = resolve;\n    });\n    const interval = (_a = opts === null || opts === void 0 ? void 0 : opts.interval) !== null && _a !== void 0 ? _a : 3000;\n    const value = (_b = opts === null || opts === void 0 ? void 0 : opts.value) !== null && _b !== void 0 ? _b : \" \";\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n        try {\n            const stream = new ReadableStream({\n                start(controller) {\n                    const encoder = new TextEncoder();\n                    const heartbeat = setInterval(() => {\n                        controller.enqueue(encoder.encode(value));\n                    }, interval);\n                    const finalize = (data) => {\n                        clearInterval(heartbeat);\n                        // `data` may be a `Promise`. If it is, we need to wait for it to\n                        // resolve before sending it. To support this elegantly we'll always\n                        // assume it's a promise and handle that case.\n                        void Promise.resolve(data).then((resolvedData) => {\n                            controller.enqueue(encoder.encode((0, strings_js_1.stringify)(resolvedData)));\n                            controller.close();\n                        });\n                    };\n                    passFinalize(finalize);\n                },\n            });\n            resolve({ stream, finalize: await finalizeP });\n        }\n        catch (err) {\n            reject(err);\n        }\n    });\n};\nexports.createStream = createStream;\n//# sourceMappingURL=stream.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0I7QUFDcEIscUJBQXFCLG1CQUFPLENBQUMscUVBQWM7QUFDM0M7QUFDQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2Isc0JBQXNCLG1DQUFtQztBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBzdHJpbmdzX2pzXzEgPSByZXF1aXJlKFwiLi9zdHJpbmdzLmpzXCIpO1xuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFJlYWRhYmxlU3RyZWFtfSB0aGF0IHNlbmRzIGEgYHZhbHVlYCBldmVyeSBgaW50ZXJ2YWxgXG4gKiBtaWxsaXNlY29uZHMgYXMgYSBoZWFydGJlYXQsIGludGVuZGVkIHRvIGtlZXAgYSBzdHJlYW0gb3Blbi5cbiAqXG4gKiBSZXR1cm5zIHRoZSBgc3RyZWFtYCBpdHNlbGYgYW5kIGEgYGZpbmFsaXplYCBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvXG4gKiBjbG9zZSB0aGUgc3RyZWFtIGFuZCBzZW5kIGEgZmluYWwgdmFsdWUuXG4gKi9cbmNvbnN0IGNyZWF0ZVN0cmVhbSA9IChvcHRzKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAvKipcbiAgICAgKiBXZSBuZWVkIHRvIHJlc29sdmUgdGhpcyBwcm9taXNlIHdpdGggYm90aCB0aGUgc3RyZWFtIGFuZCB0aGUgYGZpbmFsaXplYFxuICAgICAqIGZ1bmN0aW9uLCBidXQgaGF2aW5nIHRoZW0gYm90aCBpbnN0YW50aWF0ZWQgc3luY2hyb25vdXNseSBpcyBkaWZmaWN1bHQsIGFzXG4gICAgICogd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIHN0cmVhbSdzIGludGVybmFscyB0b28uXG4gICAgICpcbiAgICAgKiBXZSBjcmVhdGUgdGhpcyBjaGVla3kgZGVmZXJyZWQgcHJvbWlzZSB0byBncmFiIHRoZSBpbnRlcm5hbCBgZmluYWxpemVgXG4gICAgICogdmFsdWUuIEJlIHdhcm5lZCB0aGF0IHNpbXBsZXIgc29sdXRpb25zIG1heSBhcHBlYXIgdG8gY29tcGlsZSwgYnV0IGZhaWwgYXRcbiAgICAgKiBydW50aW1lIGR1ZSB0byB2YXJpYWJsZXMgbm90IGJlaW5nIGFzc2lnbmVkOyBtYWtlIHN1cmUgdG8gdGVzdCB5b3VyIGNvZGUhXG4gICAgICovXG4gICAgbGV0IHBhc3NGaW5hbGl6ZTtcbiAgICBjb25zdCBmaW5hbGl6ZVAgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBwYXNzRmluYWxpemUgPSByZXNvbHZlO1xuICAgIH0pO1xuICAgIGNvbnN0IGludGVydmFsID0gKF9hID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLmludGVydmFsKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAzMDAwO1xuICAgIGNvbnN0IHZhbHVlID0gKF9iID0gb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIiBcIjtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW1pc3VzZWQtcHJvbWlzZXMsIG5vLWFzeW5jLXByb21pc2UtZXhlY3V0b3JcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgICAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGVhcnRiZWF0ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGVuY29kZXIuZW5jb2RlKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxpemUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChoZWFydGJlYXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYGRhdGFgIG1heSBiZSBhIGBQcm9taXNlYC4gSWYgaXQgaXMsIHdlIG5lZWQgdG8gd2FpdCBmb3IgaXQgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc29sdmUgYmVmb3JlIHNlbmRpbmcgaXQuIFRvIHN1cHBvcnQgdGhpcyBlbGVnYW50bHkgd2UnbGwgYWx3YXlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhc3N1bWUgaXQncyBhIHByb21pc2UgYW5kIGhhbmRsZSB0aGF0IGNhc2UuXG4gICAgICAgICAgICAgICAgICAgICAgICB2b2lkIFByb21pc2UucmVzb2x2ZShkYXRhKS50aGVuKChyZXNvbHZlZERhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZW5jb2Rlci5lbmNvZGUoKDAsIHN0cmluZ3NfanNfMS5zdHJpbmdpZnkpKHJlc29sdmVkRGF0YSkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcGFzc0ZpbmFsaXplKGZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNvbHZlKHsgc3RyZWFtLCBmaW5hbGl6ZTogYXdhaXQgZmluYWxpemVQIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0cy5jcmVhdGVTdHJlYW0gPSBjcmVhdGVTdHJlYW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJlYW0uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/strings.js":
/*!*************************************************!*\
  !*** ./node_modules/inngest/helpers/strings.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.hashSigningKey = exports.hashEventKey = exports.stringifyUnknown = exports.timeStr = exports.slugify = exports.stringify = void 0;\nconst hash_js_1 = __webpack_require__(/*! hash.js */ \"(rsc)/./node_modules/hash.js/lib/hash.js\");\nconst json_stringify_safe_1 = __importDefault(__webpack_require__(/*! json-stringify-safe */ \"(rsc)/./node_modules/json-stringify-safe/stringify.js\"));\nconst ms_1 = __importDefault(__webpack_require__(/*! ms */ \"(rsc)/./node_modules/ms/index.js\"));\n/**\n * Safely `JSON.stringify()` an `input`, handling circular refernences and\n * removing `BigInt` values.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst stringify = (input) => {\n    return (0, json_stringify_safe_1.default)(input, (key, value) => {\n        if (typeof value !== \"bigint\") {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            return value;\n        }\n    });\n};\nexports.stringify = stringify;\n/**\n * Returns a slugified string used to generate consistent IDs.\n *\n * This can be used to generate a consistent ID for a function when migrating\n * from v2 to v3 of the SDK.\n *\n * @public\n */\nconst slugify = (str) => {\n    const join = \"-\";\n    return str\n        .toLowerCase()\n        .replace(/[^a-z0-9-]+/g, join)\n        .replace(/-+/g, join)\n        .split(join)\n        .filter(Boolean)\n        .join(join);\n};\nexports.slugify = slugify;\nconst millisecond = 1;\nconst second = millisecond * 1000;\nconst minute = second * 60;\nconst hour = minute * 60;\nconst day = hour * 24;\nconst week = day * 7;\n/**\n * A collection of periods in milliseconds and their suffixes used when creating\n * time strings.\n */\nconst periods = [\n    [\"w\", week],\n    [\"d\", day],\n    [\"h\", hour],\n    [\"m\", minute],\n    [\"s\", second],\n];\n/**\n * Convert a given `Date`, `number`, or `ms`-compatible `string` to a\n * Inngest sleep-compatible time string (e.g. `\"1d\"` or `\"2h3010s\"`).\n *\n * Can optionally provide a `now` date to use as the base for the calculation,\n * otherwise a new date will be created on invocation.\n */\nconst timeStr = (\n/**\n * The future date to use to convert to a time string.\n */\ninput) => {\n    if (input instanceof Date) {\n        return input.toISOString();\n    }\n    const milliseconds = typeof input === \"string\" ? (0, ms_1.default)(input) : input;\n    const [, timeStr] = periods.reduce(([num, str], [suffix, period]) => {\n        const numPeriods = Math.floor(num / period);\n        if (numPeriods > 0) {\n            return [num % period, `${str}${numPeriods}${suffix}`];\n        }\n        return [num, str];\n    }, [milliseconds, \"\"]);\n    return timeStr;\n};\nexports.timeStr = timeStr;\n/**\n * Given an unknown input, stringify it if it's a boolean, a number, or a\n * string, else return `undefined`.\n */\nconst stringifyUnknown = (input) => {\n    if (typeof input === \"boolean\" ||\n        typeof input === \"number\" ||\n        typeof input === \"string\") {\n        return input.toString();\n    }\n};\nexports.stringifyUnknown = stringifyUnknown;\nconst hashEventKey = (eventKey) => {\n    return (0, hash_js_1.sha256)().update(eventKey).digest(\"hex\");\n};\nexports.hashEventKey = hashEventKey;\nconst hashSigningKey = (signingKey) => {\n    var _a;\n    if (!signingKey) {\n        return \"\";\n    }\n    const prefix = ((_a = signingKey.match(/^signkey-[\\w]+-/)) === null || _a === void 0 ? void 0 : _a.shift()) || \"\";\n    const key = signingKey.replace(/^signkey-[\\w]+-/, \"\");\n    // Decode the key from its hex representation into a bytestream\n    return `${prefix}${(0, hash_js_1.sha256)().update(key, \"hex\").digest(\"hex\")}`;\n};\nexports.hashSigningKey = hashSigningKey;\n//# sourceMappingURL=strings.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3N0cmluZ3MuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBLDZDQUE2QztBQUM3QztBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxzQkFBc0IsR0FBRyxvQkFBb0IsR0FBRyx3QkFBd0IsR0FBRyxlQUFlLEdBQUcsZUFBZSxHQUFHLGlCQUFpQjtBQUNoSSxrQkFBa0IsbUJBQU8sQ0FBQyx5REFBUztBQUNuQyw4Q0FBOEMsbUJBQU8sQ0FBQyxrRkFBcUI7QUFDM0UsNkJBQTZCLG1CQUFPLENBQUMsNENBQUk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLElBQUksRUFBRSxXQUFXLEVBQUUsT0FBTztBQUMvRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTyxFQUFFLHlEQUF5RDtBQUNoRjtBQUNBLHNCQUFzQjtBQUN0QiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvc3RyaW5ncy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzaFNpZ25pbmdLZXkgPSBleHBvcnRzLmhhc2hFdmVudEtleSA9IGV4cG9ydHMuc3RyaW5naWZ5VW5rbm93biA9IGV4cG9ydHMudGltZVN0ciA9IGV4cG9ydHMuc2x1Z2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gdm9pZCAwO1xuY29uc3QgaGFzaF9qc18xID0gcmVxdWlyZShcImhhc2guanNcIik7XG5jb25zdCBqc29uX3N0cmluZ2lmeV9zYWZlXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImpzb24tc3RyaW5naWZ5LXNhZmVcIikpO1xuY29uc3QgbXNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwibXNcIikpO1xuLyoqXG4gKiBTYWZlbHkgYEpTT04uc3RyaW5naWZ5KClgIGFuIGBpbnB1dGAsIGhhbmRsaW5nIGNpcmN1bGFyIHJlZmVybmVuY2VzIGFuZFxuICogcmVtb3ZpbmcgYEJpZ0ludGAgdmFsdWVzLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3Qgc3RyaW5naWZ5ID0gKGlucHV0KSA9PiB7XG4gICAgcmV0dXJuICgwLCBqc29uX3N0cmluZ2lmeV9zYWZlXzEuZGVmYXVsdCkoaW5wdXQsIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVyblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBzdHJpbmdpZnk7XG4vKipcbiAqIFJldHVybnMgYSBzbHVnaWZpZWQgc3RyaW5nIHVzZWQgdG8gZ2VuZXJhdGUgY29uc2lzdGVudCBJRHMuXG4gKlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBnZW5lcmF0ZSBhIGNvbnNpc3RlbnQgSUQgZm9yIGEgZnVuY3Rpb24gd2hlbiBtaWdyYXRpbmdcbiAqIGZyb20gdjIgdG8gdjMgb2YgdGhlIFNESy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHNsdWdpZnkgPSAoc3RyKSA9PiB7XG4gICAgY29uc3Qgam9pbiA9IFwiLVwiO1xuICAgIHJldHVybiBzdHJcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnJlcGxhY2UoL1teYS16MC05LV0rL2csIGpvaW4pXG4gICAgICAgIC5yZXBsYWNlKC8tKy9nLCBqb2luKVxuICAgICAgICAuc3BsaXQoam9pbilcbiAgICAgICAgLmZpbHRlcihCb29sZWFuKVxuICAgICAgICAuam9pbihqb2luKTtcbn07XG5leHBvcnRzLnNsdWdpZnkgPSBzbHVnaWZ5O1xuY29uc3QgbWlsbGlzZWNvbmQgPSAxO1xuY29uc3Qgc2Vjb25kID0gbWlsbGlzZWNvbmQgKiAxMDAwO1xuY29uc3QgbWludXRlID0gc2Vjb25kICogNjA7XG5jb25zdCBob3VyID0gbWludXRlICogNjA7XG5jb25zdCBkYXkgPSBob3VyICogMjQ7XG5jb25zdCB3ZWVrID0gZGF5ICogNztcbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHBlcmlvZHMgaW4gbWlsbGlzZWNvbmRzIGFuZCB0aGVpciBzdWZmaXhlcyB1c2VkIHdoZW4gY3JlYXRpbmdcbiAqIHRpbWUgc3RyaW5ncy5cbiAqL1xuY29uc3QgcGVyaW9kcyA9IFtcbiAgICBbXCJ3XCIsIHdlZWtdLFxuICAgIFtcImRcIiwgZGF5XSxcbiAgICBbXCJoXCIsIGhvdXJdLFxuICAgIFtcIm1cIiwgbWludXRlXSxcbiAgICBbXCJzXCIsIHNlY29uZF0sXG5dO1xuLyoqXG4gKiBDb252ZXJ0IGEgZ2l2ZW4gYERhdGVgLCBgbnVtYmVyYCwgb3IgYG1zYC1jb21wYXRpYmxlIGBzdHJpbmdgIHRvIGFcbiAqIElubmdlc3Qgc2xlZXAtY29tcGF0aWJsZSB0aW1lIHN0cmluZyAoZS5nLiBgXCIxZFwiYCBvciBgXCIyaDMwMTBzXCJgKS5cbiAqXG4gKiBDYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgYG5vd2AgZGF0ZSB0byB1c2UgYXMgdGhlIGJhc2UgZm9yIHRoZSBjYWxjdWxhdGlvbixcbiAqIG90aGVyd2lzZSBhIG5ldyBkYXRlIHdpbGwgYmUgY3JlYXRlZCBvbiBpbnZvY2F0aW9uLlxuICovXG5jb25zdCB0aW1lU3RyID0gKFxuLyoqXG4gKiBUaGUgZnV0dXJlIGRhdGUgdG8gdXNlIHRvIGNvbnZlcnQgdG8gYSB0aW1lIHN0cmluZy5cbiAqL1xuaW5wdXQpID0+IHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBjb25zdCBtaWxsaXNlY29uZHMgPSB0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIgPyAoMCwgbXNfMS5kZWZhdWx0KShpbnB1dCkgOiBpbnB1dDtcbiAgICBjb25zdCBbLCB0aW1lU3RyXSA9IHBlcmlvZHMucmVkdWNlKChbbnVtLCBzdHJdLCBbc3VmZml4LCBwZXJpb2RdKSA9PiB7XG4gICAgICAgIGNvbnN0IG51bVBlcmlvZHMgPSBNYXRoLmZsb29yKG51bSAvIHBlcmlvZCk7XG4gICAgICAgIGlmIChudW1QZXJpb2RzID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtudW0gJSBwZXJpb2QsIGAke3N0cn0ke251bVBlcmlvZHN9JHtzdWZmaXh9YF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtudW0sIHN0cl07XG4gICAgfSwgW21pbGxpc2Vjb25kcywgXCJcIl0pO1xuICAgIHJldHVybiB0aW1lU3RyO1xufTtcbmV4cG9ydHMudGltZVN0ciA9IHRpbWVTdHI7XG4vKipcbiAqIEdpdmVuIGFuIHVua25vd24gaW5wdXQsIHN0cmluZ2lmeSBpdCBpZiBpdCdzIGEgYm9vbGVhbiwgYSBudW1iZXIsIG9yIGFcbiAqIHN0cmluZywgZWxzZSByZXR1cm4gYHVuZGVmaW5lZGAuXG4gKi9cbmNvbnN0IHN0cmluZ2lmeVVua25vd24gPSAoaW5wdXQpID0+IHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcImJvb2xlYW5cIiB8fFxuICAgICAgICB0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCIgfHxcbiAgICAgICAgdHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC50b1N0cmluZygpO1xuICAgIH1cbn07XG5leHBvcnRzLnN0cmluZ2lmeVVua25vd24gPSBzdHJpbmdpZnlVbmtub3duO1xuY29uc3QgaGFzaEV2ZW50S2V5ID0gKGV2ZW50S2V5KSA9PiB7XG4gICAgcmV0dXJuICgwLCBoYXNoX2pzXzEuc2hhMjU2KSgpLnVwZGF0ZShldmVudEtleSkuZGlnZXN0KFwiaGV4XCIpO1xufTtcbmV4cG9ydHMuaGFzaEV2ZW50S2V5ID0gaGFzaEV2ZW50S2V5O1xuY29uc3QgaGFzaFNpZ25pbmdLZXkgPSAoc2lnbmluZ0tleSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoIXNpZ25pbmdLZXkpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9ICgoX2EgPSBzaWduaW5nS2V5Lm1hdGNoKC9ec2lnbmtleS1bXFx3XSstLykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaGlmdCgpKSB8fCBcIlwiO1xuICAgIGNvbnN0IGtleSA9IHNpZ25pbmdLZXkucmVwbGFjZSgvXnNpZ25rZXktW1xcd10rLS8sIFwiXCIpO1xuICAgIC8vIERlY29kZSB0aGUga2V5IGZyb20gaXRzIGhleCByZXByZXNlbnRhdGlvbiBpbnRvIGEgYnl0ZXN0cmVhbVxuICAgIHJldHVybiBgJHtwcmVmaXh9JHsoMCwgaGFzaF9qc18xLnNoYTI1NikoKS51cGRhdGUoa2V5LCBcImhleFwiKS5kaWdlc3QoXCJoZXhcIil9YDtcbn07XG5leHBvcnRzLmhhc2hTaWduaW5nS2V5ID0gaGFzaFNpZ25pbmdLZXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHJpbmdzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/strings.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/helpers/temporal.js":
/*!**************************************************!*\
  !*** ./node_modules/inngest/helpers/temporal.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getISOString = exports.isTemporalZonedDateTime = exports.isTemporalInstant = exports.isTemporalDuration = void 0;\n/**\n * Asserts that the given `input` is a `Temporal.Duration` object.\n */\nconst isTemporalDuration = (\n/**\n * The input to check.\n */\ninput) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        return input[Symbol.toStringTag] === \"Temporal.Duration\";\n    }\n    catch (_a) {\n        return false;\n    }\n};\nexports.isTemporalDuration = isTemporalDuration;\n/**\n * Asserts that the given `input` is a `Temporal.TimeZone` object.\n */\nconst isTemporalInstant = (\n/**\n * The input to check.\n */\ninput) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        return input[Symbol.toStringTag] === \"Temporal.Instant\";\n    }\n    catch (_a) {\n        return false;\n    }\n};\nexports.isTemporalInstant = isTemporalInstant;\n/**\n * Asserts that the given `input` is a `Temporal.ZonedDateTime` object.\n */\nconst isTemporalZonedDateTime = (\n/**\n * The input to check.\n */\ninput) => {\n    try {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n        return input[Symbol.toStringTag] === \"Temporal.ZonedDateTime\";\n    }\n    catch (_a) {\n        return false;\n    }\n};\nexports.isTemporalZonedDateTime = isTemporalZonedDateTime;\n/**\n * Converts a given `Date`, `string`, `Temporal.Instant`, or\n * `Temporal.ZonedDateTime` to an ISO 8601 string.\n */\nconst getISOString = (time) => {\n    if (typeof time === \"string\") {\n        return new Date(time).toISOString();\n    }\n    if (time instanceof Date) {\n        return time.toISOString();\n    }\n    if ((0, exports.isTemporalZonedDateTime)(time)) {\n        return time.toInstant().toString();\n    }\n    if ((0, exports.isTemporalInstant)(time)) {\n        return time.toString();\n    }\n    throw new TypeError(\"Invalid date input\");\n};\nexports.getISOString = getISOString;\n//# sourceMappingURL=temporal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9oZWxwZXJzL3RlbXBvcmFsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQixHQUFHLCtCQUErQixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQjtBQUMvRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L2hlbHBlcnMvdGVtcG9yYWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldElTT1N0cmluZyA9IGV4cG9ydHMuaXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUgPSBleHBvcnRzLmlzVGVtcG9yYWxJbnN0YW50ID0gZXhwb3J0cy5pc1RlbXBvcmFsRHVyYXRpb24gPSB2b2lkIDA7XG4vKipcbiAqIEFzc2VydHMgdGhhdCB0aGUgZ2l2ZW4gYGlucHV0YCBpcyBhIGBUZW1wb3JhbC5EdXJhdGlvbmAgb2JqZWN0LlxuICovXG5jb25zdCBpc1RlbXBvcmFsRHVyYXRpb24gPSAoXG4vKipcbiAqIFRoZSBpbnB1dCB0byBjaGVjay5cbiAqL1xuaW5wdXQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIHJldHVybiBpbnB1dFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIlRlbXBvcmFsLkR1cmF0aW9uXCI7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufTtcbmV4cG9ydHMuaXNUZW1wb3JhbER1cmF0aW9uID0gaXNUZW1wb3JhbER1cmF0aW9uO1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGBpbnB1dGAgaXMgYSBgVGVtcG9yYWwuVGltZVpvbmVgIG9iamVjdC5cbiAqL1xuY29uc3QgaXNUZW1wb3JhbEluc3RhbnQgPSAoXG4vKipcbiAqIFRoZSBpbnB1dCB0byBjaGVjay5cbiAqL1xuaW5wdXQpID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzXG4gICAgICAgIHJldHVybiBpbnB1dFtTeW1ib2wudG9TdHJpbmdUYWddID09PSBcIlRlbXBvcmFsLkluc3RhbnRcIjtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuZXhwb3J0cy5pc1RlbXBvcmFsSW5zdGFudCA9IGlzVGVtcG9yYWxJbnN0YW50O1xuLyoqXG4gKiBBc3NlcnRzIHRoYXQgdGhlIGdpdmVuIGBpbnB1dGAgaXMgYSBgVGVtcG9yYWwuWm9uZWREYXRlVGltZWAgb2JqZWN0LlxuICovXG5jb25zdCBpc1RlbXBvcmFsWm9uZWREYXRlVGltZSA9IChcbi8qKlxuICogVGhlIGlucHV0IHRvIGNoZWNrLlxuICovXG5pbnB1dCkgPT4ge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55LCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgICAgICAgcmV0dXJuIGlucHV0W1N5bWJvbC50b1N0cmluZ1RhZ10gPT09IFwiVGVtcG9yYWwuWm9uZWREYXRlVGltZVwiO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5leHBvcnRzLmlzVGVtcG9yYWxab25lZERhdGVUaW1lID0gaXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWU7XG4vKipcbiAqIENvbnZlcnRzIGEgZ2l2ZW4gYERhdGVgLCBgc3RyaW5nYCwgYFRlbXBvcmFsLkluc3RhbnRgLCBvclxuICogYFRlbXBvcmFsLlpvbmVkRGF0ZVRpbWVgIHRvIGFuIElTTyA4NjAxIHN0cmluZy5cbiAqL1xuY29uc3QgZ2V0SVNPU3RyaW5nID0gKHRpbWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHRpbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRpbWUpLnRvSVNPU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh0aW1lIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gdGltZS50b0lTT1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoKDAsIGV4cG9ydHMuaXNUZW1wb3JhbFpvbmVkRGF0ZVRpbWUpKHRpbWUpKSB7XG4gICAgICAgIHJldHVybiB0aW1lLnRvSW5zdGFudCgpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICgoMCwgZXhwb3J0cy5pc1RlbXBvcmFsSW5zdGFudCkodGltZSkpIHtcbiAgICAgICAgcmV0dXJuIHRpbWUudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgZGF0ZSBpbnB1dFwiKTtcbn07XG5leHBvcnRzLmdldElTT1N0cmluZyA9IGdldElTT1N0cmluZztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRlbXBvcmFsLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/helpers/temporal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/index.js":
/*!***************************************!*\
  !*** ./node_modules/inngest/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n/**\n * The primary entrypoint for the Inngest SDK. This provides all the necessary\n * exports to create, run, and trigger Inngest functions.\n *\n * Typical usage involves creating a new Inngest client with `Inngest`, and then\n * using the client to create functions, middleware, and other tools.\n *\n * See {@link https://www.inngest.com/docs} for more information.\n *\n * @example Create an Inngest client\n * ```ts\n * const inngest = new Inngest({\n *   id: \"my-app-id\",\n * });\n * ```\n *\n * @example Create an Inngest function\n * ```ts\n * const myFn = inngest.createFunction({\n *  id: \"my-function\",\n * }, {\n *   event: \"user/created\",\n * }, async ({ event, step }) => {\n *   console.log(\"User created:\", event.data);\n * });\n * ```\n *\n * @example Send an event\n * ```ts\n * await inngest.send({\n *   name: \"user/created\",\n *   data: {\n *     id: \"123\",\n *   },\n * });\n * ```\n *\n * @module\n */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = exports.ProxyLogger = exports.dependencyInjectionMiddleware = exports.slugify = exports.queryKeys = exports.internalEvents = exports.headerKeys = exports.StepError = exports.RetryAfterError = exports.NonRetriableError = exports.InngestMiddleware = exports.referenceFunction = exports.InngestCommHandler = exports.Inngest = exports.EventSchemas = void 0;\n__exportStar(__webpack_require__(/*! @inngest/ai */ \"(rsc)/./node_modules/@inngest/ai/dist/index.js\"), exports);\nvar EventSchemas_js_1 = __webpack_require__(/*! ./components/EventSchemas.js */ \"(rsc)/./node_modules/inngest/components/EventSchemas.js\");\nObject.defineProperty(exports, \"EventSchemas\", ({ enumerable: true, get: function () { return EventSchemas_js_1.EventSchemas; } }));\nvar Fetch_js_1 = __webpack_require__(/*! ./components/Fetch.js */ \"(rsc)/./node_modules/inngest/components/Fetch.js\");\nObject.defineProperty(exports, \"fetch\", ({ enumerable: true, get: function () { return Fetch_js_1.fetch; } }));\nvar Inngest_js_1 = __webpack_require__(/*! ./components/Inngest.js */ \"(rsc)/./node_modules/inngest/components/Inngest.js\");\nObject.defineProperty(exports, \"Inngest\", ({ enumerable: true, get: function () { return Inngest_js_1.Inngest; } }));\nvar InngestCommHandler_js_1 = __webpack_require__(/*! ./components/InngestCommHandler.js */ \"(rsc)/./node_modules/inngest/components/InngestCommHandler.js\");\nObject.defineProperty(exports, \"InngestCommHandler\", ({ enumerable: true, get: function () { return InngestCommHandler_js_1.InngestCommHandler; } }));\nvar InngestFunctionReference_js_1 = __webpack_require__(/*! ./components/InngestFunctionReference.js */ \"(rsc)/./node_modules/inngest/components/InngestFunctionReference.js\");\nObject.defineProperty(exports, \"referenceFunction\", ({ enumerable: true, get: function () { return InngestFunctionReference_js_1.referenceFunction; } }));\nvar InngestMiddleware_js_1 = __webpack_require__(/*! ./components/InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\nObject.defineProperty(exports, \"InngestMiddleware\", ({ enumerable: true, get: function () { return InngestMiddleware_js_1.InngestMiddleware; } }));\nvar NonRetriableError_js_1 = __webpack_require__(/*! ./components/NonRetriableError.js */ \"(rsc)/./node_modules/inngest/components/NonRetriableError.js\");\nObject.defineProperty(exports, \"NonRetriableError\", ({ enumerable: true, get: function () { return NonRetriableError_js_1.NonRetriableError; } }));\nvar RetryAfterError_js_1 = __webpack_require__(/*! ./components/RetryAfterError.js */ \"(rsc)/./node_modules/inngest/components/RetryAfterError.js\");\nObject.defineProperty(exports, \"RetryAfterError\", ({ enumerable: true, get: function () { return RetryAfterError_js_1.RetryAfterError; } }));\nvar StepError_js_1 = __webpack_require__(/*! ./components/StepError.js */ \"(rsc)/./node_modules/inngest/components/StepError.js\");\nObject.defineProperty(exports, \"StepError\", ({ enumerable: true, get: function () { return StepError_js_1.StepError; } }));\nvar consts_js_1 = __webpack_require__(/*! ./helpers/consts.js */ \"(rsc)/./node_modules/inngest/helpers/consts.js\");\nObject.defineProperty(exports, \"headerKeys\", ({ enumerable: true, get: function () { return consts_js_1.headerKeys; } }));\nObject.defineProperty(exports, \"internalEvents\", ({ enumerable: true, get: function () { return consts_js_1.internalEvents; } }));\nObject.defineProperty(exports, \"queryKeys\", ({ enumerable: true, get: function () { return consts_js_1.queryKeys; } }));\nvar strings_js_1 = __webpack_require__(/*! ./helpers/strings.js */ \"(rsc)/./node_modules/inngest/helpers/strings.js\");\nObject.defineProperty(exports, \"slugify\", ({ enumerable: true, get: function () { return strings_js_1.slugify; } }));\nvar dependencyInjection_js_1 = __webpack_require__(/*! ./middleware/dependencyInjection.js */ \"(rsc)/./node_modules/inngest/middleware/dependencyInjection.js\");\nObject.defineProperty(exports, \"dependencyInjectionMiddleware\", ({ enumerable: true, get: function () { return dependencyInjection_js_1.dependencyInjectionMiddleware; } }));\nvar logger_js_1 = __webpack_require__(/*! ./middleware/logger.js */ \"(rsc)/./node_modules/inngest/middleware/logger.js\");\nObject.defineProperty(exports, \"ProxyLogger\", ({ enumerable: true, get: function () { return logger_js_1.ProxyLogger; } }));\nvar version_js_1 = __webpack_require__(/*! ./version.js */ \"(rsc)/./node_modules/inngest/version.js\");\nObject.defineProperty(exports, \"version\", ({ enumerable: true, get: function () { return version_js_1.version; } }));\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJLFdBQVcsYUFBYTtBQUM1QjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLEdBQUcsbUJBQW1CLEdBQUcscUNBQXFDLEdBQUcsZUFBZSxHQUFHLGlCQUFpQixHQUFHLHNCQUFzQixHQUFHLGtCQUFrQixHQUFHLGlCQUFpQixHQUFHLHVCQUF1QixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLDBCQUEwQixHQUFHLGVBQWUsR0FBRyxvQkFBb0I7QUFDelcsYUFBYSxtQkFBTyxDQUFDLG1FQUFhO0FBQ2xDLHdCQUF3QixtQkFBTyxDQUFDLDZGQUE4QjtBQUM5RCxnREFBK0MsRUFBRSxxQ0FBcUMsMENBQTBDLEVBQUM7QUFDakksaUJBQWlCLG1CQUFPLENBQUMsK0VBQXVCO0FBQ2hELHlDQUF3QyxFQUFFLHFDQUFxQyw0QkFBNEIsRUFBQztBQUM1RyxtQkFBbUIsbUJBQU8sQ0FBQyxtRkFBeUI7QUFDcEQsMkNBQTBDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2xILDhCQUE4QixtQkFBTyxDQUFDLHlHQUFvQztBQUMxRSxzREFBcUQsRUFBRSxxQ0FBcUMsc0RBQXNELEVBQUM7QUFDbkosb0NBQW9DLG1CQUFPLENBQUMscUhBQTBDO0FBQ3RGLHFEQUFvRCxFQUFFLHFDQUFxQywyREFBMkQsRUFBQztBQUN2Siw2QkFBNkIsbUJBQU8sQ0FBQyx1R0FBbUM7QUFDeEUscURBQW9ELEVBQUUscUNBQXFDLG9EQUFvRCxFQUFDO0FBQ2hKLDZCQUE2QixtQkFBTyxDQUFDLHVHQUFtQztBQUN4RSxxREFBb0QsRUFBRSxxQ0FBcUMsb0RBQW9ELEVBQUM7QUFDaEosMkJBQTJCLG1CQUFPLENBQUMsbUdBQWlDO0FBQ3BFLG1EQUFrRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUMxSSxxQkFBcUIsbUJBQU8sQ0FBQyx1RkFBMkI7QUFDeEQsNkNBQTRDLEVBQUUscUNBQXFDLG9DQUFvQyxFQUFDO0FBQ3hILGtCQUFrQixtQkFBTyxDQUFDLDJFQUFxQjtBQUMvQyw4Q0FBNkMsRUFBRSxxQ0FBcUMsa0NBQWtDLEVBQUM7QUFDdkgsa0RBQWlELEVBQUUscUNBQXFDLHNDQUFzQyxFQUFDO0FBQy9ILDZDQUE0QyxFQUFFLHFDQUFxQyxpQ0FBaUMsRUFBQztBQUNySCxtQkFBbUIsbUJBQU8sQ0FBQyw2RUFBc0I7QUFDakQsMkNBQTBDLEVBQUUscUNBQXFDLGdDQUFnQyxFQUFDO0FBQ2xILCtCQUErQixtQkFBTyxDQUFDLDJHQUFxQztBQUM1RSxpRUFBZ0UsRUFBRSxxQ0FBcUMsa0VBQWtFLEVBQUM7QUFDMUssa0JBQWtCLG1CQUFPLENBQUMsaUZBQXdCO0FBQ2xELCtDQUE4QyxFQUFFLHFDQUFxQyxtQ0FBbUMsRUFBQztBQUN6SCxtQkFBbUIsbUJBQU8sQ0FBQyw2REFBYztBQUN6QywyQ0FBMEMsRUFBRSxxQ0FBcUMsZ0NBQWdDLEVBQUM7QUFDbEgiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbi8qKlxuICogVGhlIHByaW1hcnkgZW50cnlwb2ludCBmb3IgdGhlIElubmdlc3QgU0RLLiBUaGlzIHByb3ZpZGVzIGFsbCB0aGUgbmVjZXNzYXJ5XG4gKiBleHBvcnRzIHRvIGNyZWF0ZSwgcnVuLCBhbmQgdHJpZ2dlciBJbm5nZXN0IGZ1bmN0aW9ucy5cbiAqXG4gKiBUeXBpY2FsIHVzYWdlIGludm9sdmVzIGNyZWF0aW5nIGEgbmV3IElubmdlc3QgY2xpZW50IHdpdGggYElubmdlc3RgLCBhbmQgdGhlblxuICogdXNpbmcgdGhlIGNsaWVudCB0byBjcmVhdGUgZnVuY3Rpb25zLCBtaWRkbGV3YXJlLCBhbmQgb3RoZXIgdG9vbHMuXG4gKlxuICogU2VlIHtAbGluayBodHRwczovL3d3dy5pbm5nZXN0LmNvbS9kb2NzfSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZXhhbXBsZSBDcmVhdGUgYW4gSW5uZ2VzdCBjbGllbnRcbiAqIGBgYHRzXG4gKiBjb25zdCBpbm5nZXN0ID0gbmV3IElubmdlc3Qoe1xuICogICBpZDogXCJteS1hcHAtaWRcIixcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGUgQ3JlYXRlIGFuIElubmdlc3QgZnVuY3Rpb25cbiAqIGBgYHRzXG4gKiBjb25zdCBteUZuID0gaW5uZ2VzdC5jcmVhdGVGdW5jdGlvbih7XG4gKiAgaWQ6IFwibXktZnVuY3Rpb25cIixcbiAqIH0sIHtcbiAqICAgZXZlbnQ6IFwidXNlci9jcmVhdGVkXCIsXG4gKiB9LCBhc3luYyAoeyBldmVudCwgc3RlcCB9KSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKFwiVXNlciBjcmVhdGVkOlwiLCBldmVudC5kYXRhKTtcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGUgU2VuZCBhbiBldmVudFxuICogYGBgdHNcbiAqIGF3YWl0IGlubmdlc3Quc2VuZCh7XG4gKiAgIG5hbWU6IFwidXNlci9jcmVhdGVkXCIsXG4gKiAgIGRhdGE6IHtcbiAqICAgICBpZDogXCIxMjNcIixcbiAqICAgfSxcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQG1vZHVsZVxuICovXG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChleHBvcnRzLCBwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudmVyc2lvbiA9IGV4cG9ydHMuUHJveHlMb2dnZXIgPSBleHBvcnRzLmRlcGVuZGVuY3lJbmplY3Rpb25NaWRkbGV3YXJlID0gZXhwb3J0cy5zbHVnaWZ5ID0gZXhwb3J0cy5xdWVyeUtleXMgPSBleHBvcnRzLmludGVybmFsRXZlbnRzID0gZXhwb3J0cy5oZWFkZXJLZXlzID0gZXhwb3J0cy5TdGVwRXJyb3IgPSBleHBvcnRzLlJldHJ5QWZ0ZXJFcnJvciA9IGV4cG9ydHMuTm9uUmV0cmlhYmxlRXJyb3IgPSBleHBvcnRzLklubmdlc3RNaWRkbGV3YXJlID0gZXhwb3J0cy5yZWZlcmVuY2VGdW5jdGlvbiA9IGV4cG9ydHMuSW5uZ2VzdENvbW1IYW5kbGVyID0gZXhwb3J0cy5Jbm5nZXN0ID0gZXhwb3J0cy5FdmVudFNjaGVtYXMgPSB2b2lkIDA7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIkBpbm5nZXN0L2FpXCIpLCBleHBvcnRzKTtcbnZhciBFdmVudFNjaGVtYXNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvRXZlbnRTY2hlbWFzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiRXZlbnRTY2hlbWFzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBFdmVudFNjaGVtYXNfanNfMS5FdmVudFNjaGVtYXM7IH0gfSk7XG52YXIgRmV0Y2hfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvRmV0Y2guanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJmZXRjaFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRmV0Y2hfanNfMS5mZXRjaDsgfSB9KTtcbnZhciBJbm5nZXN0X2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL0lubmdlc3QuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbm5nZXN0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBJbm5nZXN0X2pzXzEuSW5uZ2VzdDsgfSB9KTtcbnZhciBJbm5nZXN0Q29tbUhhbmRsZXJfanNfMSA9IHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvSW5uZ2VzdENvbW1IYW5kbGVyLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiSW5uZ2VzdENvbW1IYW5kbGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBJbm5nZXN0Q29tbUhhbmRsZXJfanNfMS5Jbm5nZXN0Q29tbUhhbmRsZXI7IH0gfSk7XG52YXIgSW5uZ2VzdEZ1bmN0aW9uUmVmZXJlbmNlX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL0lubmdlc3RGdW5jdGlvblJlZmVyZW5jZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlZmVyZW5jZUZ1bmN0aW9uXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBJbm5nZXN0RnVuY3Rpb25SZWZlcmVuY2VfanNfMS5yZWZlcmVuY2VGdW5jdGlvbjsgfSB9KTtcbnZhciBJbm5nZXN0TWlkZGxld2FyZV9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9Jbm5nZXN0TWlkZGxld2FyZS5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIklubmdlc3RNaWRkbGV3YXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBJbm5nZXN0TWlkZGxld2FyZV9qc18xLklubmdlc3RNaWRkbGV3YXJlOyB9IH0pO1xudmFyIE5vblJldHJpYWJsZUVycm9yX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL05vblJldHJpYWJsZUVycm9yLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiTm9uUmV0cmlhYmxlRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIE5vblJldHJpYWJsZUVycm9yX2pzXzEuTm9uUmV0cmlhYmxlRXJyb3I7IH0gfSk7XG52YXIgUmV0cnlBZnRlckVycm9yX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL1JldHJ5QWZ0ZXJFcnJvci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlJldHJ5QWZ0ZXJFcnJvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUmV0cnlBZnRlckVycm9yX2pzXzEuUmV0cnlBZnRlckVycm9yOyB9IH0pO1xudmFyIFN0ZXBFcnJvcl9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9TdGVwRXJyb3IuanNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTdGVwRXJyb3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFN0ZXBFcnJvcl9qc18xLlN0ZXBFcnJvcjsgfSB9KTtcbnZhciBjb25zdHNfanNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvY29uc3RzLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaGVhZGVyS2V5c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RzX2pzXzEuaGVhZGVyS2V5czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludGVybmFsRXZlbnRzXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdHNfanNfMS5pbnRlcm5hbEV2ZW50czsgfSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInF1ZXJ5S2V5c1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RzX2pzXzEucXVlcnlLZXlzOyB9IH0pO1xudmFyIHN0cmluZ3NfanNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvc3RyaW5ncy5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInNsdWdpZnlcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN0cmluZ3NfanNfMS5zbHVnaWZ5OyB9IH0pO1xudmFyIGRlcGVuZGVuY3lJbmplY3Rpb25fanNfMSA9IHJlcXVpcmUoXCIuL21pZGRsZXdhcmUvZGVwZW5kZW5jeUluamVjdGlvbi5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlcGVuZGVuY3lJbmplY3Rpb25NaWRkbGV3YXJlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkZXBlbmRlbmN5SW5qZWN0aW9uX2pzXzEuZGVwZW5kZW5jeUluamVjdGlvbk1pZGRsZXdhcmU7IH0gfSk7XG52YXIgbG9nZ2VyX2pzXzEgPSByZXF1aXJlKFwiLi9taWRkbGV3YXJlL2xvZ2dlci5qc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb3h5TG9nZ2VyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBsb2dnZXJfanNfMS5Qcm94eUxvZ2dlcjsgfSB9KTtcbnZhciB2ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uLmpzXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwidmVyc2lvblwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmVyc2lvbl9qc18xLnZlcnNpb247IH0gfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/middleware/dependencyInjection.js":
/*!****************************************************************!*\
  !*** ./node_modules/inngest/middleware/dependencyInjection.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dependencyInjectionMiddleware = void 0;\nconst InngestMiddleware_js_1 = __webpack_require__(/*! ../components/InngestMiddleware.js */ \"(rsc)/./node_modules/inngest/components/InngestMiddleware.js\");\n/**\n * Adds properties to the function input for every function created using this\n * app.\n */\n// We can use `const` here yet due to TS constraints.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst dependencyInjectionMiddleware = (\n/**\n * The context to inject into the function input.\n */\nctx) => {\n    return new InngestMiddleware_js_1.InngestMiddleware({\n        name: \"Inngest: Dependency Injection\",\n        init() {\n            return {\n                onFunctionRun() {\n                    return {\n                        transformInput() {\n                            return {\n                                ctx,\n                            };\n                        },\n                    };\n                },\n            };\n        },\n    });\n};\nexports.dependencyInjectionMiddleware = dependencyInjectionMiddleware;\n//# sourceMappingURL=dependencyInjection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9taWRkbGV3YXJlL2RlcGVuZGVuY3lJbmplY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUNBQXFDO0FBQ3JDLCtCQUErQixtQkFBTyxDQUFDLHdHQUFvQztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EscUNBQXFDO0FBQ3JDIiwic291cmNlcyI6WyIvVXNlcnMvaGFyc2hzaHJpdmFzdGF2L0Rlc2t0b3AvQ29kaW5nIFByb2plY3RzL0pvYi1Bc3Npc3RhbnQtQWdlbnQvbm9kZV9tb2R1bGVzL2lubmdlc3QvbWlkZGxld2FyZS9kZXBlbmRlbmN5SW5qZWN0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXBlbmRlbmN5SW5qZWN0aW9uTWlkZGxld2FyZSA9IHZvaWQgMDtcbmNvbnN0IElubmdlc3RNaWRkbGV3YXJlX2pzXzEgPSByZXF1aXJlKFwiLi4vY29tcG9uZW50cy9Jbm5nZXN0TWlkZGxld2FyZS5qc1wiKTtcbi8qKlxuICogQWRkcyBwcm9wZXJ0aWVzIHRvIHRoZSBmdW5jdGlvbiBpbnB1dCBmb3IgZXZlcnkgZnVuY3Rpb24gY3JlYXRlZCB1c2luZyB0aGlzXG4gKiBhcHAuXG4gKi9cbi8vIFdlIGNhbiB1c2UgYGNvbnN0YCBoZXJlIHlldCBkdWUgdG8gVFMgY29uc3RyYWludHMuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuY29uc3QgZGVwZW5kZW5jeUluamVjdGlvbk1pZGRsZXdhcmUgPSAoXG4vKipcbiAqIFRoZSBjb250ZXh0IHRvIGluamVjdCBpbnRvIHRoZSBmdW5jdGlvbiBpbnB1dC5cbiAqL1xuY3R4KSA9PiB7XG4gICAgcmV0dXJuIG5ldyBJbm5nZXN0TWlkZGxld2FyZV9qc18xLklubmdlc3RNaWRkbGV3YXJlKHtcbiAgICAgICAgbmFtZTogXCJJbm5nZXN0OiBEZXBlbmRlbmN5IEluamVjdGlvblwiLFxuICAgICAgICBpbml0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvbkZ1bmN0aW9uUnVuKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtSW5wdXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3R4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgIH0pO1xufTtcbmV4cG9ydHMuZGVwZW5kZW5jeUluamVjdGlvbk1pZGRsZXdhcmUgPSBkZXBlbmRlbmN5SW5qZWN0aW9uTWlkZGxld2FyZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcGVuZGVuY3lJbmplY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/middleware/dependencyInjection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/middleware/logger.js":
/*!***************************************************!*\
  !*** ./node_modules/inngest/middleware/logger.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProxyLogger = exports.DefaultLogger = void 0;\nclass DefaultLogger {\n    info(...args) {\n        console.info(...args);\n    }\n    warn(...args) {\n        console.warn(...args);\n    }\n    error(...args) {\n        console.error(...args);\n    }\n    debug(...args) {\n        console.debug(...args);\n    }\n}\nexports.DefaultLogger = DefaultLogger;\n/**\n * ProxyLogger aims to provide a thin wrapper on user's provided logger.\n * It's expected to be turned on and off based on the function execution\n * context, so it doesn't result in duplicated logging.\n *\n * And also attempt to allow enough time for the logger to flush all logs.\n *\n * @public\n */\nclass ProxyLogger {\n    constructor(logger) {\n        this.enabled = false;\n        this.logger = logger;\n        // Return a Proxy to forward arbitrary property access to the underlying\n        // logger. For example, if the user provides a logger that has a `foo`\n        // method, they can call `foo` on the ProxyLogger and it will call the\n        // underlying logger's `foo` method.\n        return new Proxy(this, {\n            get(target, prop, receiver) {\n                // Handle ProxyLogger's own methods/properties.\n                if (prop in target) {\n                    return Reflect.get(target, prop, receiver);\n                }\n                // Forward property access to the underlying logger.\n                return Reflect.get(target.logger, prop, receiver);\n            },\n        });\n    }\n    info(...args) {\n        if (!this.enabled)\n            return;\n        this.logger.info(...args);\n    }\n    warn(...args) {\n        if (!this.enabled)\n            return;\n        this.logger.warn(...args);\n    }\n    error(...args) {\n        if (!this.enabled)\n            return;\n        this.logger.error(...args);\n    }\n    debug(...args) {\n        // there are loggers that don't implement \"debug\" by default\n        if (!this.enabled || !(typeof this.logger.debug === \"function\"))\n            return;\n        this.logger.debug(...args);\n    }\n    enable() {\n        this.enabled = true;\n    }\n    disable() {\n        this.enabled = false;\n    }\n    async flush() {\n        // Allow 1s for the provided logger to handle flushing since the ones that do\n        // flushing usually has some kind of timeout of up to 1s.\n        //\n        // TODO:\n        // This should only happen when using a serverless environment because it's very\n        // costly from the compute perspective.\n        // server runtimes should just let the logger do their thing since most of them\n        // should have already figured what to do in those environments, be it threading or\n        // something else.\n        if (this.logger.constructor.name !== DefaultLogger.name) {\n            await new Promise((resolve) => {\n                setTimeout(() => resolve(null), 1000);\n            });\n        }\n    }\n}\nexports.ProxyLogger = ProxyLogger;\n//# sourceMappingURL=logger.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9taWRkbGV3YXJlL2xvZ2dlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyxxQkFBcUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9taWRkbGV3YXJlL2xvZ2dlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJveHlMb2dnZXIgPSBleHBvcnRzLkRlZmF1bHRMb2dnZXIgPSB2b2lkIDA7XG5jbGFzcyBEZWZhdWx0TG9nZ2VyIHtcbiAgICBpbmZvKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKC4uLmFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc29sZS53YXJuKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBlcnJvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoLi4uYXJncyk7XG4gICAgfVxuICAgIGRlYnVnKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc29sZS5kZWJ1ZyguLi5hcmdzKTtcbiAgICB9XG59XG5leHBvcnRzLkRlZmF1bHRMb2dnZXIgPSBEZWZhdWx0TG9nZ2VyO1xuLyoqXG4gKiBQcm94eUxvZ2dlciBhaW1zIHRvIHByb3ZpZGUgYSB0aGluIHdyYXBwZXIgb24gdXNlcidzIHByb3ZpZGVkIGxvZ2dlci5cbiAqIEl0J3MgZXhwZWN0ZWQgdG8gYmUgdHVybmVkIG9uIGFuZCBvZmYgYmFzZWQgb24gdGhlIGZ1bmN0aW9uIGV4ZWN1dGlvblxuICogY29udGV4dCwgc28gaXQgZG9lc24ndCByZXN1bHQgaW4gZHVwbGljYXRlZCBsb2dnaW5nLlxuICpcbiAqIEFuZCBhbHNvIGF0dGVtcHQgdG8gYWxsb3cgZW5vdWdoIHRpbWUgZm9yIHRoZSBsb2dnZXIgdG8gZmx1c2ggYWxsIGxvZ3MuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBQcm94eUxvZ2dlciB7XG4gICAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICAgICAgLy8gUmV0dXJuIGEgUHJveHkgdG8gZm9yd2FyZCBhcmJpdHJhcnkgcHJvcGVydHkgYWNjZXNzIHRvIHRoZSB1bmRlcmx5aW5nXG4gICAgICAgIC8vIGxvZ2dlci4gRm9yIGV4YW1wbGUsIGlmIHRoZSB1c2VyIHByb3ZpZGVzIGEgbG9nZ2VyIHRoYXQgaGFzIGEgYGZvb2BcbiAgICAgICAgLy8gbWV0aG9kLCB0aGV5IGNhbiBjYWxsIGBmb29gIG9uIHRoZSBQcm94eUxvZ2dlciBhbmQgaXQgd2lsbCBjYWxsIHRoZVxuICAgICAgICAvLyB1bmRlcmx5aW5nIGxvZ2dlcidzIGBmb29gIG1ldGhvZC5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eSh0aGlzLCB7XG4gICAgICAgICAgICBnZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBQcm94eUxvZ2dlcidzIG93biBtZXRob2RzL3Byb3BlcnRpZXMuXG4gICAgICAgICAgICAgICAgaWYgKHByb3AgaW4gdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRm9yd2FyZCBwcm9wZXJ0eSBhY2Nlc3MgdG8gdGhlIHVuZGVybHlpbmcgbG9nZ2VyLlxuICAgICAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQubG9nZ2VyLCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxvZ2dlci5pbmZvKC4uLmFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oLi4uYXJncyk7XG4gICAgfVxuICAgIGVycm9yKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKC4uLmFyZ3MpO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIC8vIHRoZXJlIGFyZSBsb2dnZXJzIHRoYXQgZG9uJ3QgaW1wbGVtZW50IFwiZGVidWdcIiBieSBkZWZhdWx0XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICEodHlwZW9mIHRoaXMubG9nZ2VyLmRlYnVnID09PSBcImZ1bmN0aW9uXCIpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmxvZ2dlci5kZWJ1ZyguLi5hcmdzKTtcbiAgICB9XG4gICAgZW5hYmxlKCkge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBkaXNhYmxlKCkge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIC8vIEFsbG93IDFzIGZvciB0aGUgcHJvdmlkZWQgbG9nZ2VyIHRvIGhhbmRsZSBmbHVzaGluZyBzaW5jZSB0aGUgb25lcyB0aGF0IGRvXG4gICAgICAgIC8vIGZsdXNoaW5nIHVzdWFsbHkgaGFzIHNvbWUga2luZCBvZiB0aW1lb3V0IG9mIHVwIHRvIDFzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUT0RPOlxuICAgICAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGhhcHBlbiB3aGVuIHVzaW5nIGEgc2VydmVybGVzcyBlbnZpcm9ubWVudCBiZWNhdXNlIGl0J3MgdmVyeVxuICAgICAgICAvLyBjb3N0bHkgZnJvbSB0aGUgY29tcHV0ZSBwZXJzcGVjdGl2ZS5cbiAgICAgICAgLy8gc2VydmVyIHJ1bnRpbWVzIHNob3VsZCBqdXN0IGxldCB0aGUgbG9nZ2VyIGRvIHRoZWlyIHRoaW5nIHNpbmNlIG1vc3Qgb2YgdGhlbVxuICAgICAgICAvLyBzaG91bGQgaGF2ZSBhbHJlYWR5IGZpZ3VyZWQgd2hhdCB0byBkbyBpbiB0aG9zZSBlbnZpcm9ubWVudHMsIGJlIGl0IHRocmVhZGluZyBvclxuICAgICAgICAvLyBzb21ldGhpbmcgZWxzZS5cbiAgICAgICAgaWYgKHRoaXMubG9nZ2VyLmNvbnN0cnVjdG9yLm5hbWUgIT09IERlZmF1bHRMb2dnZXIubmFtZSkge1xuICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHJlc29sdmUobnVsbCksIDEwMDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlByb3h5TG9nZ2VyID0gUHJveHlMb2dnZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2dnZXIuanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/middleware/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/next.js":
/*!**************************************!*\
  !*** ./node_modules/inngest/next.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * An adapter for Next.js to serve and register any declared functions with\n * Inngest, making them available to be triggered by events.\n *\n * Supports Next.js 12+, both serverless and edge.\n *\n * @example Next.js <=12 or the pages router can export the handler directly\n * ```ts\n * export default serve({ client: inngest, functions: [fn1, fn2] });\n * ```\n *\n * @example Next.js >=13 with the `app` dir must export individual methods\n * ```ts\n * export const { GET, POST, PUT } = serve({\n *            client: inngest,\n *            functions: [fn1, fn2],\n * });\n * ```\n *\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serve = exports.frameworkName = void 0;\nconst InngestCommHandler_js_1 = __webpack_require__(/*! ./components/InngestCommHandler.js */ \"(rsc)/./node_modules/inngest/components/InngestCommHandler.js\");\nconst env_js_1 = __webpack_require__(/*! ./helpers/env.js */ \"(rsc)/./node_modules/inngest/helpers/env.js\");\n/**\n * The name of the framework, used to identify the framework in Inngest\n * dashboards and during testing.\n */\nexports.frameworkName = \"nextjs\";\nconst isRecord = (val) => {\n    return typeof val === \"object\" && val !== null;\n};\nconst isFunction = (val) => {\n    return typeof val === \"function\";\n};\nconst isNext12ApiResponse = (val) => {\n    return (isRecord(val) &&\n        isFunction(val.setHeader) &&\n        isFunction(val.status) &&\n        isFunction(val.send));\n};\n/**\n * In Next.js, serve and register any declared functions with Inngest, making\n * them available to be triggered by events.\n *\n * Supports Next.js 12+, both serverless and edge.\n *\n * @example Next.js <=12 or the pages router can export the handler directly\n * ```ts\n * export default serve({ client: inngest, functions: [fn1, fn2] });\n * ```\n *\n * @example Next.js >=13 with the `app` dir must export individual methods\n * ```ts\n * export const { GET, POST, PUT } = serve({\n *            client: inngest,\n *            functions: [fn1, fn2],\n * });\n * ```\n *\n * @public\n */\n// Has explicit return type to avoid JSR-defined \"slow types\"\nconst serve = (options) => {\n    const handler = new InngestCommHandler_js_1.InngestCommHandler(Object.assign(Object.assign({ frameworkName: exports.frameworkName }, options), { handler: (reqMethod, ...args) => {\n            const [expectedReq, res] = args;\n            const req = expectedReq;\n            const getHeader = (key) => {\n                const header = typeof req.headers.get === \"function\"\n                    ? req.headers.get(key)\n                    : req.headers[key];\n                return Array.isArray(header) ? header[0] : header;\n            };\n            return {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n                body: () => (typeof req.json === \"function\" ? req.json() : req.body),\n                headers: getHeader,\n                method: () => {\n                    /**\n                     * `req.method`, though types say otherwise, is not available in Next.js\n                     * 13 {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}.\n                     *\n                     * Therefore, we must try to set the method ourselves where we know it.\n                     */\n                    const method = reqMethod || req.method || \"\";\n                    return method;\n                },\n                isProduction: () => {\n                    /**\n                     * Vercel Edge Functions do not allow dynamic access to environment\n                     * variables, so we'll manage production checks directly here.\n                     *\n                     * We try/catch to avoid situations where Next.js is being used in\n                     * environments where `process.env` is not accessible or polyfilled.\n                     */\n                    try {\n                        // eslint-disable-next-line @inngest/internal/process-warn\n                        const isProd = \"development\" === \"production\";\n                        return isProd;\n                    }\n                    catch (err) {\n                        // no-op\n                    }\n                },\n                queryString: (key, url) => {\n                    var _a;\n                    const qs = ((_a = req.query) === null || _a === void 0 ? void 0 : _a[key]) || url.searchParams.get(key);\n                    return Array.isArray(qs) ? qs[0] : qs;\n                },\n                url: () => {\n                    let absoluteUrl;\n                    try {\n                        absoluteUrl = new URL(req.url);\n                    }\n                    catch (_a) {\n                        // no-op\n                    }\n                    if (absoluteUrl) {\n                        /**\n                         * `req.url` here should may be the full URL, including query string.\n                         * There are some caveats, however, where Next.js will obfuscate\n                         * the host. For example, in the case of `host.docker.internal`,\n                         * Next.js will instead set the host here to `localhost`.\n                         *\n                         * To avoid this, we'll try to parse the URL from `req.url`, but\n                         * also use the `host` header if it's available.\n                         */\n                        const host = options.serveHost || getHeader(\"host\");\n                        if (host) {\n                            const hostWithProtocol = new URL(host.includes(\"://\") ? host : `${absoluteUrl.protocol}//${host}`);\n                            absoluteUrl.protocol = hostWithProtocol.protocol;\n                            absoluteUrl.host = hostWithProtocol.host;\n                            absoluteUrl.port = hostWithProtocol.port;\n                            absoluteUrl.username = hostWithProtocol.username;\n                            absoluteUrl.password = hostWithProtocol.password;\n                        }\n                        return absoluteUrl;\n                    }\n                    let scheme = \"https\";\n                    const host = options.serveHost || getHeader(\"host\") || \"\";\n                    try {\n                        // eslint-disable-next-line @inngest/internal/process-warn\n                        if (true) {\n                            scheme = \"http\";\n                        }\n                    }\n                    catch (err) {\n                        // no-op\n                    }\n                    const url = new URL(req.url, `${scheme}://${host}`);\n                    return url;\n                },\n                transformResponse: ({ body, headers, status }) => {\n                    /**\n                     * Carefully attempt to set headers and data on the response object\n                     * for Next.js 12 support.\n                     *\n                     * This also assumes that we're not using Next.js 15, where the `res`\n                     * object is repopulated as a `RouteContext` object. We expect these\n                     * methods to NOT be defined in Next.js 15.\n                     *\n                     * We could likely use `instanceof ServerResponse` to better check the\n                     * type of this, though Next.js 12 had issues with this due to not\n                     * instantiating the response correctly.\n                     */\n                    if (isNext12ApiResponse(res)) {\n                        for (const [key, value] of Object.entries(headers)) {\n                            res.setHeader(key, value);\n                        }\n                        res.status(status);\n                        res.send(body);\n                        /**\n                         * If we're here, we're in a serverless endpoint (not edge), so\n                         * we've correctly sent the response and can return `undefined`.\n                         *\n                         * Next.js 13 edge requires that the return value is typed as\n                         * `Response`, so we still enforce that as we cannot dynamically\n                         * adjust typing based on the environment.\n                         */\n                        return undefined;\n                    }\n                    /**\n                     * If we're here, we're in an edge environment and need to return a\n                     * `Response` object.\n                     *\n                     * We also don't know if the current environment has a native\n                     * `Response` object, so we'll grab that first.\n                     */\n                    const Res = (0, env_js_1.getResponse)();\n                    return new Res(body, { status, headers });\n                },\n                transformStreamingResponse: ({ body, headers, status }) => {\n                    return new Response(body, { status, headers });\n                },\n            };\n        } }));\n    /**\n     * Next.js 13 uses\n     * {@link https://beta.nextjs.org/docs/routing/route-handlers Route Handlers}\n     * to declare API routes instead of a generic catch-all method that was\n     * available using the `pages/api` directory.\n     *\n     * This means that users must now export a function for each method supported\n     * by the endpoint. For us, this means requiring a user explicitly exports\n     * `GET`, `POST`, and `PUT` functions.\n     *\n     * Because of this, we'll add circular references to those property names of\n     * the returned handler, meaning we can write some succinct code to export\n     * them. Thanks, @goodoldneon.\n     *\n     * @example\n     * ```ts\n     * export const { GET, POST, PUT } = serve(...);\n     * ```\n     *\n     * See {@link https://beta.nextjs.org/docs/routing/route-handlers}\n     */\n    const baseFn = handler.createHandler();\n    const fn = baseFn.bind(null, undefined);\n    /**\n     * Ensure we have a non-variadic length to avoid issues with forced type\n     * checking.\n     */\n    Object.defineProperty(fn, \"length\", { value: 1 });\n    const handlerFn = Object.defineProperties(fn, {\n        GET: { value: baseFn.bind(null, \"GET\") },\n        POST: { value: baseFn.bind(null, \"POST\") },\n        PUT: { value: baseFn.bind(null, \"PUT\") },\n    });\n    return handlerFn;\n};\nexports.serve = serve;\n//# sourceMappingURL=next.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9uZXh0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix3Q0FBd0M7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLHFCQUFxQjtBQUNyQyxnQ0FBZ0MsbUJBQU8sQ0FBQyx5R0FBb0M7QUFDNUUsaUJBQWlCLG1CQUFPLENBQUMscUVBQWtCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsd0NBQXdDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlHQUFpRyxzQ0FBc0MsY0FBYztBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIseUVBQXlFO0FBQ3BHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsYUFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLHFCQUFxQixJQUFJLEtBQUs7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLElBQXNDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPLEtBQUssS0FBSztBQUNyRTtBQUNBLGlCQUFpQjtBQUNqQixzQ0FBc0MsdUJBQXVCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQsaUJBQWlCO0FBQ2pCLCtDQUErQyx1QkFBdUI7QUFDdEUsZ0RBQWdELGlCQUFpQjtBQUNqRSxpQkFBaUI7QUFDakI7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxVQUFVO0FBQ3BEO0FBQ0EsZUFBZSxpQ0FBaUM7QUFDaEQsZ0JBQWdCLGtDQUFrQztBQUNsRCxlQUFlLGlDQUFpQztBQUNoRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L25leHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEFuIGFkYXB0ZXIgZm9yIE5leHQuanMgdG8gc2VydmUgYW5kIHJlZ2lzdGVyIGFueSBkZWNsYXJlZCBmdW5jdGlvbnMgd2l0aFxuICogSW5uZ2VzdCwgbWFraW5nIHRoZW0gYXZhaWxhYmxlIHRvIGJlIHRyaWdnZXJlZCBieSBldmVudHMuXG4gKlxuICogU3VwcG9ydHMgTmV4dC5qcyAxMissIGJvdGggc2VydmVybGVzcyBhbmQgZWRnZS5cbiAqXG4gKiBAZXhhbXBsZSBOZXh0LmpzIDw9MTIgb3IgdGhlIHBhZ2VzIHJvdXRlciBjYW4gZXhwb3J0IHRoZSBoYW5kbGVyIGRpcmVjdGx5XG4gKiBgYGB0c1xuICogZXhwb3J0IGRlZmF1bHQgc2VydmUoeyBjbGllbnQ6IGlubmdlc3QsIGZ1bmN0aW9uczogW2ZuMSwgZm4yXSB9KTtcbiAqIGBgYFxuICpcbiAqIEBleGFtcGxlIE5leHQuanMgPj0xMyB3aXRoIHRoZSBgYXBwYCBkaXIgbXVzdCBleHBvcnQgaW5kaXZpZHVhbCBtZXRob2RzXG4gKiBgYGB0c1xuICogZXhwb3J0IGNvbnN0IHsgR0VULCBQT1NULCBQVVQgfSA9IHNlcnZlKHtcbiAqICAgICAgICAgICAgY2xpZW50OiBpbm5nZXN0LFxuICogICAgICAgICAgICBmdW5jdGlvbnM6IFtmbjEsIGZuMl0sXG4gKiB9KTtcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXJ2ZSA9IGV4cG9ydHMuZnJhbWV3b3JrTmFtZSA9IHZvaWQgMDtcbmNvbnN0IElubmdlc3RDb21tSGFuZGxlcl9qc18xID0gcmVxdWlyZShcIi4vY29tcG9uZW50cy9Jbm5nZXN0Q29tbUhhbmRsZXIuanNcIik7XG5jb25zdCBlbnZfanNfMSA9IHJlcXVpcmUoXCIuL2hlbHBlcnMvZW52LmpzXCIpO1xuLyoqXG4gKiBUaGUgbmFtZSBvZiB0aGUgZnJhbWV3b3JrLCB1c2VkIHRvIGlkZW50aWZ5IHRoZSBmcmFtZXdvcmsgaW4gSW5uZ2VzdFxuICogZGFzaGJvYXJkcyBhbmQgZHVyaW5nIHRlc3RpbmcuXG4gKi9cbmV4cG9ydHMuZnJhbWV3b3JrTmFtZSA9IFwibmV4dGpzXCI7XG5jb25zdCBpc1JlY29yZCA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiB2YWwgIT09IG51bGw7XG59O1xuY29uc3QgaXNGdW5jdGlvbiA9ICh2YWwpID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xufTtcbmNvbnN0IGlzTmV4dDEyQXBpUmVzcG9uc2UgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuIChpc1JlY29yZCh2YWwpICYmXG4gICAgICAgIGlzRnVuY3Rpb24odmFsLnNldEhlYWRlcikgJiZcbiAgICAgICAgaXNGdW5jdGlvbih2YWwuc3RhdHVzKSAmJlxuICAgICAgICBpc0Z1bmN0aW9uKHZhbC5zZW5kKSk7XG59O1xuLyoqXG4gKiBJbiBOZXh0LmpzLCBzZXJ2ZSBhbmQgcmVnaXN0ZXIgYW55IGRlY2xhcmVkIGZ1bmN0aW9ucyB3aXRoIElubmdlc3QsIG1ha2luZ1xuICogdGhlbSBhdmFpbGFibGUgdG8gYmUgdHJpZ2dlcmVkIGJ5IGV2ZW50cy5cbiAqXG4gKiBTdXBwb3J0cyBOZXh0LmpzIDEyKywgYm90aCBzZXJ2ZXJsZXNzIGFuZCBlZGdlLlxuICpcbiAqIEBleGFtcGxlIE5leHQuanMgPD0xMiBvciB0aGUgcGFnZXMgcm91dGVyIGNhbiBleHBvcnQgdGhlIGhhbmRsZXIgZGlyZWN0bHlcbiAqIGBgYHRzXG4gKiBleHBvcnQgZGVmYXVsdCBzZXJ2ZSh7IGNsaWVudDogaW5uZ2VzdCwgZnVuY3Rpb25zOiBbZm4xLCBmbjJdIH0pO1xuICogYGBgXG4gKlxuICogQGV4YW1wbGUgTmV4dC5qcyA+PTEzIHdpdGggdGhlIGBhcHBgIGRpciBtdXN0IGV4cG9ydCBpbmRpdmlkdWFsIG1ldGhvZHNcbiAqIGBgYHRzXG4gKiBleHBvcnQgY29uc3QgeyBHRVQsIFBPU1QsIFBVVCB9ID0gc2VydmUoe1xuICogICAgICAgICAgICBjbGllbnQ6IGlubmdlc3QsXG4gKiAgICAgICAgICAgIGZ1bmN0aW9uczogW2ZuMSwgZm4yXSxcbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG4vLyBIYXMgZXhwbGljaXQgcmV0dXJuIHR5cGUgdG8gYXZvaWQgSlNSLWRlZmluZWQgXCJzbG93IHR5cGVzXCJcbmNvbnN0IHNlcnZlID0gKG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBoYW5kbGVyID0gbmV3IElubmdlc3RDb21tSGFuZGxlcl9qc18xLklubmdlc3RDb21tSGFuZGxlcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBmcmFtZXdvcmtOYW1lOiBleHBvcnRzLmZyYW1ld29ya05hbWUgfSwgb3B0aW9ucyksIHsgaGFuZGxlcjogKHJlcU1ldGhvZCwgLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3QgW2V4cGVjdGVkUmVxLCByZXNdID0gYXJncztcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGV4cGVjdGVkUmVxO1xuICAgICAgICAgICAgY29uc3QgZ2V0SGVhZGVyID0gKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlYWRlciA9IHR5cGVvZiByZXEuaGVhZGVycy5nZXQgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICA/IHJlcS5oZWFkZXJzLmdldChrZXkpXG4gICAgICAgICAgICAgICAgICAgIDogcmVxLmhlYWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShoZWFkZXIpID8gaGVhZGVyWzBdIDogaGVhZGVyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgICAgICAgICAgICAgYm9keTogKCkgPT4gKHR5cGVvZiByZXEuanNvbiA9PT0gXCJmdW5jdGlvblwiID8gcmVxLmpzb24oKSA6IHJlcS5ib2R5KSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiBnZXRIZWFkZXIsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBgcmVxLm1ldGhvZGAsIHRob3VnaCB0eXBlcyBzYXkgb3RoZXJ3aXNlLCBpcyBub3QgYXZhaWxhYmxlIGluIE5leHQuanNcbiAgICAgICAgICAgICAgICAgICAgICogMTMge0BsaW5rIGh0dHBzOi8vYmV0YS5uZXh0anMub3JnL2RvY3Mvcm91dGluZy9yb3V0ZS1oYW5kbGVycyBSb3V0ZSBIYW5kbGVyc30uXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIFRoZXJlZm9yZSwgd2UgbXVzdCB0cnkgdG8gc2V0IHRoZSBtZXRob2Qgb3Vyc2VsdmVzIHdoZXJlIHdlIGtub3cgaXQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXRob2QgPSByZXFNZXRob2QgfHwgcmVxLm1ldGhvZCB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNQcm9kdWN0aW9uOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBWZXJjZWwgRWRnZSBGdW5jdGlvbnMgZG8gbm90IGFsbG93IGR5bmFtaWMgYWNjZXNzIHRvIGVudmlyb25tZW50XG4gICAgICAgICAgICAgICAgICAgICAqIHZhcmlhYmxlcywgc28gd2UnbGwgbWFuYWdlIHByb2R1Y3Rpb24gY2hlY2tzIGRpcmVjdGx5IGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIHRyeS9jYXRjaCB0byBhdm9pZCBzaXR1YXRpb25zIHdoZXJlIE5leHQuanMgaXMgYmVpbmcgdXNlZCBpblxuICAgICAgICAgICAgICAgICAgICAgKiBlbnZpcm9ubWVudHMgd2hlcmUgYHByb2Nlc3MuZW52YCBpcyBub3QgYWNjZXNzaWJsZSBvciBwb2x5ZmlsbGVkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAaW5uZ2VzdC9pbnRlcm5hbC9wcm9jZXNzLXdhcm5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUHJvZCA9IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1Byb2Q7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcXVlcnlTdHJpbmc6IChrZXksIHVybCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHFzID0gKChfYSA9IHJlcS5xdWVyeSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2tleV0pIHx8IHVybC5zZWFyY2hQYXJhbXMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHFzKSA/IHFzWzBdIDogcXM7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB1cmw6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGFic29sdXRlVXJsO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVVcmwgPSBuZXcgVVJMKHJlcS51cmwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8tb3BcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWJzb2x1dGVVcmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogYHJlcS51cmxgIGhlcmUgc2hvdWxkIG1heSBiZSB0aGUgZnVsbCBVUkwsIGluY2x1ZGluZyBxdWVyeSBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUaGVyZSBhcmUgc29tZSBjYXZlYXRzLCBob3dldmVyLCB3aGVyZSBOZXh0LmpzIHdpbGwgb2JmdXNjYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGUgaG9zdC4gRm9yIGV4YW1wbGUsIGluIHRoZSBjYXNlIG9mIGBob3N0LmRvY2tlci5pbnRlcm5hbGAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBOZXh0LmpzIHdpbGwgaW5zdGVhZCBzZXQgdGhlIGhvc3QgaGVyZSB0byBgbG9jYWxob3N0YC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBUbyBhdm9pZCB0aGlzLCB3ZSdsbCB0cnkgdG8gcGFyc2UgdGhlIFVSTCBmcm9tIGByZXEudXJsYCwgYnV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBhbHNvIHVzZSB0aGUgYGhvc3RgIGhlYWRlciBpZiBpdCdzIGF2YWlsYWJsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9zdCA9IG9wdGlvbnMuc2VydmVIb3N0IHx8IGdldEhlYWRlcihcImhvc3RcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvc3RXaXRoUHJvdG9jb2wgPSBuZXcgVVJMKGhvc3QuaW5jbHVkZXMoXCI6Ly9cIikgPyBob3N0IDogYCR7YWJzb2x1dGVVcmwucHJvdG9jb2x9Ly8ke2hvc3R9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVVcmwucHJvdG9jb2wgPSBob3N0V2l0aFByb3RvY29sLnByb3RvY29sO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVXJsLmhvc3QgPSBob3N0V2l0aFByb3RvY29sLmhvc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVVcmwucG9ydCA9IGhvc3RXaXRoUHJvdG9jb2wucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVVybC51c2VybmFtZSA9IGhvc3RXaXRoUHJvdG9jb2wudXNlcm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVVcmwucGFzc3dvcmQgPSBob3N0V2l0aFByb3RvY29sLnBhc3N3b3JkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFic29sdXRlVXJsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBzY2hlbWUgPSBcImh0dHBzXCI7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvc3QgPSBvcHRpb25zLnNlcnZlSG9zdCB8fCBnZXRIZWFkZXIoXCJob3N0XCIpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGlubmdlc3QvaW50ZXJuYWwvcHJvY2Vzcy13YXJuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjaGVtZSA9IFwiaHR0cFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vLW9wXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXEudXJsLCBgJHtzY2hlbWV9Oi8vJHtob3N0fWApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtUmVzcG9uc2U6ICh7IGJvZHksIGhlYWRlcnMsIHN0YXR1cyB9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBDYXJlZnVsbHkgYXR0ZW1wdCB0byBzZXQgaGVhZGVycyBhbmQgZGF0YSBvbiB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAqIGZvciBOZXh0LmpzIDEyIHN1cHBvcnQuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIFRoaXMgYWxzbyBhc3N1bWVzIHRoYXQgd2UncmUgbm90IHVzaW5nIE5leHQuanMgMTUsIHdoZXJlIHRoZSBgcmVzYFxuICAgICAgICAgICAgICAgICAgICAgKiBvYmplY3QgaXMgcmVwb3B1bGF0ZWQgYXMgYSBgUm91dGVDb250ZXh0YCBvYmplY3QuIFdlIGV4cGVjdCB0aGVzZVxuICAgICAgICAgICAgICAgICAgICAgKiBtZXRob2RzIHRvIE5PVCBiZSBkZWZpbmVkIGluIE5leHQuanMgMTUuXG4gICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIGNvdWxkIGxpa2VseSB1c2UgYGluc3RhbmNlb2YgU2VydmVyUmVzcG9uc2VgIHRvIGJldHRlciBjaGVjayB0aGVcbiAgICAgICAgICAgICAgICAgICAgICogdHlwZSBvZiB0aGlzLCB0aG91Z2ggTmV4dC5qcyAxMiBoYWQgaXNzdWVzIHdpdGggdGhpcyBkdWUgdG8gbm90XG4gICAgICAgICAgICAgICAgICAgICAqIGluc3RhbnRpYXRpbmcgdGhlIHJlc3BvbnNlIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc05leHQxMkFwaVJlc3BvbnNlKHJlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzLnNldEhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5zZW5kKGJvZHkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiB3ZSdyZSBoZXJlLCB3ZSdyZSBpbiBhIHNlcnZlcmxlc3MgZW5kcG9pbnQgKG5vdCBlZGdlKSwgc29cbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHdlJ3ZlIGNvcnJlY3RseSBzZW50IHRoZSByZXNwb25zZSBhbmQgY2FuIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBOZXh0LmpzIDEzIGVkZ2UgcmVxdWlyZXMgdGhhdCB0aGUgcmV0dXJuIHZhbHVlIGlzIHR5cGVkIGFzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBgUmVzcG9uc2VgLCBzbyB3ZSBzdGlsbCBlbmZvcmNlIHRoYXQgYXMgd2UgY2Fubm90IGR5bmFtaWNhbGx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBhZGp1c3QgdHlwaW5nIGJhc2VkIG9uIHRoZSBlbnZpcm9ubWVudC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogSWYgd2UncmUgaGVyZSwgd2UncmUgaW4gYW4gZWRnZSBlbnZpcm9ubWVudCBhbmQgbmVlZCB0byByZXR1cm4gYVxuICAgICAgICAgICAgICAgICAgICAgKiBgUmVzcG9uc2VgIG9iamVjdC5cbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogV2UgYWxzbyBkb24ndCBrbm93IGlmIHRoZSBjdXJyZW50IGVudmlyb25tZW50IGhhcyBhIG5hdGl2ZVxuICAgICAgICAgICAgICAgICAgICAgKiBgUmVzcG9uc2VgIG9iamVjdCwgc28gd2UnbGwgZ3JhYiB0aGF0IGZpcnN0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgUmVzID0gKDAsIGVudl9qc18xLmdldFJlc3BvbnNlKSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlcyhib2R5LCB7IHN0YXR1cywgaGVhZGVycyB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybVN0cmVhbWluZ1Jlc3BvbnNlOiAoeyBib2R5LCBoZWFkZXJzLCBzdGF0dXMgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGJvZHksIHsgc3RhdHVzLCBoZWFkZXJzIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IH0pKTtcbiAgICAvKipcbiAgICAgKiBOZXh0LmpzIDEzIHVzZXNcbiAgICAgKiB7QGxpbmsgaHR0cHM6Ly9iZXRhLm5leHRqcy5vcmcvZG9jcy9yb3V0aW5nL3JvdXRlLWhhbmRsZXJzIFJvdXRlIEhhbmRsZXJzfVxuICAgICAqIHRvIGRlY2xhcmUgQVBJIHJvdXRlcyBpbnN0ZWFkIG9mIGEgZ2VuZXJpYyBjYXRjaC1hbGwgbWV0aG9kIHRoYXQgd2FzXG4gICAgICogYXZhaWxhYmxlIHVzaW5nIHRoZSBgcGFnZXMvYXBpYCBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgdXNlcnMgbXVzdCBub3cgZXhwb3J0IGEgZnVuY3Rpb24gZm9yIGVhY2ggbWV0aG9kIHN1cHBvcnRlZFxuICAgICAqIGJ5IHRoZSBlbmRwb2ludC4gRm9yIHVzLCB0aGlzIG1lYW5zIHJlcXVpcmluZyBhIHVzZXIgZXhwbGljaXRseSBleHBvcnRzXG4gICAgICogYEdFVGAsIGBQT1NUYCwgYW5kIGBQVVRgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEJlY2F1c2Ugb2YgdGhpcywgd2UnbGwgYWRkIGNpcmN1bGFyIHJlZmVyZW5jZXMgdG8gdGhvc2UgcHJvcGVydHkgbmFtZXMgb2ZcbiAgICAgKiB0aGUgcmV0dXJuZWQgaGFuZGxlciwgbWVhbmluZyB3ZSBjYW4gd3JpdGUgc29tZSBzdWNjaW5jdCBjb2RlIHRvIGV4cG9ydFxuICAgICAqIHRoZW0uIFRoYW5rcywgQGdvb2RvbGRuZW9uLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGB0c1xuICAgICAqIGV4cG9ydCBjb25zdCB7IEdFVCwgUE9TVCwgUFVUIH0gPSBzZXJ2ZSguLi4pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBodHRwczovL2JldGEubmV4dGpzLm9yZy9kb2NzL3JvdXRpbmcvcm91dGUtaGFuZGxlcnN9XG4gICAgICovXG4gICAgY29uc3QgYmFzZUZuID0gaGFuZGxlci5jcmVhdGVIYW5kbGVyKCk7XG4gICAgY29uc3QgZm4gPSBiYXNlRm4uYmluZChudWxsLCB1bmRlZmluZWQpO1xuICAgIC8qKlxuICAgICAqIEVuc3VyZSB3ZSBoYXZlIGEgbm9uLXZhcmlhZGljIGxlbmd0aCB0byBhdm9pZCBpc3N1ZXMgd2l0aCBmb3JjZWQgdHlwZVxuICAgICAqIGNoZWNraW5nLlxuICAgICAqL1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgXCJsZW5ndGhcIiwgeyB2YWx1ZTogMSB9KTtcbiAgICBjb25zdCBoYW5kbGVyRm4gPSBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhmbiwge1xuICAgICAgICBHRVQ6IHsgdmFsdWU6IGJhc2VGbi5iaW5kKG51bGwsIFwiR0VUXCIpIH0sXG4gICAgICAgIFBPU1Q6IHsgdmFsdWU6IGJhc2VGbi5iaW5kKG51bGwsIFwiUE9TVFwiKSB9LFxuICAgICAgICBQVVQ6IHsgdmFsdWU6IGJhc2VGbi5iaW5kKG51bGwsIFwiUFVUXCIpIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGhhbmRsZXJGbjtcbn07XG5leHBvcnRzLnNlcnZlID0gc2VydmU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXh0LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/next.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/ansi-regex/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/node_modules/ansi-regex/index.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = (options)=>{\n    options = Object.assign({\n        onlyFirst: false\n    }, options);\n    const pattern = [\n        '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n        '(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n    ].join('|');\n    return new RegExp(pattern, options.onlyFirst ? undefined : 'g');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUViQSxPQUFPQyxPQUFPLEdBQUdDLENBQUFBO0lBQ2hCQSxVQUFVQyxPQUFPQyxNQUFNLENBQUM7UUFDdkJDLFdBQVc7SUFDWixHQUFHSDtJQUVILE1BQU1JLFVBQVU7UUFDZjtRQUNBO0tBQ0EsQ0FBQ0MsSUFBSSxDQUFDO0lBRVAsT0FBTyxJQUFJQyxPQUFPRixTQUFTSixRQUFRRyxTQUFTLEdBQUdJLFlBQVk7QUFDNUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy9oYXJzaHNocml2YXN0YXYvRGVza3RvcC9Db2RpbmcgUHJvamVjdHMvSm9iLUFzc2lzdGFudC1BZ2VudC9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gb3B0aW9ucyA9PiB7XG5cdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHtcblx0XHRvbmx5Rmlyc3Q6IGZhbHNlXG5cdH0sIG9wdGlvbnMpO1xuXG5cdGNvbnN0IHBhdHRlcm4gPSBbXG5cdFx0J1tcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10rKSp8W2EtekEtWlxcXFxkXSsoPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNyknLFxuXHRcdCcoPzooPzpcXFxcZHsxLDR9KD86O1xcXFxkezAsNH0pKik/W1xcXFxkQS1QUi1UWmNmLW50cXJ5PT48fl0pKSdcblx0XS5qb2luKCd8Jyk7XG5cblx0cmV0dXJuIG5ldyBSZWdFeHAocGF0dGVybiwgb3B0aW9ucy5vbmx5Rmlyc3QgPyB1bmRlZmluZWQgOiAnZycpO1xufTtcbiJdLCJuYW1lcyI6WyJtb2R1bGUiLCJleHBvcnRzIiwib3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsIm9ubHlGaXJzdCIsInBhdHRlcm4iLCJqb2luIiwiUmVnRXhwIiwidW5kZWZpbmVkIl0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/ansi-regex/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/node_modules/strip-ansi/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/inngest/node_modules/strip-ansi/index.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst ansiRegex = __webpack_require__(/*! ansi-regex */ \"(rsc)/./node_modules/inngest/node_modules/ansi-regex/index.js\");\nconst stripAnsi = (string)=>typeof string === 'string' ? string.replace(ansiRegex(), '') : string;\nmodule.exports = stripAnsi;\nmodule.exports[\"default\"] = stripAnsi;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC9ub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLE1BQU1BLFlBQVlDLG1CQUFPQSxDQUFDLGlGQUFZO0FBRXRDLE1BQU1DLFlBQVlDLENBQUFBLFNBQVUsT0FBT0EsV0FBVyxXQUFXQSxPQUFPQyxPQUFPLENBQUNKLGFBQWEsTUFBTUc7QUFFM0ZFLE9BQU9DLE9BQU8sR0FBR0o7QUFDakJHLHlCQUFzQixHQUFHSCIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L25vZGVfbW9kdWxlcy9zdHJpcC1hbnNpL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmNvbnN0IGFuc2lSZWdleCA9IHJlcXVpcmUoJ2Fuc2ktcmVnZXgnKTtcblxuY29uc3Qgc3RyaXBBbnNpID0gc3RyaW5nID0+IHR5cGVvZiBzdHJpbmcgPT09ICdzdHJpbmcnID8gc3RyaW5nLnJlcGxhY2UoYW5zaVJlZ2V4KCksICcnKSA6IHN0cmluZztcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpcEFuc2k7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gc3RyaXBBbnNpO1xuIl0sIm5hbWVzIjpbImFuc2lSZWdleCIsInJlcXVpcmUiLCJzdHJpcEFuc2kiLCJzdHJpbmciLCJyZXBsYWNlIiwibW9kdWxlIiwiZXhwb3J0cyIsImRlZmF1bHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/node_modules/strip-ansi/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/types.js":
/*!***************************************!*\
  !*** ./node_modules/inngest/types.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\n/**\n * Internal types and schemas used throughout the Inngest SDK.\n *\n * Note that types intended to be imported and utilized in userland code will be\n * exported from the main entrypoint of the SDK, `inngest`; importing types\n * directly from this file may result in breaking changes in non-major bumps as\n * only those exported from `inngest` are considered stable.\n *\n * @module\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.inBandSyncRequestBodySchema = exports.err = exports.ok = exports.functionConfigSchema = exports.logLevels = exports.sendEventResponseSchema = exports.incomingOpSchema = exports.StepOpCode = exports.jsonErrorSchema = void 0;\nconst zod_1 = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.js\");\nconst baseJsonErrorSchema = zod_1.z.object({\n    name: zod_1.z.string().trim().optional(),\n    error: zod_1.z.string().trim().optional(),\n    message: zod_1.z.string().trim().optional(),\n    stack: zod_1.z.string().trim().optional(),\n});\nconst maybeJsonErrorSchema = zod_1.z.lazy(() => zod_1.z.object({\n    name: zod_1.z.string().trim(),\n    message: zod_1.z.string().trim(),\n    stack: zod_1.z.string().trim().optional(),\n    cause: zod_1.z.union([maybeJsonErrorSchema, zod_1.z.unknown()]).optional(),\n}));\nexports.jsonErrorSchema = baseJsonErrorSchema\n    .extend({\n    cause: zod_1.z.union([maybeJsonErrorSchema, zod_1.z.unknown()]).optional(),\n})\n    .passthrough()\n    .catch({})\n    .transform((val) => {\n    return Object.assign(Object.assign({}, val), { name: val.name || \"Error\", message: val.message || val.error || \"Unknown error\", stack: val.stack });\n});\n/**\n * Unique codes for the different types of operation that can be sent to Inngest\n * from SDK step functions.\n */\nvar StepOpCode;\n(function (StepOpCode) {\n    StepOpCode[\"WaitForSignal\"] = \"WaitForSignal\";\n    StepOpCode[\"WaitForEvent\"] = \"WaitForEvent\";\n    /**\n     * Legacy equivalent to `\"StepRun\"`. Has mixed data wrapping (e.g. `data` or\n     * `data.data` depending on SDK version), so this is phased out in favour of\n     * `\"StepRun\"`, which never wraps.\n     *\n     * Note that it is still used for v0 executions for backwards compatibility.\n     *\n     * @deprecated Only used for v0 executions; use `\"StepRun\"` instead.\n     */\n    StepOpCode[\"Step\"] = \"Step\";\n    StepOpCode[\"StepRun\"] = \"StepRun\";\n    StepOpCode[\"StepError\"] = \"StepError\";\n    StepOpCode[\"StepPlanned\"] = \"StepPlanned\";\n    StepOpCode[\"Sleep\"] = \"Sleep\";\n    /**\n     * Used to signify that the executor has requested that a step run, but we\n     * could not find that step.\n     *\n     * This is likely indicative that a step was renamed or removed from the\n     * function.\n     */\n    StepOpCode[\"StepNotFound\"] = \"StepNotFound\";\n    StepOpCode[\"InvokeFunction\"] = \"InvokeFunction\";\n    StepOpCode[\"AiGateway\"] = \"AIGateway\";\n    StepOpCode[\"Gateway\"] = \"Gateway\";\n})(StepOpCode || (exports.StepOpCode = StepOpCode = {}));\nexports.incomingOpSchema = zod_1.z.object({\n    id: zod_1.z.string().min(1),\n    data: zod_1.z.any().optional(),\n    error: zod_1.z.any().optional(),\n    input: zod_1.z.any().optional(),\n});\nexports.sendEventResponseSchema = zod_1.z.object({\n    /**\n     * Event IDs\n     */\n    ids: zod_1.z.array(zod_1.z.string()).default([]),\n    /**\n     * HTTP Status Code. Will be undefined if no request was sent.\n     */\n    status: zod_1.z.number().default(0),\n    /**\n     * Error message. Will be undefined if no error occurred.\n     */\n    error: zod_1.z.string().optional(),\n});\n/**\n * A set of log levels that can be used to control the amount of logging output\n * from various parts of the Inngest library.\n *\n * @public\n */\nexports.logLevels = [\n    \"fatal\",\n    \"error\",\n    \"warn\",\n    \"info\",\n    \"debug\",\n    \"silent\",\n];\n/**\n * This schema is used internally to share the shape of a concurrency option\n * when validating config. We cannot add comments to Zod fields, so we just use\n * an extra type check to ensure it matches our exported expectations.\n */\nconst concurrencyOptionSchema = zod_1.z.strictObject({\n    limit: zod_1.z.number(),\n    key: zod_1.z.string().optional(),\n    scope: zod_1.z.enum([\"fn\", \"env\", \"account\"]).optional(),\n});\nconst _checkConcurrencySchemaAligns = true;\n/**\n * The schema used to represent an individual function being synced with\n * Inngest.\n *\n * Note that this should only be used to validate the shape of a config object\n * and not used for feature compatibility, such as feature X being exclusive\n * with feature Y; these should be handled on the Inngest side.\n */\nexports.functionConfigSchema = zod_1.z.strictObject({\n    name: zod_1.z.string().optional(),\n    id: zod_1.z.string(),\n    triggers: zod_1.z.array(zod_1.z.union([\n        zod_1.z.strictObject({\n            event: zod_1.z.string(),\n            expression: zod_1.z.string().optional(),\n        }),\n        zod_1.z.strictObject({\n            cron: zod_1.z.string(),\n        }),\n    ])),\n    steps: zod_1.z.record(zod_1.z.strictObject({\n        id: zod_1.z.string(),\n        name: zod_1.z.string(),\n        runtime: zod_1.z.strictObject({\n            type: zod_1.z.union([zod_1.z.literal(\"http\"), zod_1.z.literal(\"ws\")]),\n            url: zod_1.z.string(),\n        }),\n        retries: zod_1.z\n            .strictObject({\n            attempts: zod_1.z.number().optional(),\n        })\n            .optional(),\n    })),\n    idempotency: zod_1.z.string().optional(),\n    batchEvents: zod_1.z\n        .strictObject({\n        maxSize: zod_1.z.number(),\n        timeout: zod_1.z.string(),\n        key: zod_1.z.string().optional(),\n    })\n        .optional(),\n    rateLimit: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        limit: zod_1.z.number(),\n        period: zod_1.z.string().transform((x) => x),\n    })\n        .optional(),\n    throttle: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        limit: zod_1.z.number(),\n        period: zod_1.z.string().transform((x) => x),\n        burst: zod_1.z.number().optional(),\n    })\n        .optional(),\n    singleton: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        mode: zod_1.z.enum([\"skip\", \"cancel\"]),\n    })\n        .optional(),\n    cancel: zod_1.z\n        .array(zod_1.z.strictObject({\n        event: zod_1.z.string(),\n        if: zod_1.z.string().optional(),\n        timeout: zod_1.z.string().optional(),\n    }))\n        .optional(),\n    debounce: zod_1.z\n        .strictObject({\n        key: zod_1.z.string().optional(),\n        period: zod_1.z.string().transform((x) => x),\n        timeout: zod_1.z\n            .string()\n            .transform((x) => x)\n            .optional(),\n    })\n        .optional(),\n    timeouts: zod_1.z\n        .strictObject({\n        start: zod_1.z\n            .string()\n            .transform((x) => x)\n            .optional(),\n        finish: zod_1.z\n            .string()\n            .transform((x) => x)\n            .optional(),\n    })\n        .optional(),\n    priority: zod_1.z\n        .strictObject({\n        run: zod_1.z.string().optional(),\n    })\n        .optional(),\n    concurrency: zod_1.z\n        .union([\n        zod_1.z.number(),\n        concurrencyOptionSchema.transform((x) => x),\n        zod_1.z\n            .array(concurrencyOptionSchema.transform((x) => x))\n            .min(1)\n            .max(2),\n    ])\n        .optional(),\n});\nconst ok = (data) => {\n    return { ok: true, value: data };\n};\nexports.ok = ok;\nconst err = (error) => {\n    return { ok: false, error };\n};\nexports.err = err;\nexports.inBandSyncRequestBodySchema = zod_1.z.strictObject({\n    url: zod_1.z.string(),\n});\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUNBQW1DLEdBQUcsV0FBVyxHQUFHLFVBQVUsR0FBRyw0QkFBNEIsR0FBRyxpQkFBaUIsR0FBRywrQkFBK0IsR0FBRyx3QkFBd0IsR0FBRyxrQkFBa0IsR0FBRyx1QkFBdUI7QUFDN04sY0FBYyxtQkFBTyxDQUFDLGtEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGFBQWE7QUFDYjtBQUNBLHlDQUF5QyxVQUFVLG1HQUFtRztBQUN0SixDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGlCQUFpQixrQkFBa0Isa0JBQWtCO0FBQ3RELHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYLG1DQUFtQztBQUNuQztBQUNBLENBQUM7QUFDRCIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L3R5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBJbnRlcm5hbCB0eXBlcyBhbmQgc2NoZW1hcyB1c2VkIHRocm91Z2hvdXQgdGhlIElubmdlc3QgU0RLLlxuICpcbiAqIE5vdGUgdGhhdCB0eXBlcyBpbnRlbmRlZCB0byBiZSBpbXBvcnRlZCBhbmQgdXRpbGl6ZWQgaW4gdXNlcmxhbmQgY29kZSB3aWxsIGJlXG4gKiBleHBvcnRlZCBmcm9tIHRoZSBtYWluIGVudHJ5cG9pbnQgb2YgdGhlIFNESywgYGlubmdlc3RgOyBpbXBvcnRpbmcgdHlwZXNcbiAqIGRpcmVjdGx5IGZyb20gdGhpcyBmaWxlIG1heSByZXN1bHQgaW4gYnJlYWtpbmcgY2hhbmdlcyBpbiBub24tbWFqb3IgYnVtcHMgYXNcbiAqIG9ubHkgdGhvc2UgZXhwb3J0ZWQgZnJvbSBgaW5uZ2VzdGAgYXJlIGNvbnNpZGVyZWQgc3RhYmxlLlxuICpcbiAqIEBtb2R1bGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbkJhbmRTeW5jUmVxdWVzdEJvZHlTY2hlbWEgPSBleHBvcnRzLmVyciA9IGV4cG9ydHMub2sgPSBleHBvcnRzLmZ1bmN0aW9uQ29uZmlnU2NoZW1hID0gZXhwb3J0cy5sb2dMZXZlbHMgPSBleHBvcnRzLnNlbmRFdmVudFJlc3BvbnNlU2NoZW1hID0gZXhwb3J0cy5pbmNvbWluZ09wU2NoZW1hID0gZXhwb3J0cy5TdGVwT3BDb2RlID0gZXhwb3J0cy5qc29uRXJyb3JTY2hlbWEgPSB2b2lkIDA7XG5jb25zdCB6b2RfMSA9IHJlcXVpcmUoXCJ6b2RcIik7XG5jb25zdCBiYXNlSnNvbkVycm9yU2NoZW1hID0gem9kXzEuei5vYmplY3Qoe1xuICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCkudHJpbSgpLm9wdGlvbmFsKCksXG4gICAgZXJyb3I6IHpvZF8xLnouc3RyaW5nKCkudHJpbSgpLm9wdGlvbmFsKCksXG4gICAgbWVzc2FnZTogem9kXzEuei5zdHJpbmcoKS50cmltKCkub3B0aW9uYWwoKSxcbiAgICBzdGFjazogem9kXzEuei5zdHJpbmcoKS50cmltKCkub3B0aW9uYWwoKSxcbn0pO1xuY29uc3QgbWF5YmVKc29uRXJyb3JTY2hlbWEgPSB6b2RfMS56LmxhenkoKCkgPT4gem9kXzEuei5vYmplY3Qoe1xuICAgIG5hbWU6IHpvZF8xLnouc3RyaW5nKCkudHJpbSgpLFxuICAgIG1lc3NhZ2U6IHpvZF8xLnouc3RyaW5nKCkudHJpbSgpLFxuICAgIHN0YWNrOiB6b2RfMS56LnN0cmluZygpLnRyaW0oKS5vcHRpb25hbCgpLFxuICAgIGNhdXNlOiB6b2RfMS56LnVuaW9uKFttYXliZUpzb25FcnJvclNjaGVtYSwgem9kXzEuei51bmtub3duKCldKS5vcHRpb25hbCgpLFxufSkpO1xuZXhwb3J0cy5qc29uRXJyb3JTY2hlbWEgPSBiYXNlSnNvbkVycm9yU2NoZW1hXG4gICAgLmV4dGVuZCh7XG4gICAgY2F1c2U6IHpvZF8xLnoudW5pb24oW21heWJlSnNvbkVycm9yU2NoZW1hLCB6b2RfMS56LnVua25vd24oKV0pLm9wdGlvbmFsKCksXG59KVxuICAgIC5wYXNzdGhyb3VnaCgpXG4gICAgLmNhdGNoKHt9KVxuICAgIC50cmFuc2Zvcm0oKHZhbCkgPT4ge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhbCksIHsgbmFtZTogdmFsLm5hbWUgfHwgXCJFcnJvclwiLCBtZXNzYWdlOiB2YWwubWVzc2FnZSB8fCB2YWwuZXJyb3IgfHwgXCJVbmtub3duIGVycm9yXCIsIHN0YWNrOiB2YWwuc3RhY2sgfSk7XG59KTtcbi8qKlxuICogVW5pcXVlIGNvZGVzIGZvciB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIG9wZXJhdGlvbiB0aGF0IGNhbiBiZSBzZW50IHRvIElubmdlc3RcbiAqIGZyb20gU0RLIHN0ZXAgZnVuY3Rpb25zLlxuICovXG52YXIgU3RlcE9wQ29kZTtcbihmdW5jdGlvbiAoU3RlcE9wQ29kZSkge1xuICAgIFN0ZXBPcENvZGVbXCJXYWl0Rm9yU2lnbmFsXCJdID0gXCJXYWl0Rm9yU2lnbmFsXCI7XG4gICAgU3RlcE9wQ29kZVtcIldhaXRGb3JFdmVudFwiXSA9IFwiV2FpdEZvckV2ZW50XCI7XG4gICAgLyoqXG4gICAgICogTGVnYWN5IGVxdWl2YWxlbnQgdG8gYFwiU3RlcFJ1blwiYC4gSGFzIG1peGVkIGRhdGEgd3JhcHBpbmcgKGUuZy4gYGRhdGFgIG9yXG4gICAgICogYGRhdGEuZGF0YWAgZGVwZW5kaW5nIG9uIFNESyB2ZXJzaW9uKSwgc28gdGhpcyBpcyBwaGFzZWQgb3V0IGluIGZhdm91ciBvZlxuICAgICAqIGBcIlN0ZXBSdW5cImAsIHdoaWNoIG5ldmVyIHdyYXBzLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IGl0IGlzIHN0aWxsIHVzZWQgZm9yIHYwIGV4ZWN1dGlvbnMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgT25seSB1c2VkIGZvciB2MCBleGVjdXRpb25zOyB1c2UgYFwiU3RlcFJ1blwiYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIFN0ZXBPcENvZGVbXCJTdGVwXCJdID0gXCJTdGVwXCI7XG4gICAgU3RlcE9wQ29kZVtcIlN0ZXBSdW5cIl0gPSBcIlN0ZXBSdW5cIjtcbiAgICBTdGVwT3BDb2RlW1wiU3RlcEVycm9yXCJdID0gXCJTdGVwRXJyb3JcIjtcbiAgICBTdGVwT3BDb2RlW1wiU3RlcFBsYW5uZWRcIl0gPSBcIlN0ZXBQbGFubmVkXCI7XG4gICAgU3RlcE9wQ29kZVtcIlNsZWVwXCJdID0gXCJTbGVlcFwiO1xuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gc2lnbmlmeSB0aGF0IHRoZSBleGVjdXRvciBoYXMgcmVxdWVzdGVkIHRoYXQgYSBzdGVwIHJ1biwgYnV0IHdlXG4gICAgICogY291bGQgbm90IGZpbmQgdGhhdCBzdGVwLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBsaWtlbHkgaW5kaWNhdGl2ZSB0aGF0IGEgc3RlcCB3YXMgcmVuYW1lZCBvciByZW1vdmVkIGZyb20gdGhlXG4gICAgICogZnVuY3Rpb24uXG4gICAgICovXG4gICAgU3RlcE9wQ29kZVtcIlN0ZXBOb3RGb3VuZFwiXSA9IFwiU3RlcE5vdEZvdW5kXCI7XG4gICAgU3RlcE9wQ29kZVtcIkludm9rZUZ1bmN0aW9uXCJdID0gXCJJbnZva2VGdW5jdGlvblwiO1xuICAgIFN0ZXBPcENvZGVbXCJBaUdhdGV3YXlcIl0gPSBcIkFJR2F0ZXdheVwiO1xuICAgIFN0ZXBPcENvZGVbXCJHYXRld2F5XCJdID0gXCJHYXRld2F5XCI7XG59KShTdGVwT3BDb2RlIHx8IChleHBvcnRzLlN0ZXBPcENvZGUgPSBTdGVwT3BDb2RlID0ge30pKTtcbmV4cG9ydHMuaW5jb21pbmdPcFNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICBpZDogem9kXzEuei5zdHJpbmcoKS5taW4oMSksXG4gICAgZGF0YTogem9kXzEuei5hbnkoKS5vcHRpb25hbCgpLFxuICAgIGVycm9yOiB6b2RfMS56LmFueSgpLm9wdGlvbmFsKCksXG4gICAgaW5wdXQ6IHpvZF8xLnouYW55KCkub3B0aW9uYWwoKSxcbn0pO1xuZXhwb3J0cy5zZW5kRXZlbnRSZXNwb25zZVNjaGVtYSA9IHpvZF8xLnoub2JqZWN0KHtcbiAgICAvKipcbiAgICAgKiBFdmVudCBJRHNcbiAgICAgKi9cbiAgICBpZHM6IHpvZF8xLnouYXJyYXkoem9kXzEuei5zdHJpbmcoKSkuZGVmYXVsdChbXSksXG4gICAgLyoqXG4gICAgICogSFRUUCBTdGF0dXMgQ29kZS4gV2lsbCBiZSB1bmRlZmluZWQgaWYgbm8gcmVxdWVzdCB3YXMgc2VudC5cbiAgICAgKi9cbiAgICBzdGF0dXM6IHpvZF8xLnoubnVtYmVyKCkuZGVmYXVsdCgwKSxcbiAgICAvKipcbiAgICAgKiBFcnJvciBtZXNzYWdlLiBXaWxsIGJlIHVuZGVmaW5lZCBpZiBubyBlcnJvciBvY2N1cnJlZC5cbiAgICAgKi9cbiAgICBlcnJvcjogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxufSk7XG4vKipcbiAqIEEgc2V0IG9mIGxvZyBsZXZlbHMgdGhhdCBjYW4gYmUgdXNlZCB0byBjb250cm9sIHRoZSBhbW91bnQgb2YgbG9nZ2luZyBvdXRwdXRcbiAqIGZyb20gdmFyaW91cyBwYXJ0cyBvZiB0aGUgSW5uZ2VzdCBsaWJyYXJ5LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2dMZXZlbHMgPSBbXG4gICAgXCJmYXRhbFwiLFxuICAgIFwiZXJyb3JcIixcbiAgICBcIndhcm5cIixcbiAgICBcImluZm9cIixcbiAgICBcImRlYnVnXCIsXG4gICAgXCJzaWxlbnRcIixcbl07XG4vKipcbiAqIFRoaXMgc2NoZW1hIGlzIHVzZWQgaW50ZXJuYWxseSB0byBzaGFyZSB0aGUgc2hhcGUgb2YgYSBjb25jdXJyZW5jeSBvcHRpb25cbiAqIHdoZW4gdmFsaWRhdGluZyBjb25maWcuIFdlIGNhbm5vdCBhZGQgY29tbWVudHMgdG8gWm9kIGZpZWxkcywgc28gd2UganVzdCB1c2VcbiAqIGFuIGV4dHJhIHR5cGUgY2hlY2sgdG8gZW5zdXJlIGl0IG1hdGNoZXMgb3VyIGV4cG9ydGVkIGV4cGVjdGF0aW9ucy5cbiAqL1xuY29uc3QgY29uY3VycmVuY3lPcHRpb25TY2hlbWEgPSB6b2RfMS56LnN0cmljdE9iamVjdCh7XG4gICAgbGltaXQ6IHpvZF8xLnoubnVtYmVyKCksXG4gICAga2V5OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgc2NvcGU6IHpvZF8xLnouZW51bShbXCJmblwiLCBcImVudlwiLCBcImFjY291bnRcIl0pLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IF9jaGVja0NvbmN1cnJlbmN5U2NoZW1hQWxpZ25zID0gdHJ1ZTtcbi8qKlxuICogVGhlIHNjaGVtYSB1c2VkIHRvIHJlcHJlc2VudCBhbiBpbmRpdmlkdWFsIGZ1bmN0aW9uIGJlaW5nIHN5bmNlZCB3aXRoXG4gKiBJbm5nZXN0LlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgdG8gdmFsaWRhdGUgdGhlIHNoYXBlIG9mIGEgY29uZmlnIG9iamVjdFxuICogYW5kIG5vdCB1c2VkIGZvciBmZWF0dXJlIGNvbXBhdGliaWxpdHksIHN1Y2ggYXMgZmVhdHVyZSBYIGJlaW5nIGV4Y2x1c2l2ZVxuICogd2l0aCBmZWF0dXJlIFk7IHRoZXNlIHNob3VsZCBiZSBoYW5kbGVkIG9uIHRoZSBJbm5nZXN0IHNpZGUuXG4gKi9cbmV4cG9ydHMuZnVuY3Rpb25Db25maWdTY2hlbWEgPSB6b2RfMS56LnN0cmljdE9iamVjdCh7XG4gICAgbmFtZTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGlkOiB6b2RfMS56LnN0cmluZygpLFxuICAgIHRyaWdnZXJzOiB6b2RfMS56LmFycmF5KHpvZF8xLnoudW5pb24oW1xuICAgICAgICB6b2RfMS56LnN0cmljdE9iamVjdCh7XG4gICAgICAgICAgICBldmVudDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgICAgIGV4cHJlc3Npb246IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgfSksXG4gICAgICAgIHpvZF8xLnouc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgICAgIGNyb246IHpvZF8xLnouc3RyaW5nKCksXG4gICAgICAgIH0pLFxuICAgIF0pKSxcbiAgICBzdGVwczogem9kXzEuei5yZWNvcmQoem9kXzEuei5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBpZDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgbmFtZTogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgcnVudGltZTogem9kXzEuei5zdHJpY3RPYmplY3Qoe1xuICAgICAgICAgICAgdHlwZTogem9kXzEuei51bmlvbihbem9kXzEuei5saXRlcmFsKFwiaHR0cFwiKSwgem9kXzEuei5saXRlcmFsKFwid3NcIildKSxcbiAgICAgICAgICAgIHVybDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgfSksXG4gICAgICAgIHJldHJpZXM6IHpvZF8xLnpcbiAgICAgICAgICAgIC5zdHJpY3RPYmplY3Qoe1xuICAgICAgICAgICAgYXR0ZW1wdHM6IHpvZF8xLnoubnVtYmVyKCkub3B0aW9uYWwoKSxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vcHRpb25hbCgpLFxuICAgIH0pKSxcbiAgICBpZGVtcG90ZW5jeTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIGJhdGNoRXZlbnRzOiB6b2RfMS56XG4gICAgICAgIC5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBtYXhTaXplOiB6b2RfMS56Lm51bWJlcigpLFxuICAgICAgICB0aW1lb3V0OiB6b2RfMS56LnN0cmluZygpLFxuICAgICAgICBrZXk6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICByYXRlTGltaXQ6IHpvZF8xLnpcbiAgICAgICAgLnN0cmljdE9iamVjdCh7XG4gICAgICAgIGtleTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBsaW1pdDogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgcGVyaW9kOiB6b2RfMS56LnN0cmluZygpLnRyYW5zZm9ybSgoeCkgPT4geCksXG4gICAgfSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgdGhyb3R0bGU6IHpvZF8xLnpcbiAgICAgICAgLnN0cmljdE9iamVjdCh7XG4gICAgICAgIGtleTogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgICAgICBsaW1pdDogem9kXzEuei5udW1iZXIoKSxcbiAgICAgICAgcGVyaW9kOiB6b2RfMS56LnN0cmluZygpLnRyYW5zZm9ybSgoeCkgPT4geCksXG4gICAgICAgIGJ1cnN0OiB6b2RfMS56Lm51bWJlcigpLm9wdGlvbmFsKCksXG4gICAgfSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG4gICAgc2luZ2xldG9uOiB6b2RfMS56XG4gICAgICAgIC5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBrZXk6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgbW9kZTogem9kXzEuei5lbnVtKFtcInNraXBcIiwgXCJjYW5jZWxcIl0pLFxuICAgIH0pXG4gICAgICAgIC5vcHRpb25hbCgpLFxuICAgIGNhbmNlbDogem9kXzEuelxuICAgICAgICAuYXJyYXkoem9kXzEuei5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBldmVudDogem9kXzEuei5zdHJpbmcoKSxcbiAgICAgICAgaWY6IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICAgICAgdGltZW91dDogem9kXzEuei5zdHJpbmcoKS5vcHRpb25hbCgpLFxuICAgIH0pKVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICBkZWJvdW5jZTogem9kXzEuelxuICAgICAgICAuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAga2V5OiB6b2RfMS56LnN0cmluZygpLm9wdGlvbmFsKCksXG4gICAgICAgIHBlcmlvZDogem9kXzEuei5zdHJpbmcoKS50cmFuc2Zvcm0oKHgpID0+IHgpLFxuICAgICAgICB0aW1lb3V0OiB6b2RfMS56XG4gICAgICAgICAgICAuc3RyaW5nKClcbiAgICAgICAgICAgIC50cmFuc2Zvcm0oKHgpID0+IHgpXG4gICAgICAgICAgICAub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICB0aW1lb3V0czogem9kXzEuelxuICAgICAgICAuc3RyaWN0T2JqZWN0KHtcbiAgICAgICAgc3RhcnQ6IHpvZF8xLnpcbiAgICAgICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAgICAgLnRyYW5zZm9ybSgoeCkgPT4geClcbiAgICAgICAgICAgIC5vcHRpb25hbCgpLFxuICAgICAgICBmaW5pc2g6IHpvZF8xLnpcbiAgICAgICAgICAgIC5zdHJpbmcoKVxuICAgICAgICAgICAgLnRyYW5zZm9ybSgoeCkgPT4geClcbiAgICAgICAgICAgIC5vcHRpb25hbCgpLFxuICAgIH0pXG4gICAgICAgIC5vcHRpb25hbCgpLFxuICAgIHByaW9yaXR5OiB6b2RfMS56XG4gICAgICAgIC5zdHJpY3RPYmplY3Qoe1xuICAgICAgICBydW46IHpvZF8xLnouc3RyaW5nKCkub3B0aW9uYWwoKSxcbiAgICB9KVxuICAgICAgICAub3B0aW9uYWwoKSxcbiAgICBjb25jdXJyZW5jeTogem9kXzEuelxuICAgICAgICAudW5pb24oW1xuICAgICAgICB6b2RfMS56Lm51bWJlcigpLFxuICAgICAgICBjb25jdXJyZW5jeU9wdGlvblNjaGVtYS50cmFuc2Zvcm0oKHgpID0+IHgpLFxuICAgICAgICB6b2RfMS56XG4gICAgICAgICAgICAuYXJyYXkoY29uY3VycmVuY3lPcHRpb25TY2hlbWEudHJhbnNmb3JtKCh4KSA9PiB4KSlcbiAgICAgICAgICAgIC5taW4oMSlcbiAgICAgICAgICAgIC5tYXgoMiksXG4gICAgXSlcbiAgICAgICAgLm9wdGlvbmFsKCksXG59KTtcbmNvbnN0IG9rID0gKGRhdGEpID0+IHtcbiAgICByZXR1cm4geyBvazogdHJ1ZSwgdmFsdWU6IGRhdGEgfTtcbn07XG5leHBvcnRzLm9rID0gb2s7XG5jb25zdCBlcnIgPSAoZXJyb3IpID0+IHtcbiAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yIH07XG59O1xuZXhwb3J0cy5lcnIgPSBlcnI7XG5leHBvcnRzLmluQmFuZFN5bmNSZXF1ZXN0Qm9keVNjaGVtYSA9IHpvZF8xLnouc3RyaWN0T2JqZWN0KHtcbiAgICB1cmw6IHpvZF8xLnouc3RyaW5nKCksXG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/inngest/version.js":
/*!*****************************************!*\
  !*** ./node_modules/inngest/version.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.version = void 0;\n// Generated by genversion.\nexports.version = \"3.40.1\";\n//# sourceMappingURL=version.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvaW5uZ2VzdC92ZXJzaW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZiIsInNvdXJjZXMiOlsiL1VzZXJzL2hhcnNoc2hyaXZhc3Rhdi9EZXNrdG9wL0NvZGluZyBQcm9qZWN0cy9Kb2ItQXNzaXN0YW50LUFnZW50L25vZGVfbW9kdWxlcy9pbm5nZXN0L3ZlcnNpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG4vLyBHZW5lcmF0ZWQgYnkgZ2VudmVyc2lvbi5cbmV4cG9ydHMudmVyc2lvbiA9IFwiMy40MC4xXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/inngest/version.js\n");

/***/ })

};
;